<chapter id="chapter-serql">
	<title>The SeRQL query language (revision 3.0)</title>

	<section>
		<title>Revisions</title>
		<section>
			<title>revision 1.1</title>
			<para>
				SeRQL revision 1.1 is a syntax revision (see issue tracker item
				<ulink
					url="http://www.openrdf.org/issues/secure/ViewIssue.jspa?key=SES-75">SES-75</ulink>).
				This document describes the revised syntax. From Sesame release
				1.2-RC1 onwards, the old syntax is no longer supported.
			</para>
		</section>
		<section>
			<title>revision 1.2</title>
			<para>
				SeRQL revision 1.2 covers a set of new functions and operators:
			</para>
			<itemizedlist>
				<listitem>
					Specification of blank node identifiers
					(<xref linkend="section-blanknodes"/>).
				</listitem>
				<listitem>
					Case sensitive string matching
					(<xref linkend="section-like"/>).
				</listitem>
				<listitem>
					New functions isBNode(), isURI()
					(<xref linkend="section-isuri"/>).
				</listitem>
				<listitem>
					Nested WHERE clause for optional path expressions
					(<xref linkend="nested-where"/>).
				</listitem>
				<listitem>
					New functions namespace(), localName()
					(<xref linkend="section-namespace"/>).
				</listitem>
				<listitem>
					OWL default namespace
					(<xref linkend="section-usingns"/>).
				</listitem>
				<listitem>
					Set operations
					(<xref linkend="section-setoper"/>).
				</listitem>
				<listitem>
					Nested queries
					(<xref linkend="section-nesting"/>).
				</listitem>
				<listitem>
					Set membership operator
					(<xref linkend="section-in"/>).
				</listitem>
				<listitem>
					ANY and ALL keywords
					(<xref linkend="section-any"/>).
				</listitem>
				<listitem>
					Existential quantification
					(<xref linkend="section-exists"/>).
				</listitem>
			</itemizedlist>
			<para>
				New operations have been marked with (R1.2) where appropriate in
				this document.
			</para>
		</section>
		<section>
			<title>revision 2.0</title>
			<para>
				SeRQL revision 2.0 is an extension of SeRQL that offers
				functionality for querying contexts. See
				<xref linkend="section-context"/> for details.
			</para>
		</section>
		<section>
			<title>revision 3.0</title>
			<para>
				SeRQL revision 3.0 modifies SeRQL to be more like SPARQL,
				adopting its semantics and operators. Main backwards
				compatiblity issues with revision 2.0 are:
			</para>
			<itemizedlist>
				<listitem>
					The NULL value has been deprecated; the BOUND-operator should
					now be used instead. For now, the SeRQL parser will
					automatically translate NULL values to BOUND-operators as much
					as possible.
				</listitem>
				<listitem>
					The semantics of optional joins have been changed from the
					existing iterative semantics to the better defined
					compositional semantics that is used in SPARQL. This change
					will only affect some corner cases that are unlikely to
					appear in actual queries.
				</listitem>
			</itemizedlist>
		</section>
	</section> <!-- Revisions -->
	<section>
		<title>Introduction</title>
		<para>
			SeRQL ("Sesame RDF Query Language", pronounced "circle") is an RDF
			query language that is very similar to SPARQL, but with other syntax.
			SeRQL was originally developed as a better alternative for the query
			languages RQL and RDQL. A lot of SeRQL's features can now be found in
			<ulink url="http://www.w3.org/TR/rdf-sparql-query/">SPARQL</ulink>
			and SeRQL has adopted some of SPARQL's features in return. 
		</para>
		<para>
			This document briefly shows all of these features. After reading
			through this document one should be able to write SeRQL queries.
		</para>
	</section> <!-- Introduction -->

	<section>
		<title>URIs, literals and variables</title>
		<para>
			URIs and literals are the basic building blocks of RDF. For a query
			language like SeRQL, variables are added to this list. The following
			sections will show how to write these down in SeRQL.
		</para>

		<section>
			<title>Variables</title>
			<para>
				Variables are identified by names. These names must start with a
				letter or an underscore ('_') and can be followed by zero or
				more letters, numbers, underscores, dashes ('-') or dots ('.').
				Examples variable names are:
			</para>
			<itemizedlist>
				<listitem>Var1</listitem>
				<listitem>_var2</listitem>
				<listitem>unwise.var-name_isnt-it</listitem>
			</itemizedlist>
			<para>
				SeRQL keywords are not allowed to be used as variable names.
				Currently, the following keywords are used or reserved for
				future use in SeRQL: select, construct, from, where, using,
				namespace, true, false, not, and, or, like, label, lang,
				datatype, null, bound, isresource, isliteral, sort, in, union,
				intersect, minus, exists, forall, distinct, limit, offset.
			</para>
			<para>
				Keywords in SeRQL are all case-insensitive, this in contrast to
				variable names; these are case-sensitive.
			</para>
		</section>

		<section>
			<title>URIs</title>
			<para>
				There are two ways to write down URIs in SeRQL: either as full
				URIs or as abbreviated URIs. Full URIs must be surrounded with
				"&lt;" and "&gt;". Examples of this are:
			</para>
			<itemizedlist>
				<listitem><![CDATA[<http://www.openrdf.org/index.html>]]></listitem>
				<listitem><![CDATA[<http://www.w3.org/1999/02/22-rdf-syntax-ns#type>]]></listitem>
				<listitem><![CDATA[<mailto:sesame@openrdf.org>]]></listitem>
				<listitem><![CDATA[<file:///C:\rdffiles\test.rdf>]]></listitem>
			</itemizedlist>
			<para>
				As URIs tend to be long strings with the first part being shared
				by several of them (i.e. the namespace), SeRQL allows one to use
				abbreviated URIs (or QNames) by defining (short) names for these
				namespaces which are called "prefixes". A QName always starts
				with one of the defined prefixes and a colon (":"). After this
				colon, the part of the URI that is not part of the namespace
				follows. The first part, consisting of the prefix and the colon,
				is replaced by the full namespace by the query engine. Some
				example QNames are:
			</para>
			<itemizedlist>
				<listitem>sesame:index.html</listitem>
				<listitem>rdf:type</listitem>
				<listitem>foaf:Person</listitem>
			</itemizedlist>
		</section>

		<section>
			<title>Literals</title>
			<para>
				RDF literals consist of three parts: a label, a language tag,
				and a datatype. The language tag and the datatype are optional
				and at most one of these two can accompany a label (a literal
				can not have both a language tag and a datatype). The notation
				of literals in SeRQL has been modelled after their notation in
				N-Triples; literals start with the label, which is surrounded by
				double quotes, optionally followed by a language tag with a "@"
				prefix or by a datatype URI with a "^^" prefix. Example literals
				are:
			</para>
			<itemizedlist>
				<listitem>"foo"</listitem>
				<listitem>"foo"@en</listitem>
				<listitem><![CDATA["<foo/>"^^<http://www.w3.org/1999/02/22-rdf-syntax-ns#XMLLiteral>]]></listitem>
			</itemizedlist>
			<para>
				The SeRQL notation for abbreviated URIs can also be used. When the
				prefix rdf is mapped to the namespace
				http://www.w3.org/1999/02/22-rdf-syntax-ns#, the last example
				literal could also have been written down like:
			</para>
			<itemizedlist>
				<listitem><![CDATA["<foo/>"^^rdf:XMLLiteral]]></listitem>
			</itemizedlist>
			<para>
				SeRQL has also adopted the character escapes from N-Triples;
				special characters can be escaped by prefixing them with a
				backslash. One of the special characters is the double quote.
				Normally, a double quote would signal the end of a literal's
				label. If the double quote is part of the label, it needs to be
				escaped. For example, the sentence John said: "Hi!" can be
				encoded in a SeRQL literals as: "John said: \"Hi!\"".
			</para>
			<para>
				As the backslash is a special character itself, it also needs
				to be escaped. To encode a single backslash in a literal's
				label, two backslashes need to be written in the label. For
				example, a Windows directory would be encoded as:
				"C:\\Program Files\\Apache Tomcat\\".
			</para>
			<para>
				SeRQL has functions for extracting each of the three parts of a
				literal. These functions are label, lang, and datatype.
				label("foo"@en) extracts the label "foo", lang("foo"@en) extracts
				the language tag "en", and datatype("foo"^^rdf:XMLLiteral)
				extracts the datatype rdf:XMLLiteral. The use of these functions
				is explained later.
			</para>
		</section>
		<section id="section-blanknodes">
			<title>Blank Nodes (R1.2)</title>
			<para>
				RDF has a notion of blank nodes. These are nodes in the RDF graph
				that are not labeled with a URI or a literal. The interpretation
				of such blank nodes is as a form of existential quantification:
				it allows one to assert that "there exists a node such that..."
				without specifying what that particular node is. Blank nodes do in
				fact often have identifiers, but these identifiers are assigned
				internally by whatever processor is processing the graph and they
				are only valid in the local context, not as global identifiers
				(unlike URIs). 
			</para>
			<para>
				Strictly speaking blank nodes are only addressable indirectly, by
				querying for one or more properties of the node. However, SeRQL,
				as a practical shortcut, allows blank node identifiers to be used
				in queries. The syntax for blank nodes is adopted from N-Triples,
				using a QName-like syntax with "_" as the namespace prefix, and
				the internal blank node identifier as the local name. For example:
			</para>
			<itemizedlist>
				<listitem><![CDATA[_:bnode1]]></listitem>
			</itemizedlist>
			<para>
				This identifies the blank node with internal identifier "bnode1".
				These blank node identifiers can be used in the same way that
				normal URIs or QNames can be used.
			</para>
			<para> 
				<emphasis role="strong">Caution:</emphasis> It is important to
				realize that addressing blank nodes in this way makes SeRQL
				queries non-portable across repositories. There is no guarantee
				that in two repositories, even if they contain identical datasets,
				the blank node identifiers will be identical. It may well be that
				"bnode1" in repository A is a completely different blank node than
				"bnode1" in repository B. Even in the same repository, it is not
				guaranteed that blank node identifiers are stable over updates: if
				certain statements are added to or removed from a repository, it
				is not guaranteed "bnode1" still identifies the same blank node
				that it did before the update operation.
			</para>
		</section>
	</section> <!-- URIs, literals and variables -->

	<section>
		<title>Path expressions</title>
		<para>
			One of the most prominent parts of SeRQL are path expressions. Path
			expressions are expressions that match specific paths through an RDF
			graph. 
		</para>

		<section>
			<title>Basic path expressions</title>
			<para>
				Imagine that we want to query an RDF graph for persons who work
				for companies that are IT companies. Querying for this
				information comes down to finding the following pattern in the
				RDF graph (gray nodes denote variables):
			</para>
			<figure id="figure-serql-basic-pe" float="1">
				<title>A basic path expression</title>
				<mediaobject>
					<imageobject>
						<imagedata fileref="figures/serql-basic-pe.png"/>
					</imageobject>
				</mediaobject>
			</figure>
			<para>
				The SeRQL notation for path expressions resembles the picture
				above; it is written down as:
			</para>
			<screen><![CDATA[
{Person} foo:worksFor {Company} rdf:type {foo:ITCompany}]]></screen>
			<para>
				The parts surrounded by curly brackets represent the nodes in
				the RDF graph, the parts between these nodes represent the
				edges in the graph. The direction of the arcs (properties) in
				SeRQL path expressions is always from left to right.
			</para>
			<para>
				In SeRQL queries, multiple path expressions can be specified by
				seperating them with commas. For example, the path expression
				show before can also be written down as two smaller path
				expressions:
			</para>
			<screen><![CDATA[
{Person} foo:worksFor {Company},
{Company} rdf:type {foo:ITCompany}]]></screen>
			<para>
				The nodes and edges in the path expressions can be variables,
				URIs and literals. Also, a node can be left empty in case one is
				not interested in the value of that node. Here are some more
				example path expressions to illustrate this:
			</para>
			<itemizedlist>
				<listitem>
<![CDATA[{Person} foo:worksFor {} rdf:type {foo:ITCompany}]]>
				</listitem>
				<listitem>
<![CDATA[{Painting} ex:painted_by {} ex:name {"Picasso"}]]>
				</listitem>
				<listitem>
<![CDATA[{comic:RoadRunner} SomeRelation {foo:WillyECoyote}]]>
				</listitem>
			</itemizedlist>
		</section>

		<section>
			<title>Path expression short cuts</title>
			<para>
				Each and every path can be constructed using a set of basic path
				expressions. Sometimes, however, it is nicer to use one of the
				available short cuts. There are three types of short cuts:
			</para>

			<section>
				<title>Multi-value nodes</title>
				<para>
					In situations where one wants to query for two or more
					statements with identical subject and predicate, the subject
					and predicate do not have to be repeated over and over
					again. Instead, a multi-value node can be used:
				</para>
				<screen><![CDATA[
{subj1} pred1 {obj1, obj2, obj3}]]></screen>
				<para>
					A built-in constraint on this construction is that each value
					for the variables in the multi-value node is unique (i.e. they
					are pairwise disjoint). Therefore, this path expression is
					equivalent to the following combination of path expressions and
					boolean constraints:
				</para>
				<screen><![CDATA[
FROM
  {subj1} pred1 {obj1},
  {subj1} pred1 {obj2},
  {subj1} pred1 {obj3}
WHERE obj1 != obj2 AND obj1 != obj3 AND obj2 != obj3]]></screen>
				<para>
					Or graphically:
				</para>
				<figure id="figure-serql-multival-nodes" float="1">
					<title>Multi-value nodes</title>
					<mediaobject>
						<imageobject>
							<imagedata fileref="figures/serql-multival-nodes.png"/>
						</imageobject>
					</mediaobject>
				</figure>
				<para>
					Multi-value nodes can also be used when statements share the
					predicate and object, e.g.:
				</para>
				<screen><![CDATA[
{subj1, subj2, subj3} pred1 {obj1}]]></screen>
				<para>
					When used in a longer path expression, multi-value nodes
					apply to both the part left of the node and the part right
					of the node. The following path expression:
				</para>
				<screen><![CDATA[
{first} pred1 {middle1, middle2} pred2 {last}]]></screen>
				<para>
					matches the following graph:
				</para>
				<figure id="figure-serql-multival-nodes2" float="1">
					<title>Multi-value nodes in a longer path expression</title>
					<mediaobject>
						<imageobject>
							<imagedata fileref="figures/serql-multival-nodes2.png"/>
						</imageobject>
					</mediaobject>
				</figure>
			</section>

			<section>
				<title>Branches</title>
				<para>
					One of the shorts cuts that is probably used most, is the
					notation for branches in path expressions. There are lots of
					situations where one wants to query multiple properties of a
					single subject. Instead of repeating the subject over and
					over again, one can use a semi-colon to attach a
					predicate-object combination to the subject of the last part
					of a path expression, e.g.:
				</para>
				<screen><![CDATA[
{subj1} pred1 {obj1};
        pred2 {obj2}]]></screen>
				<para>
					Which is equivalent to:
				</para>
				<screen><![CDATA[
{subj1} pred1 {obj1},
{subj1} pred2 {obj2}]]></screen>
				<para>
					Or graphically:
				</para>
				<figure id="figure-serql-branch" float="1">
					<title>Branches in a path expression</title>
					<mediaobject>
						<imageobject>
							<imagedata fileref="figures/serql-branch.png"/>
						</imageobject>
					</mediaobject>
				</figure>
				<para>
					A more advanced example is:
				</para>
				<screen><![CDATA[
{first} pred {} pred1 {obj1};
                pred2 {obj2} pred3 {obj3}]]></screen>
				<para>
					Which matches the following graph:
				</para>
				<figure id="figure-serql-branch2" float="1">
					<title>Branches in a longer path expression</title>
					<mediaobject>
						<imageobject>
							<imagedata fileref="figures/serql-branch2.png"/>
						</imageobject>
					</mediaobject>
				</figure>
				<para>
					Note that an anonymous variable is used in the middle of
					the path expressions.
				</para>
			</section>

			<section>
				<title>Reified statements</title>
				<para>
					The last short cut is a short cut for reified statements. A
					path expression representing a single statement
					(i.e. {node} edge {node}) can be written between the curly
					brackets of a node, e.g.:
				</para>
				<screen><![CDATA[
{ {reifSubj} reifPred {reifObj} } pred {obj}]]></screen>
				<para>
					This would be equivalent to querying (using "rdf:" as a
					prefix for the RDF namespace, and "Statement" as a
					variable for storing the statement's URI):
				</para>
				<screen><![CDATA[
{Statement} rdf:type {rdf:Statement},
{Statement} rdf:subject {reifSubj},
{Statement} rdf:predicate {reifPred},
{Statement} rdf:object {reifObj},
{Statement} pred {obj}]]></screen>
				<para>
					Again, graphically:
				</para>
				<figure id="figure-serql-reif" float="1">
					<title>A reification path expression</title>
					<mediaobject>
						<imageobject>
							<imagedata fileref="figures/serql-reif.png"/>
						</imageobject>
					</mediaobject>
				</figure>
			</section>
		</section>

		<section id="section-optional">
			<title>Optional path expressions</title>
			<para>
				Optional path expressions differ from 'normal' path expressions
				in that they do not <emphasis>have</emphasis> to be matched to
				find query results. The SeRQL query engine will try to find
				paths in the RDF graph matching the path expression, but when
				it cannot find any paths it will skip the expression and leave
				any variables in it unbound.
			</para>
			<para>
				Consider an RDF graph that contains information about people
				that have names, ages, and <emphasis>optionally</emphasis>
				e-mail addresses. This is a situation that is very common in RDF
				data. A logical query on this data is a query that yields all
				names, ages and, when available, e-mail addresses of people,
				e.g.:
			</para>
			<screen><![CDATA[
{Person} ex:name {Name};
         ex:age  {Age};
         ex:email {EmailAddress}]]></screen>
		 	<para>
				However, using normal path expressions like in the query above,
				people without e-mail address will not be included in the query
				result. With optional path expressions, one can indicate that a
				specific (part of a) path expression is optional. This is done
				using square brackets, i.e.:
			</para>
			<screen><![CDATA[
{Person} ex:name {Name};
         ex:age  {Age};
        [ex:email {EmailAddress}]]]></screen>
		 	<para>
				Or alternatively:
			</para>
			<screen><![CDATA[
 {Person} ex:name {Name};
          ex:age  {Age},
[{Person} ex:email {EmailAddress}]]]></screen>
		 	<para>
				In contrast to the first path expressions, this expression will
				also match people without an e-mail address. For these people,
				the variable EmailAddress will be unbound.
			</para>
			<para>
				Optional path expressions can also be nested. This is useful in
				situations where the existence of a specific path is dependent
				on the existence of another path. For example, the following
				path expression queries for the titles of all known documents
				and, if the author of the document is known, the name of the
				author (if it is known) and his e-mail address (if it is known):
			</para>
			<screen><![CDATA[
{Document} ex:title {Title};
          [ex:author {Author} [ex:name {Name}];
                              [ex:email {Email}]]]]></screen>
			<para>
				With this path expression, the SeRQL query engine will not try
				to find the name and e-mail address of an author when it cannot
				even find the resource representing the author.
			</para>

		</section>
	</section> <!-- Path expressions -->

	<section>
		<title>Select- and construct queries</title>
		<para>
			The SeRQL query language supports two querying concepts. The first
			one can be characterized as returning a table of values, or a set of
			variable-value bindings. The second one returns an RDF graph, which
			can be a subgraph of the graph being queried, or a graph containing
			information that is derived from it. The first type of queries are
			called "select queries", the second type of queries are called
			"construct queries".
		</para>
		<para>
			A SeRQL query is typically built up from one to seven clauses. For
			select queries these clauses are: SELECT, FROM, FROM CONTEXT, WHERE,
			LIMIT, OFFSET and USING NAMESPACE. One might recognize some of these
			clauses from SQL, but their usage is slightly different. For construct
			queries the clauses are the same with the exception of the first;
			construct queries start with a CONSTRUCT clause instead of a SELECT
			clause. Except for the first clause (SELECT or CONSTRUCT), all
			clauses are optional.
		</para>
		<para>
			The first clause (i.e. SELECT or CONSTRUCT) determines what is done
			with the results that are found. In a SELECT clause, one can specify
			which variable values should be returned. In a CONSTRUCT clause, one
			can specify which statements should be returned.
		</para>
		<para>
			The FROM clause specifies path expressions, which were explained in
			the previous section. It defines the paths in an RDF graph that are
			relevant to the query. Note that, when the FROM clause is not specified,
			the query will simply return the constants specified in the SELECT or
			CONSTRUCT clause.
		</para>
		<para>
			The FROM CONTEXT clause is new in SeRQL revision 2.0. It is a
			variant of the FROM clause that allows one to constrain the path
			expressions in the clause to one or more contexts. Using context in
			querying will be explained in more detail in
			<xref linkend="section-context"/>.
		</para>
		<para>
			The WHERE clause specifies additional (Boolean) constraints on the
			values in the path expressions. These are constraints on the nodes
			and edges of the paths that cannot be expressed in the path expressions
			themselves.
		</para>
		<para>
			The LIMIT and OFFSET clauses can be used separately or combined in
			order to get a subset of all query answers. Their usage is very
			similar to the LIMIT and OFFSET clauses in SQL queries. The LIMIT
			clause determines the (maximum) number of query answers that will be
			returned. The OFFSET clause determines which query answer will be
			returned as the first result, skipping as many query results as
			specified in this clause.
		</para>
		<para>
			Finally, the USING NAMESPACE clause can be used to declare namespace
			prefixes. These are the mappings from prefixes to namespaces that
			were referred to in one of previous sections about (abbreviated)
			URIs.
		</para>
		<para>
			The WHERE, LIMIT, OFFSET and USING NAMESPACE clauses will be
			explained in one of the next sections. The following section will
			explain the SELECT and FROM clause.
		</para>
	</section> <!-- Select- and construct queries -->

	<section>
		<title>Select queries</title>
		<para>
			As said before, select queries return tables of values, or sets of
			variable-value bindings. Which values are returned can be specified
			in the select clause. One can specify variables and/or values in
			the select clause, seperated by commas. The following example query
			returns all URIs of classes:
		</para>
		<screen><![CDATA[
SELECT C
FROM {C} rdf:type {rdfs:Class}]]></screen>
		<para>
			It is also possible to use a '*' in the SELECT clause. In that case,
			all variable values will be returned, e.g.:
		</para>
		<screen><![CDATA[
SELECT *
FROM {S} rdfs:label {O}]]></screen>
		<para>
			This query will return the values of the variables S and O.
		</para>
		<screen><![CDATA[
SELECT O, S
FROM {S} rdfs:label {O}]]></screen>
		<para>
			By default, the results of a select query are not filtered for
			duplicate rows. Because of the nature of the above queries, these
			queries will never return duplicates. However, more complex queries
			might result in duplicate result rows. These duplicates can be
			filtered out by the SeRQL query engine. To enable this functionality,
			one needs to specify the DISTINCT keyword after the select keyword.
			For example:
		</para>
		<screen><![CDATA[
SELECT DISTINCT *
FROM {Country1} ex:borders {} ex:borders {Country2}
USING NAMESPACE
    ex = <http://example.org/things#>]]></screen>
	</section> <!-- Select queries -->

	<section>
		<title>Construct queries</title>
		<para>
			Construct queries return RDF graphs as set of statements. The statements
			that a query should return can be specified in the construct clause
			using the previously explained path expressions. The following is an
			example construct query:
		</para>
		<screen><![CDATA[
CONSTRUCT {Parent} ex:hasChild {Child}
FROM {Child} ex:hasParent {Parent}
USING NAMESPACE
    ex = <http://example.org/things#>]]></screen>
		<para>
			This query defines the inverse of the property ex:hasParent to be
			ex:hasChild. This is just one example of a query that produces
			information that is derived from the original information. Here is
			one more example:
		</para>
		<screen><![CDATA[
CONSTRUCT
    {Artist} rdf:type {ex:Painter};
             ex:hasPainted {Painting}
FROM
    {Artist} rdf:type {ex:Artist};
             ex:hasCreated {Painting} rdf:type {ex:Painting}
USING NAMESPACE
    ex = <http://example.org/things#>]]></screen>
		<para>
			This query derives that an artist who has created a painting, is a
			painter. The relation between the painter and the painting is
			modelled to be art:hasPainted.
		</para>
		<para>
			Instead of specifying a path expression in the CONSTRUCT clause, one
			can also use a '*'. In that case, the CONSTRUCT clause is identical
			to the FROM clause. This allows one to extract a subgraph from a
			larger graph, e.g.:
		</para>
		<screen><![CDATA[
CONSTRUCT *
FROM {SUB} rdfs:subClassOf {SUPER}]]></screen>
		<para>
			This query extracts all rdfs:subClassOf relations from an RDF graph.
		</para>
		<para>
			Just like with select queries, the results of a construct query are
			not filtered for duplicate statements by default. Again, these
			duplicates are filtered out by the SeRQL query engine if the
			DISTINCT keyword is specified after the construct keyword, for example:
		</para>
		<screen><![CDATA[
CONSTRUCT DISTINCT
    {Artist} rdf:type {ex:Painter}
FROM
    {Artist} rdf:type {ex:Artist};
             ex:hasCreated {} rdf:type {ex:Painting}
USING NAMESPACE
    ex = <http://example.org/things#>]]></screen>
	</section> <!-- Construct queries -->

	<section>
		<title>The WHERE clause</title>
		<para>
			The third clause in a query is the WHERE clause. This is an optional
			clause in which one can specify Boolean constraints on variables. 
		</para>
		<para>
			The following sections will explain the available Boolean
			expressions for use in the WHERE clause.
			<xref linkend="nested-where"/> will explain how WHERE clauses can be
			nested inside optional path expressions.
		</para>

		<section>
			<title>Boolean constants</title>
			<para>
				There are two Boolean constants, TRUE and FALSE. The first one
				is simply always true, the last one is always false. The
				following query will never produce any results because the
				constraint in the where clause will never evaluate to true:
			</para>
			<screen><![CDATA[
SELECT *
FROM {X} Y {Z}
WHERE FALSE]]></screen>
		</section>

		<section>
			<title>Value (in)equality</title>
			<para>
				The most common boolean constraint is equality or inequality of
				values. Values can be compared using the operators "="
				(equality) and "!=" (inequality). The expression
			</para>
			<screen><![CDATA[Var = <foo:bar>]]></screen>
			<para>
				is true if the variable Var has been bound to the URI &lt;foo:bar&gt;,
				and the expression
			</para>
			<screen><![CDATA[Var1 != Var2]]></screen>
			<para>
				checks whether two variables are bound to unequal values.
			</para>
		</section>

		<section>
			<title>Numerical comparisons</title>
			<para>
				Numbers can be compared to each other using the operators "&lt;"
				(lower than), "&lt;=" (lower than or equal to), "&gt;" (greater
				than) and "&gt;=" (greater than or equal to). SeRQL uses a
				literal's datatype to determine whether its value is numerical.
				All XML Schema built-in numerical datatypes are supported, i.e.:
				xsd:float, xsd:double, xsd:decimal and all subtypes of
				xsd:decimal (xsd:long, xsd:nonPositiveInteger, xsd:byte, etc.),
				where the prefix xsd is used to reference the XML Schema
				namespace.
			</para>
			<para>
				In the following query, a comparison between values of type
				xsd:positiveInteger is used to retrieve all countries that have
				a population of less than 1 million:
			</para>
			<screen><![CDATA[
SELECT Country
FROM {Country} ex:population {Population}
WHERE Population < "1000000"^^xsd:positiveInteger
USING NAMESPACE
    ex = <http://example.org/things#>]]></screen>
			<para>
				If one want to compare values of incompatible types, one can
				try to cast one or both of the values to another type. For
				example in the above query, if the values that Population is
				bound to generally do not have a datatype, one can cast these
				values to xsd:integer to make the comparison work, e.g.:
			</para>
			<screen><![CDATA[
SELECT Country
FROM {Country} ex:population {Population}
WHERE xsd:integer(Population) < "1000000"^^xsd:positiveInteger
USING NAMESPACE
    ex = <http://example.org/things#>]]></screen>
			<para>
				SeRQL supports all value casting methods from SPARQL, see SPARQL's
				<ulink url="http://www.w3.org/TR/rdf-sparql-query/#FunctionMapping">
						Constructor Functions</ulink> for more details.
			</para>
		</section>

		<section>
			<title>bound() (R3.0)</title>
			<para>
				The bound() boolean function checks whether a specific variable has been
				bound to a value. For example, the following query returns the names of
				all people without a (known) e-mail address.
			</para>
			<screen><![CDATA[
SELECT Name
FROM {Person} foaf:name {Name};
             [ex:email {EmailAddress}]
WHERE NOT BOUND(EmailAddress)
]]></screen>
		</section>

		<section id="section-isuri">
			<title>isURI() and isBNode() (R1.2)</title>
			<para>
				The isURI() and isBNode() boolean functions are more specific
				versions of isResource(). They check whether a variable is bound to
				a URI value or a BNode value, respectively. For example, the
				following query returns only URIs (and filters out all bNodes and
				literals):
			</para>
			<screen><![CDATA[
SELECT V
FROM {R} prop {V}
WHERE isURI(V)]]></screen>
		</section>

		<section id="section-like">
			<title>The LIKE operator (R1.2)</title>
			<para>
				The LIKE operator can check whether a value matches a specified
				pattern of characters. '*' characters can be used as wildcards,
				matching with zero or more characters. The rest of the
				characters are compared lexically. The pattern is
				surrounded with double quotes, just like a literal's label.
			</para>
			<screen><![CDATA[
SELECT Country
FROM {Country} ex:name {Name}
WHERE Name LIKE "Belgium"
USING NAMESPACE
    ex = <http://example.org/things#>]]></screen>
			<para>
				By default, the LIKE operator does a case-sensitive comparison:
				in the above query, the operator fails is the variable Name is
				bound to the value "belgium" instead of "Belgium". Optionally,
				one can specify that the operator should perform a
				case-insensitive comparison:
			</para>
			<screen><![CDATA[
SELECT Country
FROM {Country} ex:name {Name}
WHERE Name LIKE "belgium" IGNORE CASE
USING NAMESPACE
    ex = <http://example.org/things#>]]></screen>
			<para>
				In this query, the operator will succeed for "Belgium",
				"belgium", "BELGIUM", etc.
			</para>
			<para>
				The '*' character can be used as a wildcard to indicate
				substring matches, for example:
			</para>
			<screen><![CDATA[
SELECT Country
FROM {Country} ex:name {Name}
WHERE Name LIKE "*Netherlands"
USING NAMESPACE
    ex = <http://example.org/things#>]]></screen>
			<para>
				This query will match any country names that end with the string
				"Netherlands", for example "The Netherlands".
			</para>
		</section>

		<section>
			<title>AND, OR, NOT</title>
			<para>
				Boolean constraints and functions can be combined using the AND and OR
				operators, and negated using the NOT operator. The NOT operator
				has the highest presedence, then the AND operator, and finally
				the OR operator. Parentheses can be used to override the default
				presedence of these operators. The following query is a (kind of
				artifical) example of this:
			</para>
			<screen><![CDATA[
SELECT *
FROM {X} Prop {Y} rdfs:label {L}
WHERE NOT L LIKE "*FooBar*" AND
      (Y = <foo:bar> OR Y = <bar:foo>) AND
      isLiteral(L)]]></screen>
		</section>

		<section id="nested-where">
			<title>Nested WHERE clauses (R1.2)</title>
			<para>
				In order to be able to express boolean constraints on variables in
				optional path expressions, it is possible to use a <emphasis>nested
					WHERE clause</emphasis>. The constraints in such a nested
				WHERE clause restrict the potential matches of the optional path
				expressions, without causing the entire query to fail if the boolean
				constraint fails. 
			</para>
			<para>
				To illustrate the difference between a nested WHERE clause and a
				'normal' WHERE clause, consider the following two queries on the
				same data:
			</para>
			<para>
				Data (using Turtle format):
			</para>
			<screen><![CDATA[
@prefix foaf: <http://xmlns.com/foaf/0.1/> .
@prefix ex:   <http://example.org/> .

_:a  foaf:name   "Michael" .

_:b  foaf:name   "Rubens" .
_:b  ex:email    "rubinho@example.work".

_:b  foaf:name   "Giancarlo" .
_:b  ex:email    "giancarlo@example.work".]]></screen>
			<para>
				Query 1 (normal WHERE-clause):
			</para>
			<screen><![CDATA[
SELECT 
   Name, EmailAddress
FROM
  {Person} foaf:name {Name};
          [ex:email {EmailAddress}]
WHERE EmailAddress LIKE "g*"]]></screen>
			<para>
				Query 2 (nested WHERE-clause):
			</para>
			<screen><![CDATA[
SELECT 
   Name, EmailAddress
FROM
  {Person} foaf:name {Name};
          [ex:email {EmailAddress} WHERE EmailAddress LIKE "g*"]]]></screen>
			<para>
				In query 1, a normal WHERE clause specifies that the EmailAddress found
				by the optional expression must begin with the letter "g". The result of
				this query will be:
			</para>
			<informaltable frame="all">
				<tgroup cols="2" align="left">
					<thead>
						<row>
							<entry align="center">Name</entry>
							<entry align="center">EmailAddress</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry>Giancarlo</entry>
							<entry>"giancarlo@example.work"</entry>
						</row>
					</tbody>
				</tgroup>
			</informaltable>
			<para>
				Despite the fact that the match on EmailAddress is defined as
				optional, the persons named "Michael" and "Rubens" are
				not returned. The reason is that the WHERE clause explicitly
				says that the value bound to the optional variable must start
				with the letter "g". For Michael, no value is found, hence the
				variable is unbound, and the comparison operator fails on this.
				For Rubens, a value is found, but it does not start with
				the letter "g".
			</para>
			<para>
				In query 2, however, a nested WHERE-clause is used. This
				specifies that any binding the optional expression matches
				must begin with the letter "g". The result of this query is:
			</para>
			<informaltable frame="all">
				<tgroup cols="2" align="left">
					<thead>
						<row>
							<entry align="center">Name</entry>
							<entry align="center">EmailAddress</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry>Michael</entry>
							<entry></entry>
						</row>
						<row>
							<entry>Rubens</entry>
							<entry></entry>
						</row>
						<row>
							<entry>Giancarlo</entry>
							<entry>"giancarlo@example.work"</entry>
						</row>
					</tbody>
				</tgroup>
			</informaltable>
			<para>
				The person "Michael" is returned without a result for his email
				address because there is no email address known for him at all.
				The person "Rubens" is returned without a result for his email
				address because, although he does have an email address, it does
				not start with the letter "g".
			</para>
			<para>
				A query can contain at most one nested WHERE-clause per
				optional path expression, and at most one 'normal' WHERE-clause. 
			</para>
		</section>
	</section> <!-- The where clause -->

	<section>
		<title>Other functions</title>
		<para>
			Apart from the boolean functions and operators introduced in the
			previous section, SeRQL supports several other functions that return
			RDF terms rather than non-boolean values. These functions can be
			used in both the SELECT and the WHERE clause.
		</para>

		<section>
			<title>label(), lang() and datatype()</title>
			<para>
				The three functions label(), lang() and datatype() all operate on
				literals. The result of the label() function is the lexical form
				of the supplied literal. The lang() function returns the
				language attribute. Both functions return their result as an
				untyped literal, which can again be compared with other literals
				using (in)equality-, comparison-, and like operators. The
				result of the datatype() function is a URI, which can be
				compared to other URIs. These functions can also be used in
				SELECT clauses, but not in path expressions.
			</para>
			<para>
				An example query:
			</para>
			<screen><![CDATA[
SELECT label(L)
FROM {R} rdfs:label {L}
WHERE isLiteral(L) AND lang(L) LIKE "en*"]]></screen>
		</section>

		<section id="section-namespace">
			<title>namespace() and localName() (R1.2)</title>
			<para>
				The functions namespace() and localName() operate on URIs. The
				namespace() function returns the namespace of the supplied URI,
				as a URI object. The localName() function returns the local name
				part of the supplied URI, as a literal. These functions can also be used
				in SELECT clauses, but not in path expressions.
			</para>
			<para>
				The following query retrieves all properties of foaf:Person
				instances that are in the FOAF namespace. Notice that as a
				shorthand for the full URI, we can use a namespace prefix
				(followed by a colon) as an argument.
			</para>
			<para>
				Data:
			</para>
			<screen><![CDATA[
@prefix foaf: <http://xmlns.com/foaf/0.1/> .
@prefix ex:   <http://example.org/> .

_:a  rdf:type         foaf:Person .
_:a  my:nick          "Schumi" .
_:a  foaf:firstName   "Michael" .
_:a  foaf:knows       _:b .

_:b  rdf:type         foaf:Person .
_:b  foaf:firstName   "Rubens" .
_:b  foaf:nick        "Rubinho" .]]></screen>
			<para>
				Query:
			</para>
			<screen><![CDATA[
SELECT foafProp, Value
FROM {} foafProp {Value}
WHERE namespace(foafProp) = foaf:
USING NAMESPACE
    foaf = <http://xmlns.com/foaf/0.1/>]]></screen>
			<para>
				Result:
			</para>
			<informaltable frame="all">
				<tgroup cols="2" align="left">
					<thead>
						<row>
							<entry align="center">foafProp</entry>
							<entry align="center">Value</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry><![CDATA[<http://xmlns.com/foaf/0.1/firstName]]></entry>
							<entry>"Michael"</entry>
						</row>
						<row>
							<entry><![CDATA[<http://xmlns.com/foaf/0.1/knows]]></entry>
							<entry>_:b</entry>
						</row>
						<row>
							<entry><![CDATA[<http://xmlns.com/foaf/0.1/firstName]]></entry>
							<entry>"Rubens"</entry>
						</row>
						<row>
							<entry><![CDATA[<http://xmlns.com/foaf/0.1/nick]]></entry>
							<entry>"Rubinho"</entry>
						</row>
					</tbody>
				</tgroup>
			</informaltable>
			<para>
				In the following example, the localName() function is used to
				match two equivalent properties from different namespaces (using
				the above data).
			</para>
			<para>
				Query:
			</para>
			<screen><![CDATA[
SELECT nick
FROM {} rdf:type {foaf:Person};
        nickProp {nick}
WHERE localName(nickProp) LIKE "nick"
USING NAMESPACE
    foaf = <http://xmlns.com/foaf/0.1/>]]></screen>
			<para>
				Result:
			</para>
			<informaltable frame="all">
				<tgroup cols="1" align="left">
					<thead>
						<row>
							<entry align="center">nick</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry>"Schumi"</entry>
						</row>
						<row>
							<entry>"Rubinho"</entry>
						</row>
					</tbody>
				</tgroup>
			</informaltable>
		</section>
	</section> <!-- other functions -->

	<section>
		<title>The LIMIT and OFFSET clauses</title>
		<para>
			LIMIT and OFFSET allow you to retrieve just a portion of the results
			that are generated by the query. If a limit count is given, no more
			than that many results will be returned (but possibly less, if the
			query itself yields less results).
		</para>
		<para>
			OFFSET says to skip that many results before beginning to return
			results. OFFSET 0 is the same as omitting the OFFSET clause. If both
			OFFSET and LIMIT appear, then OFFSET rows are skipped before
			starting to count the LIMIT results that are returned.
		</para>
	</section>

	<section id="section-usingns">
		<title>The USING NAMESPACE clause</title>
		<para>
			The USING NAMESPACE clause can be used to define short prefixes for
			namespaces, which can then be used in abbreviated URIs. Multiple
			prefixes can be defined, but each declaration must have a unique
			prefix. The following query shows the use of namespace prefixes:
		</para>
		<screen><![CDATA[
CONSTRUCT
    {Artist} rdf:type {art:Painter};
             art:hasPainted {Painting}
FROM
    {Artist} rdf:type {art:Artist};
             art:hasCreated {Painting} rdf:type {art:Painting}
USING NAMESPACE
    rdf = <http://www.w3.org/1999/02/22-rdf-syntax-ns#>,
    art = <http://example.org/arts/>]]></screen>
		<para>
			The query engine will replace every occurence of rdf: in an
			abbreviated URI with http://www.w3.org/1999/02/22-rdf-syntax-ns#,
			and art: with http://example.org/arts/. So art:hasPainted
			will be resolved to the URI
			http://example.org/arts/hasPainted.
		</para>
		<para>
			Four namespaces that are used very frequently have been assigned
			prefixes by default:
		</para>
		<table>
			<title>Default namespaces</title>
			<tgroup cols="2" align="left">
				<thead>
					<row>
						<entry>Prefix</entry>
						<entry>Namespace</entry>
					</row>
				</thead>
				<tbody>
					<row>
						<entry>rdf</entry>
						<entry>http://www.w3.org/1999/02/22-rdf-syntax-ns#</entry>
					</row>
					<row>
						<entry>rdfs</entry>
						<entry>http://www.w3.org/2000/01/rdf-schema#</entry>
					</row>
					<row>
						<entry>xsd</entry>
						<entry>http://www.w3.org/2001/XMLSchema#</entry>
					</row>
					<row>
						<entry>owl</entry>
						<entry>http://www.w3.org/2002/07/owl#</entry>
					</row>
					<row>
						<entry>sesame</entry>
						<entry>http://www.openrdf.org/schema/sesame#</entry>
					</row>
				</tbody>
			</tgroup>
		</table>
		<para>
			These prefixes can be used without declaring them. If either of
			these prefixes is declared explicitly in a query, this declaration
			will override the default mapping.
		</para>
	</section> <!-- The using namespace clause -->

	<section>
		<title>Built-in predicates (REVISED in R2.0)</title>
		<para>
			SeRQL contains a number of built-in predicates. These built-ins can
			be used like any other predicate, as part of a path expression.  The
			difference with normal predicates is that the built-ins act as
			operators on the underlying rdf graph: they can be used to query for
			relations between RDF resources that are not explicitly modeled, nor
			immediately apparant from the RDF Semantics, but which are
			nevertheless very useful.
		</para>
		<para>
		  <emphasis>Note:</emphasis> in Sesame 2.0 built-in predicates are
		  only supported on repositories that have a
		  <classname>DirectTypeHierarchyInferencer</classname> Sail in the Sail
		  stack. This inferencer is a stacked Sail that can be deployed on
		  top of a normal
		  <classname>ForwardChainingRDFSInferencer</classname>.
		</para>
		<para>
			Currently, the following built-in predicates are supported:
		</para>
		<itemizedlist>
			<listitem>
				<screen><![CDATA[{X} sesame:directSubClassOf {Y}]]></screen>
				<para>
					This relation holds for every X and Y where:
				</para>
				<orderedlist>
					<listitem>X rdfs:subClassOf Y.</listitem>
					<listitem>X != Y.</listitem>
					<listitem>
						There is no class Z (Z != Y and Z != X) such that
						X rdfs:subClassOf Z and
						Z rdfs:subClassOf Y.
					</listitem>
				</orderedlist>
			</listitem>
			<listitem>
				<screen><![CDATA[{X} sesame:directSubPropertyOf {Y}]]></screen>
				<para>
					This relation holds for every X and Y where:
				</para>
				<orderedlist>
					<listitem>X rdfs:subPropertyOf Y.</listitem>
					<listitem>X != Y.</listitem>
					<listitem>
						There is no property Z (Z != X and Z != Y) such that
						X rdfs:subPropertyOf Z and
						Z rdfs:subPropertyOf Y.
					</listitem>
				</orderedlist>
			</listitem>
			<listitem>
				<screen><![CDATA[{X} sesame:directType {Y}]]></screen>
				<para>
					This relation holds for every X and Y where:
				</para>
				<orderedlist>
					<listitem>X rdf:type Y.</listitem>
					<listitem>
						There is no class Z (Z != Y) such that
						X rdf:type Z and Z rdfs:subClassOf Y.
					</listitem>
				</orderedlist>
			</listitem>
		</itemizedlist>
		<para>
			<emphasis>Note:</emphasis> the above definition takes class/property
			equivalence through cyclic subClassOf/subPropertyOf relations into account.
			This means that if A rdfs:subClassOf B, and B rdfs:subClassOf A, it holds
			that A = B.
		</para>
		<para>
			The namespace prefix 'sesame' is built-in and does not have to be
			defined in the query.
		</para>
	</section> <!-- SeRQL built-in predicates -->

	<section id="section-setoper">
		<title>Set combinatory operations</title>
		<para>
			SeRQL offers three combinatory operations that can be used to
			combine sets of query results.
		</para>
		<section>
			<title>UNION (REVISED in R3.0)</title>
			<para>
				UNION is a combinatory operation the result of which is the set of
				query answers of both its operands. This allows one to specify
				alternatives in a query solution.
			</para>
			<para>
				By default, UNION filters out duplicate answers from its operands.
				Specifying the ALL keyword ("UNION ALL") disables this filter.
			</para>
			<para>
				The following example query retrieves the titles of books in the
				data, where the property used to describe the title can be either
				from the DC 1.0 or DC 1.1 specification.
			</para>
			<para>Data:</para>
			<screen><![CDATA[
@prefix dc10:  <http://purl.org/dc/elements/1.0/> .
@prefix dc11:  <http://purl.org/dc/elements/1.1/> .

_:a  dc10:title     "The SeRQL Query Language" .
_:b  dc11:title     "The SeRQL Query Language (revision 1.2)" .

_:c  dc10:title     "SeRQL" .
_:c  dc11:title     "SeRQL (updated)" .]]></screen>
			<para>Query:</para>
			<screen><![CDATA[
SELECT title
FROM {book} dc10:title {title}

UNION

SELECT title
FROM {book} dc11:title {title}

USING NAMESPACE
    dc10 = <http://purl.org/dc/elements/1.0/>,
    dc11 = <http://purl.org/dc/elements/1.1/>]]></screen>
			<para>Result:</para>
			<informaltable frame="all">
				<tgroup cols="1" align="left">
					<thead>
						<row>
							<entry align="center">title</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry>"The SeRQL Query Language"</entry>
						</row>
						<row>
							<entry>"The SeRQL Query Language (revision 1.2)"</entry>
						</row>
						<row>
							<entry>"SeRQL"</entry>
						</row>
						<row>
							<entry>"SeRQL (updated)"</entry>
						</row>
					</tbody>
				</tgroup>
			</informaltable>
			<para>
				The union operator simply combines the results from both subqueries,
				matching bindings by their name:
			</para>
			<screen><![CDATA[
SELECT title, "1.0" AS "version"
FROM {book} dc10:title {title}

UNION

SELECT title
FROM {x} dc11:title {title}

USING NAMESPACE
    dc10 = <http://purl.org/dc/elements/1.0/>,
    dc11 = <http://purl.org/dc/elements/1.1/>]]></screen>
			<para>
				Result:
			</para>
			<informaltable frame="all">
				<tgroup cols="2" align="left">
					<thead>
						<row>
							<entry align="center">title</entry>
							<entry align="center">version</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry>"The SeRQL Query Language"</entry>
							<entry>"1.0"</entry>
						</row>
						<row>
							<entry>"The SeRQL Query Language (revision 1.2)"</entry>
							<entry></entry>
						</row>
						<row>
							<entry>"SeRQL"</entry>
							<entry>"1.0"</entry>
						</row>
						<row>
							<entry>"SeRQL (updated)"</entry>
							<entry></entry>
						</row>
					</tbody>
				</tgroup>
			</informaltable>
		</section>

		<section>
			<title>INTERSECT (R1.2)</title>
			<para>
				The INTERSECT operation retrieves query results that occur in both
				its operands.
			</para>
			<para>
				The following query only retrieves those album creators for
				which the name is specified identically in both DC 1.0 and DC 1.1.
			</para>
			<para>
				Data:
			</para>
			<screen><![CDATA[
@prefix dc10:  <http://purl.org/dc/elements/1.0/> .
@prefix dc11:  <http://purl.org/dc/elements/1.1/> .

_:a  dc10:creator     "George" .
_:a  dc10:creator     "Ringo" .

_:b  dc11:creator     "George" .
_:b  dc11:creator     "Ringo" .

_:c  dc10:creator     "Paul" .
_:c  dc11:creator     "Paul C." .]]></screen>
			<para>
				Query:
			</para>
			<screen><![CDATA[
SELECT creator
FROM {album} dc10:creator {creator}

INTERSECT

SELECT creator
FROM {album} dc11:creator {creator}

USING NAMESPACE
    dc10 = <http://purl.org/dc/elements/1.0/>,
    dc11 = <http://purl.org/dc/elements/1.1/>]]></screen>
			<para>
				Result:
			</para>
			<informaltable frame="all">
				<tgroup cols="1" align="left">
					<thead>
						<row>
							<entry align="center">creator</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry>"George"</entry>
						</row>
						<row>
							<entry>"Ringo"</entry>
						</row>
					</tbody>
				</tgroup>
			</informaltable>
		</section>
		<section>
			<title>MINUS (R1.2)</title>
			<para>
				The Minus operation returns query results from its first operand
				which do not occur in the results from its second operand.
			</para>
			<para>
				The following query returns the titles of all albums of which
				"Paul" is not a creator.
			</para>
			<para>
				Data:
			</para>
			<screen><![CDATA[
@prefix dc10:  <http://purl.org/dc/elements/1.0/> .

_:a  dc10:creator     "George" .
_:a  dc10:title       "Sergeant Pepper" .

_:b  dc10:creator     "Paul" .
_:b  dc10:title       "Yellow Submarine" .

_:c  dc10:creator     "Paul" .
_:c  dc10:creator     "Ringo" .
_:c  dc10:title       "Let it Be" .]]></screen>
			<para>
				Query:
			</para>
			<screen><![CDATA[
SELECT title
FROM {album} dc10:title {title}

MINUS

SELECT title
FROM {album} dc10:title {title};
             dc10:creator {creator}
WHERE creator like "Paul"

USING NAMESPACE
    dc10 = <http://purl.org/dc/elements/1.0/>,
    dc11 = <http://purl.org/dc/elements/1.1/>]]></screen>
			<para>
				Result:
			</para>
			<informaltable frame="all">
				<tgroup cols="1" align="left">
					<thead>
						<row>
							<entry align="center">title</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry>"Sergeant Pepper"</entry>
						</row>
					</tbody>
				</tgroup>
			</informaltable>
		</section>
	</section> <!-- Union, Intersection, Minus -->

	<section id="section-nesting">
		<title>Query Nesting</title>
		<para>
			SeRQL has several constructs for nested queries. Nested queries can
			occur as operands for several boolean operators, which are explained
			in more detail in the following sections.
		</para>
		<para>
			<!-- TODO better formulation please -->
			SeRQL applies variable scoping for nested queries. This means that
			when a variable is assigned in the outer query, its value will be
			carried over to the inner query when that variable is reused there.
		</para>
		<section id="section-in">
			<title>The IN operator (R1.2)</title>
			<para>
				The IN operator allows set membership checking where the set is
				defined by a nested SELECT-query.
			</para>
			<para>
				The following example query uses the IN operator to retrieve all
				names of Persons, but only those names that also appear as
				names of Authors.
			</para>
			<screen><![CDATA[
@prefix ex: <http://example.org/things#> .

_:a  rdf:type         ex:Person .
_:a  ex:name          "John" .

_:b  rdf:type         ex:Person .
_:b  ex:name          "Ringo" .

_:c  rdf:type         ex:Author .
_:c  ex:name          "John" .

_:d  rdf:type         ex:Author .
_:d  ex:name          "George" .]]></screen>
			<para>Query:</para>
<screen><![CDATA[
SELECT name
FROM {} rdf:type {ex:Person};
        ex:name {name}
WHERE name IN ( SELECT n
                FROM {} rdf:type {ex:Author};
                        ex:name {n}
              )
USING NAMESPACE
    ex = <http://example.org/things#>]]></screen>
			<para>Result:</para>
			<informaltable frame="all">
				<tgroup cols="1" align="left">
					<thead>
						<row>
							<entry align="center">name</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry>"John"</entry>
						</row>
					</tbody>
				</tgroup>
			</informaltable>
		</section>
		<section id="section-any">
			<title>ANY and ALL (R1.2)</title>
			<para>
				The ANY and ALL keywords can be used for existential and universal
				quantification on the right operand of a boolean operator, if this
				operand is a set, defined by a nested query. The ALL keyword
				indicates that for every value of the nested query the boolean
				condition must hold. The ANY keyword indicates that the boolean
				condition must hold for at least one value of the nested query.
			</para>
			<para>
				The following query selects the highest value from a set of values
				using the ALL keyword and a nested query.
			</para>
			<para>Data:</para>
		<screen><![CDATA[
@prefix ex:  <http://example.org/things#> .

_:a  ex:value     "10"^^xsd:int .
_:b  ex:value     "11"^^xsd:int .
_:c  ex:value     "12"^^xsd:int .
_:d  ex:value     "13"^^xsd:int .
_:e  ex:value     "14"^^xsd:int .]]></screen>
			<para>Query:</para>
			<screen><![CDATA[
SELECT highestValue
FROM {node} ex:value {highestValue}
WHERE highestValue >= ALL ( SELECT value
                            FROM {} ex:value {value}
                          )
USING NAMESPACE
    ex = <http://example.org/things#>]]></screen>
			<para>Result:</para>
			<informaltable frame="all">
				<tgroup cols="1" align="left">
					<thead>
						<row>
							<entry align="center">highestValue</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry>"14"^^xsd:int</entry>
						</row>
					</tbody>
				</tgroup>
			</informaltable>
		</section>
		<section id="section-exists">
			<title>EXISTS (R1.2)</title>
			<para>
				EXISTS is a unary operator that has a nested SELECT-query as its
				operand. The operator is an existential quantifier that succeeds
				when the nested query has at least one result.
			</para>
			<para>
				In the following example, we use EXIST to determine whether any
				authors are known that share a name with a person, and if so, to
				retrieve that person's names and hobbies.
			</para>
			<para>Data:</para>
			<screen><![CDATA[
@prefix ex: <http://example.org/things#> .

_:a  rdf:type         ex:Person .
_:a  ex:name          "John" .
_:a  ex:hobby         "Stamp collecting" .

_:b  rdf:type         ex:Person .
_:b  ex:name          "Ringo" .
_:b  ex:hobby         "Crossword puzzles" .

_:c  rdf:type         ex:Author .
_:c  ex:name          "John" .
_:c  ex:authorOf      "Let it be".]]></screen>
			<para>Query:</para>
			<screen><![CDATA[
SELECT name, hobby
FROM {} rdf:type {ex:Person};
        ex:name {name};
        ex:hobby {hobby}
WHERE EXISTS ( SELECT n
               FROM {} rdf:type {ex:Author};
                       ex:name {n};
                       ex:authorOf {}
               WHERE n = name
             )
USING NAMESPACE
    ex = <http://example.org/things#>]]></screen>
				 <para>Result:</para>
			<informaltable frame="all">
				<tgroup cols="2" align="left">
					<thead>
						<row>
							<entry align="center">name</entry>
							<entry align="center">hobby</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry>"John"</entry>
							<entry>"Stamp collecting"</entry>
						</row>
					</tbody>
				</tgroup>
			</informaltable>
		</section>
	</section> <!-- query nesting -->

	<section id="section-context">
		<title>Querying context (R2.0)</title>
		<para>
			A new clause, FROM CONTEXT, is introduced in SeRQL 2.0 to allow
			querying of <emphasis>context</emphasis>. Context can be seen as a
			grouping mechanism of statements inside a repository, where the
			group is identified with a <emphasis>context identifier</emphasis>
			(a URI or a blank node).
		</para>
		<para>
			A very typical way to use context is tracking
			<emphasis>provenance</emphasis> of the statements in a repository,
			that is, which location (on the Web, or on the file system) these
			statements originate from. For example, consider an application
			where you add RDF data from different files to a repository, and
			then one of those files is updated. You would then like to replace
			the data from that one file in the repository, and to be able to do
			this you need a way to figure out which statements need to be
			removed. The context mechanism gives you a way to do that.
		</para>
		<para>
			By default, a SeRQL query ranges over the total repository. This is
			known as the <emphasis>default context</emphasis>: we do not specify a
			context, therefore, the default context is queried. In practice this
			means that all statements in all contexts in the repository are
			queried.
		</para>
		<para>
			In the following example, we have a repository that contains three
			sets of data. The first set is added without context, the other two
			each have their own, specific, named context.
		</para>
		<para>Data set 1 (no context):</para>
			<screen><![CDATA[
@prefix dc: <http://purl.org/dc/elements/1.1/> .
@prefix g:  <http://example.org/contexts/>

g:graph1 dc:publisher "Bob" .
g:graph1 dc:date "2004-12-06T00:00:00Z"^^xsd:dateTime .

g:graph2 dc:publisher "Bob" .
g:graph2 dc:date "2005-01-10T00:00:00Z"^^xsd:dateTime .
]]></screen>
<para>Data set 2 (context http://example.org/contexts/graph1):</para>
			<screen><![CDATA[
@prefix foaf: <http://xmlns.com/foaf/0.1/> .

_:a1 foaf:name "Alice" .
_:a1 foaf:mbox <mailto:alice@work.example> .

_:b1 foaf:name "Bob" .
_:b1 foaf:mbox <mailto:bob@oldcorp.example.org> .]]></screen>
<para>Data set 3 (context http://example.org/contexts/graph2):</para>
			<screen><![CDATA[
@prefix foaf: <http://xmlns.com/foaf/0.1/> .

_:a2 foaf:name "Alice" .
_:a2 foaf:mbox <mailto:alice@work.example> .

_:b2 foaf:name "Bob" .
_:b2 foaf:mbox <mailto:bob@newcorp.example.org> .
	]]></screen>
<para>
	As you can see, the data in each of the named contexts contains
	different information about the e-mail address of Bob. Using a 'normal'
	SeRQL query (that is, without using context information), we can
	retrieve all e-mail addresses quite easily: 
</para>
			<para>Query:</para>
			<screen><![CDATA[
SELECT DISTINCT name, mbox
FROM {x} foaf:name {name};
         foaf:mbox {mbox}
USING NAMESPACE
foaf = <http://xmlns.com/foaf/0.1/>]]></screen>
			<para>Result:</para>
			<informaltable frame="all">
				<tgroup cols="2" align="left">
					<thead>
						<row>
							<entry align="center">name</entry>
							<entry align="center">mbox</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry>Alice</entry>
							<entry>mailto:alice@work.example</entry>
						</row>
						<row>
							<entry>Bob</entry>
							<entry>mailto:bob@oldcorp.example.org</entry>
						</row>
						<row>
							<entry>Bob</entry>
							<entry>mailto:bob@newcorp.example.org</entry>
						</row>
					</tbody>
				</tgroup>
			</informaltable>
			<para>
				However, we can not identify the source of each e-mail address using such
				a query, because all the statements in the three files are just
				merged together in a single repository. We can, however, retrieve
				this information using a context query:
			</para>
			<para>Query:</para>
			<screen><![CDATA[
SELECT DISTINCT source, name, mbox
FROM CONTEXT source
     {x} foaf:name {name};
         foaf:mbox {mbox}
USING NAMESPACE
foaf = <http://xmlns.com/foaf/0.1/>]]></screen>
			<para>Result:</para>
			<informaltable frame="all">
				<tgroup cols="3" align="left">
					<thead>
						<row>
							<entry align="center">source</entry>
							<entry align="center">name</entry>
							<entry align="center">mbox</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry>http://example.org/context/graph1</entry>
							<entry>Alice</entry>
							<entry>mailto:alice@work.example</entry>
						</row>
						<row>
							<entry>http://example.org/context/graph2</entry>
							<entry>Alice</entry>
							<entry>mailto:alice@work.example</entry>
						</row>
						<row>
							<entry>http://example.org/context/graph1</entry>
							<entry>Bob</entry>
							<entry>mailto:bob@oldcorp.example.org</entry>
						</row>
						<row>
							<entry>http://example.org/context/graph2</entry>
							<entry>Bob</entry>
							<entry>mailto:bob@newcorp.example.org</entry>
						</row>
					</tbody>
				</tgroup>
			</informaltable>
			<para>
				As you can see, by specifying a variable <varname>source</varname>
				in the FROM CONTEXT clause we can retrieve the named context from
				which the information comes.
			</para>
			<para>
				We can also specify a named context explicitly by using a URI
				directly, for example if we only want to query source graph2:
			</para>
			<para>Query:</para>
			<screen><![CDATA[
SELECT name, mbox
FROM CONTEXT <http://example.org/context/graph2>
     {x} foaf:name {name};
         foaf:mbox {mbox}
USING NAMESPACE
foaf = <http://xmlns.com/foaf/0.1/>]]></screen>
			<para>Result:</para>
			<informaltable frame="all">
				<tgroup cols="2" align="left">
					<thead>
						<row>
							<entry align="center">name</entry>
							<entry align="center">mbox</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry>Alice</entry>
							<entry>mailto:alice@work.example</entry>
						</row>
						<row>
							<entry>Bob</entry>
							<entry>mailto:bob@newcorp.example.org</entry>
						</row>
					</tbody>
				</tgroup>
			</informaltable>
			<para>
				A SeRQL query may contain any number of FROM CONTEXT clauses and may
				additionally contain a 'normal' FROM clause as well.
			</para>
			<para>
				For example, in the following query we combine information from
				the default context and from the different named contexts to
				retrieve the most recently published e-mail information:
			</para>
			<para>Query:</para>
			<screen><![CDATA[
SELECT date, source, name, mbox
FROM {source} dc:date {date}	
FROM CONTEXT source
     {x} foaf:name {name};
         foaf:mbox {mbox}
WHERE date >= ALL (SELECT d FROM {} dc:date {d})
USING NAMESPACE
   foaf = <http://xmlns.com/foaf/0.1/>,
   dc = <http://purl.org/dc/elements/1.1/>]]></screen>
			<para>Result:</para>
			<informaltable frame="all">
				<tgroup cols="4" align="left">
					<thead>
						<row>
							<entry align="center">date</entry>
							<entry align="center">source</entry>
							<entry align="center">name</entry>
							<entry align="center">mbox</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry>"2005-01-10T00:00:00Z"^^xsd:dateTime</entry>
							<entry>http://example.org/context/graph2</entry>
							<entry>Alice</entry>
							<entry>mailto:alice@work.example</entry>
						</row>
						<row>
							<entry>"2005-01-10T00:00:00Z"^^xsd:dateTime</entry>
							<entry>http://example.org/context/graph2</entry>
							<entry>Bob</entry>
							<entry>mailto:bob@newcorp.example.org</entry>
						</row>
					</tbody>
				</tgroup>
			</informaltable>
		</section> <!-- querying context -->
		
	<section>
		<title>Example SeRQL queries</title>

		<section>
			<title>Query 1</title>
			<para>
				Description: Find all papers that are about "RDF" and about
				"Querying", and their authors.
			</para>
			<screen><![CDATA[
SELECT
   Author, Paper
FROM
   {Paper} rdf:type {foo:Paper};
           ex:keyword {"RDF", "Querying"};
           dc:author {Author}
USING NAMESPACE
   dc = <http://purl.org/dc/elements/1.0/>,
   ex = <http://example.org/things#>]]></screen>
			<para>
				Depicted as a graph, this query searches through the RDF graph
				for all subgraphs matching the following template:
			</para>
			<figure id="figure-query1" float="1">
				<title>Path expression for query 1</title>
				<mediaobject>
					<imageobject>
						<imagedata fileref="figures/serql-query1.png"/>
					</imageobject>
				</mediaobject>
			</figure>
		</section>

		<section>
			<title>Query 2</title>
			<para>
				Description: Find all artefacts whose English title contains
				the string "night" and the museum where they are exhibited. The
				artefact must have been created by someone with first name
				"Rembrandt". The artefact and museum should both be represented
				by their titles.
			</para>
			<screen><![CDATA[
SELECT DISTINCT
   label(ArtefactTitle), MuseumName
FROM
   {Artefact} arts:created_by {} arts:first_name {"Rembrandt"},
   {Artefact} arts:exhibited {} dc:title {MuseumName},
   {Artefact} dc:title {ArtefactTitle}
WHERE
   isLiteral(ArtefactTitle) AND
   lang(ArtefactTitle) = "en" AND
   label(ArtefactTitle) LIKE "*night*"
USING NAMESPACE
   dc   = <http://purl.org/dc/elements/1.0/>,
   arts = <http://example.org/arts/>]]></screen>
			<para>
				Again, depicted as a subgraph template:
			</para>
			<figure id="figure-query2" float="1">
				<title>Path expression for query 2</title>
				<mediaobject>
					<imageobject>
						<imagedata fileref="figures/serql-query2.png"/>
					</imageobject>
				</mediaobject>
			</figure>
			<para>
				Note that this figure only shows the path expressions from the
				from clause. The where clause poses additional constraints on
				the values of the variables which can't be as easily depicted
				graphically.
			</para>
		</section>

		<section>
			<title>Query 3</title>
			<para>
				Description: Find all siblings of class foo:bar.
			</para>
			<screen><![CDATA[
SELECT DISTINCT
   Sibling
FROM
   {Sibling, <foo:bar>} rdfs:subClassOf {ParentClass}]]></screen>
			<para>
				Or graphically:
			</para>
			<figure id="figure-query3" float="1">
				<title>Path expression for query 3</title>
				<mediaobject>
					<imageobject>
						<imagedata fileref="figures/serql-query3.png"/>
					</imageobject>
				</mediaobject>
			</figure>
			<para>
				Note that the URI foo:bar is not returned as a result (there is
				an implicit constraint that doesn't allow Sibling to be equal to
				values that occur in the same multi-value node).
			</para>
		</section>
	</section> <!-- Example SeRQL queries -->

	<section>
		<title>References</title>
		<itemizedlist>
			<listitem>
<ulink url="http://www.w3.org/TR/rdf-sparql-query/">SPARQL</ulink>
			</listitem>
			<listitem>
<ulink url="http://139.91.183.30:9090/RDF/RQL/">RQL</ulink>
			</listitem>
			<listitem>
<ulink url="http://www.openrdf.org/doc/rql-tutorial.html">RQL tutorial</ulink>
			</listitem>
			<listitem>
<ulink url="http://www.hpl.hp.com/semweb/rdql.html">RDQL</ulink>
			</listitem>
			<listitem>
<ulink url="http://www.w3.org/TR/1999/REC-rdf-syntax-19990222/">RDF/XML syntax (W3C Recommandation)</ulink>
			</listitem>
			<listitem>
<ulink url="http://www.w3.org/TR/rdf-syntax-grammar/">Revised RDF/XML syntax (W3C Technical Report)</ulink>
			</listitem>
			<listitem>
<ulink url="http://www.w3.org/tr/rdf-mt/">RDF Semantics (W3C Recommandation)</ulink>
			</listitem>
			<listitem>
<ulink url="http://www.w3.org/TR/rdf-testcases/#ntriples">N-Triples</ulink>
			</listitem>
			<listitem>
<ulink url="http://www.ilrt.bris.ac.uk/discovery/2004/01/turtle/">Turtle</ulink>
			</listitem>
			<listitem>
<ulink url="http://www.w3.org/DesignIssues/Notation3.html">N3</ulink>
			</listitem>
			<listitem>
<ulink url="http://www.ietf.org/rfc/rfc2396.txt">URI (RFC 2396)</ulink>
			</listitem>
			<listitem>
<ulink url="http://www.w3.org/TR/REC-xml-names/">Namespace in XML (W3C Recommandation)</ulink>
			</listitem>
		</itemizedlist>
	</section> <!--References -->
	<!--
	TODO draft, unfinished.
	<section>
		<title>SeRQL formal interpretation</title>
			<para>
				The <ulink url="http://www.w3.org/tr/rdf-mt/">RDF Semantics W3C
					specification</ulink> specifies a model theoretical semantics
				for RDF and RDF Schema. In this section, we will use this model
				theory to specify a formal interpretation of SeRQL query
				constructs.
			</para>
			<para>
				Without repeating here the entire model theory, we briefly summarize a
				couple of its notions for reference:
			</para>
			<itemizedlist>
				<listitem>
					<para>
						The sets <symbol>IR</symbol>, <symbol>IP</symbol>, <symbol>IC</symbol>
						are sets of resources, properties, and classes, respectively.
						<symbol>LV</symbol> is a distinguished subset of
						<symbol>IR</symbol> and is defined as the set of literals.
					</para>
				</listitem>
				<listitem>
					<para>
						<symbol>IEXT</symbol> is defined as a mapping from
						<symbol>IP</symbol> to the powerset of <symbol>IR x IR</symbol>.
						Given <symbol>p is in IP</symbol> it holds that
						<symbol>IEXT(I(p))</symbol> is the set of pairs <symbol>&lt;x, y&gt;
							such that x, y in IR</symbol> for which the relation
						<symbol>p</symbol> holds, that is,
						for which <symbol>&lt;x, p, y&gt;</symbol> is a statement in the RDF graph.
					</para>
				</listitem>
			</itemizedlist>
		<section>
			<title>Path expressions</title>
			<para>
				For an <emphasis>RDF interpretation</emphasis>, the following semantic condition
				holds:
			</para>
			<itemizedlist>
				<listitem>
					<para><symbol>x is in IP if and only if &lt;x, I(rdf:Property)&gt; is
							in IEXT(I(rdf:type))</symbol>
					</para>
				</listitem>
			</itemizedlist>
			<para>
				Additionally, we define a NULL value, that is <symbol>I(x) =
					NULL</symbol> if no value is assigned to <symbol>x</symbol> in
				the current interpretation.  We will first characterize SeRQL in
				terms of RDF only, i.e. give an RDF interpretation:
			</para>
			<table>
				<title>RDF interpretation of basic SeRQL path expressions</title>
				<tgroup cols="2" align="left">
					<tbody>
						<row>
							<entry><screen>{x} p {y}</screen></entry>
							<entry><symbol>{&lt;x, p, y&gt; such that &lt;x,y&gt; is in IEXT(I(p))}</symbol></entry>
						</row>
						<row>
							<entry><screen>{x} p {y}; q {z}</screen></entry>
							<entry>{&lt;x, p, y&gt; such that &lt;x,y&gt; is in IEXT(I(p))}<sbr/>
								union<sbr/>
									   {&lt;x', q, z&gt; such that &lt;x',z&gt; is in IEXT(I(q))} where x = x'</entry>
						</row>
						<row>
							<entry><screen>{x} p {y,z}</screen></entry>
							<entry>{&lt;x, p, y&gt; such that &lt;x,y&gt; is in IEXT(I(p))}<sbr/>
								union<sbr/>
									   {&lt;x', p', z&gt; such that &lt;x',z&gt; is in IEXT(I(p\))} where x = x' and p = p'</entry>
							</entry>
						</row>
						<row>
							<entry><screen>[{x} p {y}]</screen></entry>
							<entry>
									{&lt;x, p, y&gt; such that &lt;x,y&gt; is in IEXT(I(p))}<sbr/>
									union<sbr/>
									{&lt;NULL, p, y&gt; such that there is no x' for which &lt;x',y&gt; is in IEXT(I(p))}<sbr/>
									union<sbr/>
									{&lt;x, NULL, y&gt; such that there is no p' for which &lt;x,y&gt; is in IEXT(I(p'))}<sbr/>
									union<sbr/>
									{&lt;x, p, NULL&gt; such that there is no y' for which &lt;x,y'&gt; is in IEXT(I(p))}<sbr/>
									union<sbr/>
									{&lt;NULL, p, NULL&gt; such that IEXT(I(p)) is empty}<sbr/>
									union<sbr/>
									{&lt;x, NULL, NULL&gt; such that there is no p' for which &lt;x,y'&gt; is in IEXT(I(p'))}<sbr/>
									union<sbr/>
									{&lt;NULL, NULL, y&gt; such that there is no p' for which &lt;x',y&gt; is in IEXT(I(p'))}
							</entry>
						</row>
					</tbody>
				</tgroup>
			</table>
			<para>
				An extended interpretation takes into account RDF Schema semantics. For an
				<emphasis>RDFS interpretation</emphasis> the following semantic conditions
				hold in addition to those specified by an RDF interpretation:
			</para>
			<itemizedlist>
				<listitem>
					<symbol>x is in ICEXT(y)</symbol> if and only if
					<symbol>&lt;x,y&gt; is in IEXT(I(rdf:type))</symbol>
				</listitem>
				<listitem>
					<symbol>IC = ICEXT(I(rdfs:Class))</symbol>
				</listitem>
				<listitem>
					<symbol>IR = ICEXT(I(rdfs:Resource))</symbol>
				</listitem>
				<listitem>
					<symbol>LV = ICEXT(I(rdfs:Literal))</symbol>
				</listitem>
				<listitem>
					if <symbol>&lt;x,y&gt; is in IEXT(I(rdfs:domain))</symbol> and
					<symbol>&lt;u,v&gt; is in IEXT(x)</symbol> then
					<symbol>u is in ICEXT(y)</symbol>
				</listitem>
				<listitem>
					if <symbol>&lt;x,y&gt; is in IEXT(I(rdfs:range))</symbol> and
					<symbol>&lt;u,v&gt; is in IEXT(x)</symbol> then
					<symbol>v is in ICEXT(y)</symbol>
				</listitem>
				<listitem>
					<symbol>IEXT(I(rdfs:subPropertyOf))</symbol> is transitive and
					reflexive on <symbol>IP</symbol>
				</listitem>
				<listitem>
					if <symbol>&lt;x,y&gt; is in
						IEXT(I(rdfs:subPropertyOf))</symbol> then <symbol>x and y are
						in IP</symbol> and <symbol>IEXT(x) is a subset of IEXT(y)</symbol>
				</listitem>
				<listitem>
					<symbol>IEXT(I(rdfs:subClassOf))</symbol> is transitive and
					reflexive on <symbol>IC</symbol>
				</listitem>
				<listitem>
					if <symbol>&lt;x,y&gt; is in
						IEXT(I(rdfs:subClassOf))</symbol> then <symbol>x and y are
						in IC</symbol> and <symbol>IEXT(x) is a subset of IEXT(y)</symbol>
				</listitem>
				<listitem>
					if <symbol>x is in IC</symbol> then
					<symbol>&lt;x,IR&gt; is in IEXT(I(rdfs:subClassOf))</symbol>
				</listitem>
				<listitem>
					if <symbol>x is in ICEXT(I(rdfs:ContainerMembershipProperty))</symbol> then
					<symbol>&lt;x,I(rdfs:member)&gt; is in IEXT(I(rdfs:subPropertyOf))</symbol>
				</listitem>
				<listitem>
					if <symbol>x is in ICEXT(I(rdfs:Datatype))</symbol> and
					<symbol>y is in ICEXT(x)</symbol>then
					<symbol>&lt;y,I(rdfs:Literal)&gt; is in IEXT(I(rdf:type))</symbol>
				</listitem>
			</itemizedlist>
			<para>
				In the following table, the extended interpretations of SeRQL path
				expressions are shown:
			</para>
			<table>
				<title>RDFS interpretation of basic SeRQL path expressions</title>
				<tgroup cols="2" align="left">
					<tbody>
						<row>
							<entry><screen>{x} rdf:type {y}</screen></entry>
							<entry>{&lt;x,y&gt; such that x is in ICEXT(y)}</entry>
						</row>
						<row>
							<entry><screen>{x} serql:directType {y}</screen></entry>
							<entry>{&lt;x,y&gt; such that x is in ICEXT(y) and there is
								no z such that:
								<itemizedlist>
									<listitem>z is not equal to y</listitem>
									<listitem>x is in ICEXT(z)</listitem>
									<listitem>&lt;z,y&gt; is in IEXT(I(rdfs:subClassOf))</listitem>
								</itemizedlist>
							</entry>
						</row>
						<row>
							<entry><screen>{x} rdfs:subClassOf {y}</screen></entry>
							<entry>{&lt;x,y&gt; such that x is in IEXT(I(rdfs:subClassOf)}</entry>
						</row>
						<row>
							<entry><screen>{x} serql:directSubClassOf {y}</screen></entry>
							<entry>{&lt;x,y&gt; such that x is not equal to y and
								&lt;x,y&gt; is in IEXT(I(rdfs:subClassOf)) and there is
								no z such that:
								<itemizedlist>
									<listitem>x, y and z are pairwise unequal</listitem>
									<listitem>&lt;x,z&gt; is in IEXT(I(rdfs:subClassOf))</listitem>
									<listitem>&lt;z,y&gt; is in IEXT(I(rdfs:subClassOf))</listitem>
								</itemizedlist>
							</entry>
						</row>
						<row>
							<entry><screen>{p} rdfs:subPropertyOf {q}</screen></entry>
							<entry>{&lt;p,q&gt; such that &lt;p,q&gt; is in IEXT(I(rdfs:subPropertyOf)}</entry>
						</row>
						<row>
							<entry><screen>{p} serql:directSubPropertyOf {q}</screen></entry>
							<entry>{&lt;p,q&gt; such that p is not equal to q and
								&lt;p,q&gt; is in IEXT(I(rdfs:subPropertyOf)) and there is
								no r such that:
								<itemizedlist>
									<listitem>p, q and r are pairwise unequal</listitem>
									<listitem>&lt;p,r&gt; is in IEXT(I(rdfs:subPropertyOf))</listitem>
									<listitem>&lt;r,q&gt; is in IEXT(I(rdfs:subPropertyOf))</listitem>
								</itemizedlist>
							</entry>
						</row>
					</tbody>
				</tgroup>
			</table>
		</section>
		<section>
			<title>Functions and operators</title>
			<table>
				<title>SeRQL functions</title>
				<tgroup cols="2" align="left">
					<tbody>
						<row>
							<entry>
								<screen>isResource(x)</screen>
							</entry>
							<entry>
								TRUE if <symbol>I(x) is in IR</symbol>; FALSE otherwise.
							</entry>
						</row>
						<row>
							<entry>
								<screen>isURI(x)</screen>
							</entry>
							<entry>
								TRUE if <symbol>I(x) is in IR</symbol> and x is a URI; FALSE otherwise.
							</entry>
						</row>
						<row>
							<entry>
								<screen>isBNode(x)</screen>
							</entry>
							<entry>
								TRUE if <symbol>I(x) is in IR</symbol> and x is a blank node; FALSE otherwise.
							</entry>
						</row>
						<row>
							<entry>
								<screen>isLiteral(x)</screen>
							</entry>
							<entry>
								TRUE if <symbol>I(x) is in LV</symbol>; FALSE otherwise.
							</entry>
						</row>
					</tbody>
				</tgroup>
			</table>
		</section>
	</section>
	-->
	<section>
		<title>SeRQL grammar</title>
		<para>
			The following is the BNF grammar of SeRQL, revision 3.0:
		</para>
		<screen><![CDATA[
ParseUnit        ::= Query [NamespaceDeclList]

NamespaceDeclList::= "using" "namespace" NamespaceDecl ("," NamespaceDecl)*
NamespaceDecl    ::= <PREFIX_NAME> "=" <URI>

Query            ::= TupleQuerySet
                   | GraphQuerySet

TupleQuerySet    ::= TupleQuery [SetOperator TupleQuerySet]
TupleQuery       ::= "(" TupleQuerySet ")"
                   | SelectQuery

GraphQuerySet    ::= GraphQuery [SetOperator GraphQuerySet]
GraphQuery       ::= "(" GraphQuerySet ")"
                   | ConstructQuery

SetOperator      ::= "union" ["all"]
                   | "minus"
                   | "intersect"

SelectQuery      ::= "select" ["distinct"] Projection [QueryBody]
Projection       ::= "*"
                   | [ ProjectionElem ("," ProjectionElem)* ]
ProjectionElem   ::= ValueExpr ["as" <STRING>]

ConstructQuery   ::= "construct" ["distinct"] ConstructClause [QueryBody]
ConstructClause  ::= "*"
                   | PathExprList

QueryBody        ::= ("from" ["context" ContextID] PathExprList)+
                     ["where" BooleanExpr]
                     ["limit" <POS_INTEGER>]
                     ["offset" <POS_INTEGER>]

ContextID        ::= Var
                   | Uri
                   | BNode

PathExprList     ::= PathExpr ("," PathExpr)*
PathExpr          ::= BasicPathExpr
                   | OptGraphPattern
BasicPathExpr    ::= Node Edge Node [[";"] PathExprTail]
OptGraphPattern  ::= "[" PathExprList ["where" BooleanExpr] "]"

PathExprTail     ::= Edge Node [[";"] PathExprTail]
                   | OptPathExprTail [";" PathExprTail]
OptPathExprTail  ::= "[" Edge Node [[";"] PathExprTail] ["where" BooleanExpr] "]"

PathExprCont     ::= PathExprBranch
                   | PathExprTail

PathExprBranch   ::= ";" PathExprTail

PathExprTail     ::= Edge Node
                   | "[" Edge Node [PathExprCont] ["where" BooleanExpr] "]"

Edge             ::= Var
                   | Uri
Node             ::= "{" [ NodeElem ("," NodeElem)* ] "}"
NodeElem         ::= Var
                   | Value
                   | ReifiedStat
ReifiedStat      ::= "{" [NodeElem] "}" Edge "{" [NodeElem] "}"

BooleanExpr      ::= OrExpr
OrExpr           ::= AndExpr ["or" BooleanExpr]
AndExpr          ::= BooleanElem ["and" AndExpr]
BooleanElem      ::= "(" BooleanExpr ")"
                   | "true"
                   | "false"
                   | "not" BooleanElem
                   | ValueExpr CompOp ValueExpr
                   | ValueExpr CompOp ("any"|"all") "(" TupleQuerySet ")"
                   | ValueExpr "like" <STRING>
                   | ValueExpr "in" "(" TupleQuerySet ")"
                   | "exists" "(" TupleQuerySet ")"
                   | "isResource" "(" Var ")"
                   | "isURI" "(" Var ")"
                   | "isBNode" "(" Var ")"
                   | "isLiteral" "(" Var ")"

CompOp           ::= "=" | "!=" | "<" | "<=" | ">" | ">="

ValueExpr        ::= Var
                   | Value
				   | "bound" "(" Var ")"
                   | "datatype" "(" Var ")"
                   | "lang" "(" Var ")"
                   | "label" "(" Var ")"
                   | "namespace" "(" Var ")"
                   | "localname" "(" Var ")"
				   | FunctionCall

FunctionCall     ::= Uri "(" [ArgList] ")"
ArgList          ::= ValueExpr ("," ValueExpr)*

Var              ::= <NC_NAME>

Value            ::= Uri
                   | BNode
                   | Literal

Uri              ::= <URI>
                   | <QNAME>

BNode            ::= <BNODE>

Literal          ::= <STRING>
                   | <LANG_LITERAL>
                   | <DT_LITERAL>
                   | <POS_INTEGER>
                   | <NEG_INTEGER>
                   | <DECIMAL>

<URI>            ::= "<" (* a legal URI, see http://www.ietf.org/rfc/rfc2396.txt *) ">"
<QNAME>          ::= <PREFIX_NAME> ":" <NC_NAME_CHAR>*
<BNODE>          ::= "_:" <NC_NAME>

<STRING>         ::= (* A quoted character string with escapes *)
<LANG_LITERAL>   ::= <STRING> "@" <LIT_LANG>
<DT_LITERAL>     ::= <STRING> "^^" (<URI>|<QNAME>)

<POS_INTEGER>    ::= "+"? [0-9]+
<NEG_INTEGER>    ::= "-" [0-9]+
<DECIMAL>        ::= ("+"|"-")? [0-9]* "." [0-9]+

<PREFIX_NAME>    ::= <LETTER> <NC_NAME_CHAR>*
                   | "_" <NC_NAME_CHAR>+

<NC_NAME>        ::= (<LETTER>|"_") <NC_NAME_CHAR>*
<NC_NAME_CHAR>   ::= (* see http://www.w3.org/TR/REC-xml-names/#NT-NCNameChar *)
<LETTER>         ::= (* see http://www.w3.org/TR/REC-xml/#NT-Letter *)]]></screen>
		<para>
			Note: all keywords are assumed to be case-insensitive. Whitespace
			characters between tokens are not significant other than for
			separating the tokens. Production rules with a head that is
			surrounded by angular brackets define tokens (aka "terminals").
		</para>
	</section> <!-- SeRQL grammar -->
</chapter>
