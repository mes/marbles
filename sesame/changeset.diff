Index: trunk/sesame/org.aduna-software.pom.xml
===================================================================
--- trunk/sesame/org.aduna-software.pom.xml (revision 49)
+++ trunk/sesame/org.aduna-software.pom.xml (revision 49)
@@ -0,0 +1,126 @@
+<project xmlns="http://maven.apache.org/POM/4.0.0"
+         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
+                             http://maven.apache.org/maven-v4_0_0.xsd">
+
+	<modelVersion>4.0.0</modelVersion>
+
+	<groupId>org.aduna-software</groupId>
+	<artifactId>aduna-opensource-root-pom</artifactId>
+	<version>1</version>
+	<packaging>pom</packaging>
+
+	<name>Aduna Open Source root pom</name>
+	<description>Aduna Open Source root pom</description>
+	<url>http://www.aduna-software.org/</url>
+
+	<organization>
+		<name>Aduna</name>
+		<url>http://www.aduna-software.com/</url>
+	</organization>
+
+	<repositories>
+		<repository>
+			<releases>
+				<enabled>true</enabled>
+			</releases>
+			<snapshots>
+				<enabled>false</enabled>
+			</snapshots>
+			<id>aduna-opensource.releases</id>
+			<name>Aduna Open Source - Maven releases</name>
+			<url>http://repo.aduna-software.org/maven2/releases</url>
+		</repository>
+		<repository>
+			<releases>
+				<enabled>true</enabled>
+			</releases>
+			<snapshots>
+				<enabled>false</enabled>
+			</snapshots>
+			<id>aduna-opensource.ext</id>
+			<name>Aduna Open Source - Maven external releases</name>
+			<url>http://repo.aduna-software.org/maven2/ext</url>
+		</repository>
+		<repository>
+			<releases>
+				<enabled>false</enabled>
+			</releases>
+			<snapshots>
+				<enabled>true</enabled>
+			</snapshots>
+			<id>aduna-opensource.snapshots</id>
+			<name>Aduna Open Source - Maven snapshots</name>
+			<url>http://repo.aduna-software.org/maven2/snapshots</url>
+		</repository>
+
+		<repository>
+			<releases>
+				<enabled>true</enabled>
+			</releases>
+			<snapshots>
+				<enabled>false</enabled>
+			</snapshots>
+			<id>aduna-repo</id>
+			<name>Aduna Open Source - Maven repository (archive)</name>
+			<url>http://repository.aduna-software.org/maven2</url>
+		</repository>
+		<repository>
+			<releases>
+				<enabled>false</enabled>
+			</releases>
+			<snapshots>
+				<enabled>true</enabled>
+			</snapshots>
+			<id>aduna-snapshot-repo</id>
+			<name>Aduna Open Source - Maven snapshot repository (archive)</name>
+			<url>http://repository.aduna-software.org/maven2-snapshots</url>
+		</repository>
+	</repositories>
+
+	<distributionManagement>
+		<repository>
+			<id>aduna-opensource.releases</id>
+			<name>Aduna Open Source - Maven releases</name>
+			<url>scp://repo.aduna-software.org:2222/home/aduna/hosts/repo.aduna-software.org/htdocs/maven2/releases</url>
+			<uniqueVersion>false</uniqueVersion>
+		</repository>
+		<snapshotRepository>
+			<id>aduna-opensource.snapshots</id>
+			<name>Aduna Open Source - Maven snapshots</name>
+			<url>scp://repo.aduna-software.org:2222/home/aduna/hosts/repo.aduna-software.org/htdocs/maven2/snapshots</url>
+			<uniqueVersion>false</uniqueVersion>
+		</snapshotRepository>
+	</distributionManagement>
+	
+	<profiles>
+		<profile>
+			<id>continuous-integration</id>
+			<distributionManagement>
+				<repository>
+					<id>aduna-opensource.releases</id>
+					<name>Aduna Open Source - Maven releases</name>
+					<url>file:/home/aduna/hosts/repo.aduna-software.org/htdocs/maven2/releases</url>
+					<uniqueVersion>false</uniqueVersion>
+				</repository>
+				<snapshotRepository>
+					<id>aduna-opensource.snapshots</id>
+					<name>Aduna Open Source - Maven snapshots</name>
+					<url>file:/home/aduna/hosts/repo.aduna-software.org/htdocs/maven2/snapshots</url>
+					<uniqueVersion>false</uniqueVersion>
+				</snapshotRepository>
+			</distributionManagement>
+		</profile>
+	</profiles>
+
+	<properties>
+		<organization.logo>http://www.aduna-software.com/images/logo.png</organization.logo>
+	</properties>
+
+	<scm>
+		<connection>scm:svn:http://repo.aduna-software.org/svn/</connection>
+		<developerConnection>scm:svn:https://repo.aduna-software.org/svn/</developerConnection>
+		<url>http://repo.aduna-software.org/viewvc/</url>
+	</scm>
+
+</project>
Index: trunk/sesame/core/.project
===================================================================
--- trunk/sesame/core/.project (revision 48)
+++ trunk/sesame/core/.project (revision 48)
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>sesame</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+</projectDescription>
Index: trunk/sesame/core/src/main/assembly/sdk.xml
===================================================================
--- trunk/sesame/core/src/main/assembly/sdk.xml (revision 45)
+++ trunk/sesame/core/src/main/assembly/sdk.xml (revision 48)
@@ -1,54 +1,54 @@
 <assembly>
 	<id>sdk</id>
 
 	<formats>
 		<format>tar.gz</format>
 		<format>zip</format>
 	</formats>
 
 	<baseDirectory>openrdf-sesame</baseDirectory>
 
 	<moduleSets>
 		<moduleSet>
 			<includes>
 				<include>*:jar:*</include>
 			</includes>
 			<binaries>
 				<unpack>false</unpack>
 				<outputDirectory>lib</outputDirectory>
 			</binaries>
 		</moduleSet>
 	</moduleSets>
 
 	<fileSets>
 		<fileSet>
 			<directory>/</directory>
 			<outputDirectory/>
 			<includes>
 				<include>*.txt</include>
 			</includes>
 		</fileSet>
 
 		<fileSet>
 			<directory>target/docs</directory>
 			<outputDirectory>docs</outputDirectory>
 		</fileSet>
 
 		<fileSet>
 			<directory>src/main/dist/bin</directory>
 			<outputDirectory>bin</outputDirectory>
 		</fileSet>
 	</fileSets>
-
+<!--
 	<files>
 		<file>
 			<source>http/server/target/openrdf-sesame.war</source>
 			<outputDirectory>war</outputDirectory>
 		</file>
 		<file>
 			<source>http/webclient/target/openrdf-workbench.war</source>
 			<outputDirectory>war</outputDirectory>
 		</file>
 	</files>
-
+-->
 </assembly>
Index: trunk/sesame/core/sail/rdbms/src/test/java/org/openrdf/sail/rdbms/schema/IntegerIdSequenceTest.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/test/java/org/openrdf/sail/rdbms/schema/IntegerIdSequenceTest.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/test/java/org/openrdf/sail/rdbms/schema/IntegerIdSequenceTest.java (revision 85)
@@ -1,78 +1,110 @@
 package org.openrdf.sail.rdbms.schema;
 
 import java.util.Arrays;
-
-import org.openrdf.model.impl.URIImpl;
+import java.util.concurrent.atomic.AtomicInteger;
 
 import junit.framework.TestCase;
 
+import org.openrdf.model.impl.BNodeImpl;
+import org.openrdf.model.impl.URIImpl;
+
 public class IntegerIdSequenceTest extends TestCase {
 	private IdSequence ids;
 	private int STEP;
 
-	public void testStep() throws Exception {
+	public void testStep()
+		throws Exception
+	{
 		assertEquals("0", Integer.toBinaryString(0));
 		assertEquals(x28('1'), Integer.toBinaryString(STEP - 1));
 		assertEquals("1" + x28('0'), Integer.toBinaryString(STEP));
 		assertEquals("10" + x28('0'), Integer.toBinaryString(STEP * 2));
 	}
 
-	public void testMinMax() throws Exception {
+	public void testMinMax()
+		throws Exception
+	{
 		for (ValueType code : ValueType.values()) {
 			assertTrue(ids.minId(code).intValue() < ids.maxId(code).intValue());
 		}
 	}
 
-	public void testDecode() throws Exception {
+	public void testDecode()
+		throws Exception
+	{
 		for (ValueType code : ValueType.values()) {
 			assertEquals(code, ids.valueOf(ids.minId(code)));
 			assertEquals(code, ids.valueOf(ids.minId(code).intValue() + 1));
 			assertEquals(code, ids.valueOf(ids.maxId(code)));
 			assertEquals(code, ids.valueOf(ids.maxId(code).intValue() - 1));
 		}
 	}
 
-	public void testMin() throws Exception {
+	public void testMin()
+		throws Exception
+	{
 		for (ValueType code : ValueType.values()) {
 			String min = Long.toBinaryString(ids.minId(code).intValue());
 			if (ids.minId(code).intValue() == 0) {
 				assertEquals("0", min);
-			} else {
+			}
+			else {
 				assertEquals(x28('0'), min.substring(min.length() - 28));
 			}
 		}
 	}
 
-	public void testMax() throws Exception {
+	public void testMax()
+		throws Exception
+	{
 		for (ValueType code : ValueType.values()) {
 			String max = Long.toBinaryString(ids.maxId(code).intValue());
 			assertEquals(x28('1'), max.substring(max.length() - 28));
 		}
 	}
 
-	public void testEncode() throws Exception {
+	public void testEncode()
+		throws Exception
+	{
 		assertEquals(ValueType.URI, ids.valueOf(ids.nextId(new URIImpl("urn:root"))));
-		assertEquals(ValueType.URI, ids.valueOf(ids.nextId(new URIImpl("urn:The quick brown fox jumps over the lazy dog"))));
+		assertEquals(ValueType.URI, ids.valueOf(ids.nextId(new URIImpl(
+				"urn:The quick brown fox jumps over the lazy dog"))));
+	}
+
+	public void testBNode()
+		throws Exception
+	{
+		assertEquals(3161856189434237699l, ids.hashOf(new BNodeImpl("node13459o40ix3")));
+		assertEquals(2859030200227941027l, ids.hashOf(new BNodeImpl("node13459o4d6x1")));
+	}
+
+	public void testAtomicInteger()
+		throws Exception
+	{
+		AtomicInteger seq = new AtomicInteger(47);
+		assertEquals(48, seq.incrementAndGet());
 	}
 
 	@Override
 	protected void setUp()
 		throws Exception
 	{
 		ids = new IntegerIdSequence();
 		ids.init();
 		STEP = ids.minId(ValueType.values()[1]).intValue();
 	}
 
 	@Override
 	protected void tearDown()
 		throws Exception
 	{
 	}
 
 	private String x28(char c) {
 		char[] a = new char[28];
 		Arrays.fill(a, 0, a.length, c);
 		return new String(a);
 	}
 }
Index: trunk/sesame/core/sail/rdbms/src/test/java/org/openrdf/sail/rdbms/schema/LongIdSequenceTest.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/test/java/org/openrdf/sail/rdbms/schema/LongIdSequenceTest.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/test/java/org/openrdf/sail/rdbms/schema/LongIdSequenceTest.java (revision 85)
@@ -1,78 +1,102 @@
 package org.openrdf.sail.rdbms.schema;
 
 import java.util.Arrays;
 
+import junit.framework.TestCase;
+
+import org.openrdf.model.impl.BNodeImpl;
 import org.openrdf.model.impl.URIImpl;
 
-import junit.framework.TestCase;
+public class LongIdSequenceTest extends TestCase {
 
-public class LongIdSequenceTest extends TestCase {
 	private IdSequence ids;
 	private long STEP;
 
-	public void testStep() throws Exception {
+	public void testStep()
+		throws Exception
+	{
 		assertEquals("0", Long.toBinaryString(0l));
 		assertEquals(x60('1'), Long.toBinaryString(STEP - 1));
 		assertEquals("1" + x60('0'), Long.toBinaryString(STEP));
 		assertEquals("10" + x60('0'), Long.toBinaryString(STEP * 2));
 	}
 
-	public void testMinMax() throws Exception {
+	public void testMinMax()
+		throws Exception
+	{
 		for (ValueType code : ValueType.values()) {
 			assertTrue(ids.minId(code).longValue() < ids.maxId(code).longValue());
 		}
 	}
 
-	public void testDecode() throws Exception {
+	public void testDecode()
+		throws Exception
+	{
 		for (ValueType code : ValueType.values()) {
 			assertEquals(code, ids.valueOf(ids.minId(code)));
 			assertEquals(code, ids.valueOf(ids.minId(code).longValue() + 1));
 			assertEquals(code, ids.valueOf(ids.maxId(code)));
 			assertEquals(code, ids.valueOf(ids.maxId(code).longValue() - 1));
 		}
 	}
 
-	public void testMin() throws Exception {
+	public void testMin()
+		throws Exception
+	{
 		for (ValueType code : ValueType.values()) {
 			String min = Long.toBinaryString(ids.minId(code).longValue());
 			if (ids.minId(code).longValue() == 0) {
 				assertEquals("0", min);
-			} else {
+			}
+			else {
 				assertEquals(x60('0'), min.substring(min.length() - 60));
 			}
 		}
 	}
 
-	public void testMax() throws Exception {
+	public void testMax()
+		throws Exception
+	{
 		for (ValueType code : ValueType.values()) {
 			String max = Long.toBinaryString(ids.maxId(code).longValue());
 			assertEquals(x60('1'), max.substring(max.length() - 60));
 		}
 	}
 
-	public void testEncode() throws Exception {
+	public void testEncode()
+		throws Exception
+	{
 		assertEquals(ValueType.URI, ids.valueOf(ids.hashOf(new URIImpl("urn:root"))));
-		assertEquals(ValueType.URI, ids.valueOf(ids.hashOf(new URIImpl("urn:The quick brown fox jumps over the lazy dog"))));
+		assertEquals(ValueType.URI, ids.valueOf(ids.hashOf(new URIImpl(
+				"urn:The quick brown fox jumps over the lazy dog"))));
+	}
+
+	public void testBNode()
+		throws Exception
+	{
+		assertEquals(3161856189434237699l, ids.hashOf(new BNodeImpl("node13459o40ix3")));
+		assertEquals(2859030200227941027l, ids.hashOf(new BNodeImpl("node13459o4d6x1")));
 	}
 
 	@Override
 	protected void setUp()
 		throws Exception
 	{
 		ids = new LongIdSequence();
 		ids.init();
 		STEP = ids.minId(ValueType.values()[1]).longValue();
 	}
 
 	@Override
 	protected void tearDown()
 		throws Exception
 	{
 	}
 
 	private String x60(char c) {
 		char[] a = new char[60];
 		Arrays.fill(a, 0, a.length, c);
 		return new String(a);
 	}
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/exceptions/RdbmsQueryEvaluationException.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/exceptions/RdbmsQueryEvaluationException.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/exceptions/RdbmsQueryEvaluationException.java (revision 85)
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/exceptions/RdbmsException.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/exceptions/RdbmsException.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/exceptions/RdbmsException.java (revision 85)
@@ -1,36 +1,38 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.exceptions;
 
 import java.sql.SQLException;
 
 import org.openrdf.sail.SailException;
 
 /**
  * SailExcetion from an RDBMS store.
  * 
  * @author James Leigh
  * 
  */
 public class RdbmsException extends SailException {
 	private static final long serialVersionUID = -4004800841908629772L;
 
 	public RdbmsException(SQLException e) {
 		super(e);
 	}
 
 	public RdbmsException(String msg) {
 		super(msg);
 	}
 
 	public RdbmsException(String msg, Exception e) {
 		super(msg, e);
 	}
 
 	public RdbmsException(Exception e) {
+		super(e);
 	}
 
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/exceptions/RdbmsRuntimeException.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/exceptions/RdbmsRuntimeException.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/exceptions/RdbmsRuntimeException.java (revision 85)
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/exceptions/UnsupportedRdbmsOperatorException.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/exceptions/UnsupportedRdbmsOperatorException.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/exceptions/UnsupportedRdbmsOperatorException.java (revision 85)
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/managers/BNodeManager.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/managers/BNodeManager.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/managers/BNodeManager.java (revision 85)
@@ -1,69 +1,74 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.managers;
 
 import java.sql.SQLException;
 
 import org.openrdf.sail.rdbms.managers.base.ValueManagerBase;
 import org.openrdf.sail.rdbms.model.RdbmsBNode;
 import org.openrdf.sail.rdbms.schema.BNodeTable;
 
 /**
- * Manages BNodes. Including creating, inserting, and looking up their
- * IDs.
+ * Manages BNodes. Including creating, inserting, and looking up their IDs.
  * 
  * @author James Leigh
  * 
  */
 public class BNodeManager extends ValueManagerBase<RdbmsBNode> {
 	public static BNodeManager instance;
 	private BNodeTable table;
 
 	public BNodeManager() {
 		instance = this;
 	}
 
 	public void setTable(BNodeTable table) {
 		this.table = table;
 	}
 
 	@Override
 	public void close()
 		throws SQLException
 	{
 		super.close();
 		table.close();
 	}
 
 	@Override
-	protected boolean expungeRemovedStatements(int count, String condition)
+	protected boolean expunge(String condition)
 		throws SQLException
 	{
-		return table.expungeRemovedStatements(count, condition);
+		return table.expunge(condition);
 	}
 
 	@Override
-	protected void optimize() throws SQLException {
+	protected void optimize()
+		throws SQLException
+	{
 		super.optimize();
 		table.optimize();
 	}
 
 	@Override
 	protected int getBatchSize() {
 		return table.getBatchSize();
 	}
 
 	@Override
 	protected String key(RdbmsBNode value) {
 		return value.stringValue();
 	}
 
 	@Override
-	protected void insert(Number id, RdbmsBNode resource) throws SQLException, InterruptedException {
+	protected void insert(Number id, RdbmsBNode resource)
+		throws SQLException, InterruptedException
+	{
 		table.insert(id, resource.stringValue());
 	}
 
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/managers/TripleTableManager.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/managers/TripleTableManager.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/managers/TripleTableManager.java (revision 85)
@@ -1,390 +1,457 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.managers;
 
 import java.sql.Connection;
 import java.sql.DatabaseMetaData;
 import java.sql.ResultSet;
 import java.sql.SQLException;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.LinkedList;
 import java.util.Map;
 import java.util.Set;
 import java.util.Map.Entry;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 import org.openrdf.sail.rdbms.schema.IdSequence;
 import org.openrdf.sail.rdbms.schema.TripleTable;
 import org.openrdf.sail.rdbms.schema.ValueTableFactory;
 
 /**
  * Manages and delegates to the collection of {@link TripleTable}.
  * 
  * @author James Leigh
  * 
  */
 public class TripleTableManager {
 	private static final String DEFAULT_TABLE_PREFIX = "TRIPLES";
 	private static final String OTHER_TRIPLES_TABLE = "TRIPLES";
-	public static int MAX_TABLES = Integer.MAX_VALUE;//1000;
+
+	public static int MAX_TABLES = Integer.MAX_VALUE;// 1000;
+
 	public static final boolean INDEX_TRIPLES = true;
 	public Number OTHER_PRED;
 	private BNodeManager bnodes;
 	private boolean closed;
 	private Connection conn;
 	private ValueTableFactory factory;
 	private Thread initThread;
 	private LiteralManager literals;
 	private Logger logger = LoggerFactory.getLogger(TripleTableManager.class);
 	private PredicateManager predicates;
 	private LinkedList<TripleTable> queue = new LinkedList<TripleTable>();
 	private Pattern tablePrefix = Pattern.compile("\\W(\\w*)\\W*$");
 	private Map<Number, TripleTable> tables = new HashMap<Number, TripleTable>();
 	private UriManager uris;
 	private HashManager hashes;
 	private int maxTables = MAX_TABLES;
 	private boolean indexingTriples = INDEX_TRIPLES;
 	private IdSequence ids;
 	Exception exc;
 
 	public TripleTableManager(ValueTableFactory factory) {
 		this.factory = factory;
 	}
 
 	public void setConnection(Connection conn) {
 		this.conn = conn;
 	}
 
 	public void setIdSequence(IdSequence ids) {
 		this.ids = ids;
 		this.OTHER_PRED = ids.idOf(Long.valueOf(-1));
 	}
 
 	public void setPredicateManager(PredicateManager predicates) {
 		this.predicates = predicates;
 	}
 
 	public void setBNodeManager(BNodeManager bnodeTable) {
 		this.bnodes = bnodeTable;
 	}
 
 	public void setLiteralManager(LiteralManager literalTable) {
 		this.literals = literalTable;
 	}
 
 	public void setUriManager(UriManager uriTable) {
 		this.uris = uriTable;
 	}
 
 	public void setHashManager(HashManager hashes) {
 		this.hashes = hashes;
 	}
 
 	public int getMaxNumberOfTripleTables() {
 		if (maxTables == Integer.MAX_VALUE)
 			return 0;
 		return maxTables + 1;
 	}
 
 	public void setMaxNumberOfTripleTables(int max) {
 		if (max < 1) {
 			maxTables = MAX_TABLES;
-		} else {
+		}
+		else {
 			maxTables = max - 1;
 		}
 	}
 
 	public boolean isIndexingTriples() {
 		return indexingTriples;
 	}
 
 	public void setIndexingTriples(boolean indexingTriples) {
 		this.indexingTriples = indexingTriples;
 	}
 
-	public void initialize() throws SQLException {
+	public void initialize()
+		throws SQLException
+	{
 		tables.putAll(findPredicateTables());
 		initThread = new Thread(new Runnable() {
 			public void run() {
 				try {
 					initThread();
-				} catch (Exception e) {
+				}
+				catch (Exception e) {
 					exc = e;
 					logger.error(e.toString(), e);
 				}
 			}
 		}, "table-initialize");
 		initThread.start();
 	}
 
-	public void close() throws SQLException {
+	public void close()
+		throws SQLException
+	{
 		closed = true;
 		synchronized (queue) {
 			queue.notify();
 		}
 		Iterator<Entry<Number, TripleTable>> iter;
 		iter = tables.entrySet().iterator();
 		while (iter.hasNext()) {
 			Entry<Number, TripleTable> next = iter.next();
 			TripleTable table = next.getValue();
 			if (table.isEmpty()) {
 				predicates.remove(next.getKey());
 				table.drop();
 				iter.remove();
 			}
 			table.close();
 		}
 	}
 
-	public void createTripleIndexes() throws SQLException {
+	public void createTripleIndexes()
+		throws SQLException
+	{
 		indexingTriples = true;
 		for (TripleTable table : tables.values()) {
 			if (!table.isIndexed()) {
 				table.createIndex();
 			}
 		}
 	}
 
-	public void dropTripleIndexes() throws SQLException {
+	public void dropTripleIndexes()
+		throws SQLException
+	{
 		indexingTriples = false;
 		for (TripleTable table : tables.values()) {
 			if (table.isIndexed()) {
 				table.dropIndex();
 			}
 		}
 	}
 
-	public String findTableName(Number pred) throws SQLException {
+	public String findTableName(Number pred)
+		throws SQLException
+	{
 		return getPredicateTable(pred).getNameWhenReady();
 	}
 
 	public synchronized TripleTable getExistingTable(Number pred) {
 		if (tables.containsKey(pred))
 			return tables.get(pred);
 		return tables.get(OTHER_PRED);
 	}
 
 	public synchronized Collection<Number> getPredicateIds() {
 		return new ArrayList<Number>(tables.keySet());
 	}
 
-	public synchronized TripleTable getPredicateTable(Number pred) throws SQLException {
+	public synchronized TripleTable getPredicateTable(Number pred)
+		throws SQLException
+	{
 		assert pred.longValue() != 0;
 		assert pred.equals(ids.idOf(pred));
-			if (tables.containsKey(pred))
-				return tables.get(pred);
-			if (tables.containsKey(OTHER_PRED))
-				return tables.get(OTHER_PRED);
-			String tableName = getNewTableName(pred);
-			if (tables.size() >= maxTables) {
-				tableName = OTHER_TRIPLES_TABLE;
-			}
-			TripleTable table = factory.createTripleTable(conn, tableName);
-			table.setIdSequence(ids);
-			if (tables.size() >= maxTables) {
-				table.setPredColumnPresent(true);
-				initTable(table);
-				tables.put(OTHER_PRED, table);
-			} else {
-				initTable(table);
-				tables.put(pred, table);
-			}
-			return table;
-	}
-
-	public synchronized String getTableName(Number pred) throws SQLException {
+		if (tables.containsKey(pred))
+			return tables.get(pred);
+		if (tables.containsKey(OTHER_PRED))
+			return tables.get(OTHER_PRED);
+		String tableName = getNewTableName(pred);
+		if (tables.size() >= maxTables) {
+			tableName = OTHER_TRIPLES_TABLE;
+		}
+		TripleTable table = factory.createTripleTable(conn, tableName);
+		table.setIdSequence(ids);
+		if (tables.size() >= maxTables) {
+			table.setPredColumnPresent(true);
+			initTable(table);
+			tables.put(OTHER_PRED, table);
+		}
+		else {
+			initTable(table);
+			tables.put(pred, table);
+		}
+		return table;
+	}
+
+	public synchronized String getTableName(Number pred)
+		throws SQLException
+	{
 		if (tables.containsKey(pred))
 			return tables.get(pred).getNameWhenReady();
 		if (tables.containsKey(OTHER_PRED))
 			return tables.get(OTHER_PRED).getNameWhenReady();
 		return null;
 	}
 
-	public void removed(int count, boolean locked) throws SQLException {
+	public void removed(int count, boolean locked)
+		throws SQLException
+	{
 		String condition = null;
 		if (locked) {
 			condition = getExpungeCondition();
 		}
 		if (hashes == null || hashes.removedStatements(count, condition)) {
-			bnodes.removedStatements(count, condition);
-			uris.removedStatements(count, condition);
-			literals.removedStatements(count, condition);
-		}
-	}
-
-	protected Set<String> findAllTables() throws SQLException {
+			condition = hashes.getExpungeCondition();
+			bnodes.removedStatements(condition);
+			uris.removedStatements(condition);
+			literals.removedStatements(condition);
+		}
+	}
+
+	protected Set<String> findAllTables()
+		throws SQLException
+	{
 		Set<String> tables = new HashSet<String>();
 		DatabaseMetaData metaData = conn.getMetaData();
 		String c = null;
 		String s = null;
 		String n = null;
 		String[] TYPE_TABLE = new String[] { "TABLE" };
 		ResultSet rs = metaData.getTables(c, s, n, TYPE_TABLE);
 		try {
 			while (rs.next()) {
 				String tableName = rs.getString(3);
 				tables.add(tableName);
 			}
 			return tables;
-		} finally {
+		}
+		finally {
 			rs.close();
 		}
 	}
 
 	protected Map<Number, TripleTable> findPredicateTables()
-			throws SQLException {
+		throws SQLException
+	{
 		Map<Number, TripleTable> tables = new HashMap<Number, TripleTable>();
 		Set<String> names = findPredicateTableNames();
 		for (String tableName : names) {
 			TripleTable table = factory.createTripleTable(conn, tableName);
 			table.setIdSequence(ids);
 			if (tableName.equalsIgnoreCase(OTHER_TRIPLES_TABLE)) {
 				table.setPredColumnPresent(true);
 			}
 			if (indexingTriples && !table.isIndexed()) {
 				table.createIndex();
 			}
 			table.reload();
 			tables.put(key(tableName), table);
 		}
 		return tables;
 	}
 
 	protected Set<String> findTablesWithColumn(String column)
-			throws SQLException {
+		throws SQLException
+	{
 		Set<String> tables = findTablesWithExactColumn(column.toUpperCase());
 		if (tables.isEmpty())
 			return findTablesWithExactColumn(column.toLowerCase());
 		return tables;
 	}
 
 	protected Set<String> findTablesWithExactColumn(String column)
-			throws SQLException {
+		throws SQLException
+	{
 		Set<String> tables = new HashSet<String>();
 		DatabaseMetaData metaData = conn.getMetaData();
 		String c = null;
 		String s = null;
 		String n = null;
 		ResultSet rs = metaData.getColumns(c, s, n, column);
 		try {
 			while (rs.next()) {
 				String tableName = rs.getString(3);
 				tables.add(tableName);
 			}
 			return tables;
-		} finally {
+		}
+		finally {
 			rs.close();
 		}
 	}
 
-	protected synchronized String getExpungeCondition() throws SQLException {
+	protected synchronized String getExpungeCondition()
+		throws SQLException
+	{
 		StringBuilder sb = new StringBuilder(1024);
 		for (Map.Entry<Number, TripleTable> e : tables.entrySet()) {
 			sb.append("\nAND id != ").append(e.getKey());
 			if (e.getValue().isEmpty())
 				continue;
 			sb.append(" AND NOT EXISTS (SELECT * FROM ");
 			sb.append(e.getValue().getNameWhenReady());
 			sb.append(" WHERE ctx = id OR subj = id OR obj = id");
 			if (e.getValue().isPredColumnPresent()) {
 				sb.append(" OR pred = id");
 			}
 			sb.append(")");
 		}
 		return sb.toString();
 	}
 
-	protected String getNewTableName(Number pred) throws SQLException {
+	protected String getNewTableName(Number pred)
+		throws SQLException
+	{
 		String prefix = getTableNamePrefix(pred);
 		String tableName = prefix + "_" + pred;
 		return tableName;
 	}
 
 	protected Number key(String tn) {
 		if (tn.equalsIgnoreCase(OTHER_TRIPLES_TABLE))
 			return OTHER_PRED;
 		Number id = ids.idOf(Long.valueOf(tn.substring(tn.lastIndexOf('_') + 1)));
 		assert id.longValue() != 0;
 		return id;
 	}
 
-	protected String getTableNamePrefix(Number pred) throws SQLException {
+	protected String getTableNamePrefix(Number pred)
+		throws SQLException
+	{
 		String uri = predicates.getPredicateUri(pred);
 		if (uri == null)
 			return DEFAULT_TABLE_PREFIX;
 		Matcher m = tablePrefix.matcher(uri);
 		if (!m.find())
 			return DEFAULT_TABLE_PREFIX;
 		String localName = m.group(1).replaceAll("^[^a-zA-Z]*", "");
 		if (localName.length() == 0)
 			return DEFAULT_TABLE_PREFIX;
 		if (localName.length() > 16)
 			return localName.substring(0, 16);
 		return localName;
 	}
 
-	void initThread() throws SQLException, InterruptedException {
+	void initThread()
+		throws SQLException, InterruptedException
+	{
 		logger.debug("Starting helper thread {}", initThread.getName());
 		while (!closed) {
 			TripleTable table = null;
 			synchronized (queue) {
 				if (queue.isEmpty()) {
 					queue.wait();
 				}
 				if (!queue.isEmpty()) {
 					table = queue.removeFirst();
 				}
 			}
 			if (table != null) {
 				table.initTable();
 				table = null;
 			}
 		}
 		logger.debug("Closing helper thread {}", initThread.getName());
 	}
 
-	private Set<String> findPredicateTableNames() throws SQLException {
+	private Set<String> findPredicateTableNames()
+		throws SQLException
+	{
 		Set<String> names = findAllTables();
 		names.retainAll(findTablesWithColumn("ctx"));
 		names.retainAll(findTablesWithColumn("subj"));
 		names.retainAll(findTablesWithColumn("obj"));
+		names.retainAll(findTablesWithColumn("expl"));
 		return names;
 	}
 
-	private void initTable(TripleTable table) throws SQLException {
+	private void initTable(TripleTable table)
+		throws SQLException
+	{
 		if (exc != null)
 			throwException();
 		table.setIndexed(indexingTriples);
 		if (true || queue == null) {
 			table.initTable();
-		} else {
+		}
+		else {
 			synchronized (queue) {
 				queue.add(table);
 				queue.notify();
 			}
 		}
 	}
 
-	private void throwException() throws SQLException {
+	private void throwException()
+		throws SQLException
+	{
 		if (exc instanceof SQLException) {
-			SQLException e = (SQLException) exc;
+			SQLException e = (SQLException)exc;
 			exc = null;
 			throw e;
-		} else if (exc instanceof RuntimeException) {
-			RuntimeException e = (RuntimeException) exc;
+		}
+		else if (exc instanceof RuntimeException) {
+			RuntimeException e = (RuntimeException)exc;
 			exc = null;
 			throw e;
 		}
 	}
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/managers/LiteralManager.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/managers/LiteralManager.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/managers/LiteralManager.java (revision 85)
@@ -1,105 +1,127 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.managers;
 
 import java.sql.SQLException;
 import java.util.Locale;
 import java.util.TimeZone;
 
 import javax.xml.datatype.XMLGregorianCalendar;
 
 import org.openrdf.model.Literal;
 import org.openrdf.model.URI;
 import org.openrdf.model.datatypes.XMLDatatypeUtil;
 import org.openrdf.sail.rdbms.managers.base.ValueManagerBase;
 import org.openrdf.sail.rdbms.model.RdbmsLiteral;
+import org.openrdf.sail.rdbms.model.RdbmsURI;
 import org.openrdf.sail.rdbms.schema.LiteralTable;
 
 /**
  * Manages RDBMS Literals. Including creation, id lookup, and inserting them
  * into the database.
  * 
  * @author James Leigh
  * 
  */
 public class LiteralManager extends ValueManagerBase<RdbmsLiteral> {
 	private static TimeZone Z = TimeZone.getTimeZone("GMT");
 
 	public static long getCalendarValue(XMLGregorianCalendar xcal) {
 		return xcal.toGregorianCalendar(Z, Locale.US, null).getTimeInMillis();
 	}
 
 	public static LiteralManager instance;
 	private LiteralTable table;
 
 	public LiteralManager() {
 		instance = this;
 	}
 
 	public void setTable(LiteralTable table) {
 		this.table = table;
 	}
 
 	@Override
 	public void close()
 		throws SQLException
 	{
 		super.close();
 		table.close();
 	}
 
 	@Override
-	protected boolean expungeRemovedStatements(int count, String condition)
+	protected boolean expunge(String condition)
 		throws SQLException
 	{
-		return table.expungeRemovedStatements(count, condition);
+		return table.expunge(condition);
 	}
 
 	@Override
-	protected void optimize() throws SQLException {
+	protected void optimize()
+		throws SQLException
+	{
 		super.optimize();
 		table.optimize();
 	}
 
 	@Override
 	protected Literal key(RdbmsLiteral value) {
 		return value;
 	}
 
 	@Override
-	protected void insert(Number id, RdbmsLiteral literal) throws SQLException, InterruptedException {
+	protected void insert(Number id, RdbmsLiteral literal)
+		throws SQLException, InterruptedException
+	{
 		String label = literal.getLabel();
 		String language = literal.getLanguage();
 		URI datatype = literal.getDatatype();
-		if (datatype == null && language == null) {
+		if (literal.getPredicate() != null 
+				&& literal.getPredicate().stringValue().equals("http://www.georss.org/georss/point")) {
+			/*
+			 * Insert point using reverse parameter order:
+			 * GeoRss uses latitude<space>longitude format, whereas POINT datatype
+			 * expects x<space>y format, which equals to longitude<space>latitude
+			 */
+			String[] point = literal.stringValue().split(" ");
+			table.insertPoint(id, label, point[1] + " " + point[0]);
+		}			
+		else if (datatype == null && language == null) {
 			table.insertSimple(id, label);
-		} else if (datatype == null) {
+		}
+		else if (datatype == null) {
 			table.insertLanguage(id, label, language);
-		} else {
+		}
+		else {
 			String dt = datatype.stringValue();
 			try {
 				if (XMLDatatypeUtil.isNumericDatatype(datatype)) {
 					table.insertNumeric(id, label, dt, literal.doubleValue());
-				} else if (XMLDatatypeUtil.isCalendarDatatype(datatype)) {
+				}
+				else if (XMLDatatypeUtil.isCalendarDatatype(datatype)) {
 					long value = getCalendarValue(literal.calendarValue());
 					table.insertDateTime(id, label, dt, value);
-				} else {
+				}
+				else {
 					table.insertDatatype(id, label, dt);
 				}
-			} catch (NumberFormatException e) {
+			}
+			catch (NumberFormatException e) {
 				table.insertDatatype(id, label, dt);
-			} catch (IllegalArgumentException e) {
+			}
+			catch (IllegalArgumentException e) {
 				table.insertDatatype(id, label, dt);
 			}
 		}
 	}
 
 	@Override
 	protected int getBatchSize() {
 		return table.getBatchSize();
 	}
 
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/managers/NamespaceManager.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/managers/NamespaceManager.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/managers/NamespaceManager.java (revision 85)
@@ -1,137 +1,163 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.managers;
 
 import java.sql.Connection;
 import java.sql.SQLException;
 import java.util.Collection;
 import java.util.HashMap;
 import java.util.Map;
 import java.util.concurrent.ConcurrentHashMap;
 
 import org.openrdf.model.Namespace;
 import org.openrdf.model.impl.NamespaceImpl;
 import org.openrdf.sail.rdbms.exceptions.RdbmsException;
 import org.openrdf.sail.rdbms.schema.NamespacesTable;
 
 /**
  * Manages the namespace prefixes.
  * 
  * @author James Leigh
  * 
  */
 public class NamespaceManager {
 	private Map<String, NamespaceImpl> byNamespace = new ConcurrentHashMap<String, NamespaceImpl>();
 	private Map<String, NamespaceImpl> byPrefix = new ConcurrentHashMap<String, NamespaceImpl>();
 	private Connection conn;
 	private NamespacesTable table;
 
 	public void setConnection(Connection conn) {
 		this.conn = conn;
 	}
 
 	public void setNamespacesTable(NamespacesTable table) {
 		this.table = table;
 	}
 
-	public void close() throws RdbmsException {
+	public void close()
+		throws RdbmsException
+	{
 		try {
 			conn.close();
-		} catch (SQLException e) {
+		}
+		catch (SQLException e) {
 			throw new RdbmsException(e);
 		}
 	}
 
-	public void initialize() throws RdbmsException {
+	public void initialize()
+		throws RdbmsException
+	{
 		try {
 			load();
-		} catch (SQLException e) {
+		}
+		catch (SQLException e) {
 			throw new RdbmsException(e);
 		}
 	}
 
-	public NamespaceImpl findNamespace(String namespace) throws RdbmsException {
+	public NamespaceImpl findNamespace(String namespace)
+		throws RdbmsException
+	{
 		if (namespace == null)
 			return null;
 		if (byNamespace.containsKey(namespace))
 			return byNamespace.get(namespace);
 		try {
 			return create(namespace);
-		} catch (SQLException e) {
+		}
+		catch (SQLException e) {
 			throw new RdbmsException(e);
 		}
 	}
 
-	private void load() throws SQLException {
+	private void load()
+		throws SQLException
+	{
 		Map<String, NamespaceImpl> map = new HashMap<String, NamespaceImpl>();
 		Map<String, NamespaceImpl> prefixes = new HashMap<String, NamespaceImpl>();
 		for (Object[] row : table.selectAll()) {
-			String prefix = (String) row[0];
-			String namespace = (String) row[1];
+			String prefix = (String)row[0];
+			String namespace = (String)row[1];
 			NamespaceImpl ns = new NamespaceImpl(prefix, namespace);
 			map.put(namespace, ns);
 			if (prefix != null) {
 				prefixes.put(prefix, ns);
 			}
 		}
 		byNamespace.putAll(map);
 		byPrefix.clear();
 		byPrefix.putAll(prefixes);
 	}
 
 	private synchronized NamespaceImpl create(String namespace)
-			throws SQLException {
+		throws SQLException
+	{
 		if (byNamespace.containsKey(namespace))
 			return byNamespace.get(namespace);
 		table.insert(null, namespace);
 		NamespaceImpl ns = new NamespaceImpl(null, namespace);
 		byNamespace.put(ns.getName(), ns);
 		return ns;
 	}
 
-	public void setPrefix(String prefix, String name) throws RdbmsException {
+	public void setPrefix(String prefix, String name)
+		throws RdbmsException
+	{
 		NamespaceImpl ns = findNamespace(name);
 		try {
 			table.updatePrefix(prefix, name);
-		} catch (SQLException e) {
+		}
+		catch (SQLException e) {
 			throw new RdbmsException(e);
 		}
 		ns.setPrefix(prefix);
 		byPrefix.put(prefix, ns);
 	}
 
 	public NamespaceImpl findByPrefix(String prefix) {
 		return byPrefix.get(prefix);
 	}
 
-	public void removePrefix(String prefix) throws RdbmsException {
+	public void removePrefix(String prefix)
+		throws RdbmsException
+	{
 		NamespaceImpl ns = findByPrefix(prefix);
 		if (ns == null)
 			return;
 		try {
 			table.updatePrefix(prefix, ns.getName());
-		} catch (SQLException e) {
+		}
+		catch (SQLException e) {
 			throw new RdbmsException(e);
 		}
 		ns.setPrefix(null);
 		byPrefix.remove(prefix);
 	}
 
 	public Collection<? extends Namespace> getNamespacesWithPrefix()
-			throws RdbmsException {
+		throws RdbmsException
+	{
 		return byPrefix.values();
 	}
 
-	public void clearPrefixes() throws RdbmsException {
+	public void clearPrefixes()
+		throws RdbmsException
+	{
 		try {
 			table.clearPrefixes();
 			load();
-		} catch (SQLException e) {
+		}
+		catch (SQLException e) {
 			throw new RdbmsException(e);
 		}
 	}
 
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/managers/TransTableManager.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/managers/TransTableManager.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/managers/TransTableManager.java (revision 85)
@@ -1,282 +1,351 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.managers;
 
 import java.sql.Connection;
 import java.sql.SQLException;
 import java.util.Collection;
 import java.util.HashMap;
 import java.util.Map;
 import java.util.concurrent.BlockingQueue;
 
 import org.openrdf.sail.helpers.DefaultSailChangedEvent;
+import org.openrdf.sail.rdbms.model.RdbmsResource;
+import org.openrdf.sail.rdbms.model.RdbmsValue;
 import org.openrdf.sail.rdbms.schema.Batch;
 import org.openrdf.sail.rdbms.schema.IdSequence;
 import org.openrdf.sail.rdbms.schema.RdbmsTable;
 import org.openrdf.sail.rdbms.schema.TableFactory;
 import org.openrdf.sail.rdbms.schema.TransactionTable;
 import org.openrdf.sail.rdbms.schema.TripleTable;
 import org.openrdf.sail.rdbms.schema.ValueTable;
 import org.openrdf.sail.rdbms.schema.ValueTypes;
 
 
 /**
  * Manages and delegates to a collection of {@link TransactionTable}s.
  * 
  * @author James Leigh
  * 
  */
 public class TransTableManager {
 	public static int BATCH_SIZE = 8 * 1024;
 	public static final boolean TEMPORARY_TABLE_USED = TripleTable.UNIQUE_INDEX_TRIPLES;
 	private TableFactory factory;
 	private TripleTableManager triples;
 	private RdbmsTable temporaryTable;
 	private Map<Number, TransactionTable> tables = new HashMap<Number, TransactionTable>();
 	private int removedCount;
 	private String fromDummy;
 	private Connection conn;
 	private BlockingQueue<Batch> batchQueue;
 	private DefaultSailChangedEvent sailChangedEvent;
 	private IdSequence ids;
 
 	public void setConnection(Connection conn) {
 		this.conn = conn;
 	}
 
 	public void setTemporaryTableFactory(TableFactory factory) {
 		this.factory = factory;
 	}
 
 	public void setStatementsTable(TripleTableManager predicateTableManager) {
 		this.triples = predicateTableManager;
 	}
 
 	public void setFromDummyTable(String fromDummy) {
 		this.fromDummy = fromDummy;
 	}
 
 	public void setBatchQueue(BlockingQueue<Batch> queue) {
 		this.batchQueue = queue;
 	}
 
 	public void setSailChangedEvent(DefaultSailChangedEvent sailChangedEvent) {
 		this.sailChangedEvent = sailChangedEvent;
 	}
 
 	public void setIdSequence(IdSequence ids) {
 		this.ids = ids;
 	}
 
 	public int getBatchSize() {
 		return BATCH_SIZE;
 	}
 
-	public void initialize() throws SQLException {
-	}
-
-	public void insert(Number ctx, Number subj, Number pred, Number obj)
-			throws SQLException, InterruptedException {
-		getTable(pred).insert(ctx, subj, pred, obj);
-	}
-
-	public void close() throws SQLException {
+	public void initialize()
+		throws SQLException
+	{
+	}
+
+	public void insert(Number ctx, Number subj, Number pred, Number obj, boolean explicit)
+		throws SQLException, InterruptedException
+	{
+		getTable(pred).insert(ctx, subj, pred, obj, explicit);
+	}
+
+	public void close()
+		throws SQLException
+	{
 		try {
 			if (temporaryTable != null) {
 				temporaryTable.drop();
 				temporaryTable.close();
 			}
-		} catch (SQLException e) {
+		}
+		catch (SQLException e) {
 			// ignore
 		}
 		for (TransactionTable table : tables.values()) {
 			table.close();
 		}
 	}
 
-	public String findTableName(Number pred) throws SQLException {
+	public String findTableName(Number pred)
+		throws SQLException
+	{
 		return triples.findTableName(pred);
 	}
 
-	public String getCombinedTableName() throws SQLException {
+	public String getCombinedTableName()
+		throws SQLException
+	{
+		return getCombinedTableName(null, null, null);
+	}
+	
+	public String getCombinedTableName(Number subj, Number obj, Number[] ctxs) throws SQLException {
 		String union = " UNION ALL ";
 		StringBuilder sb = new StringBuilder(1024);
 		sb.append("(");
 		for (Number pred : triples.getPredicateIds()) {
 			TripleTable predicate;
 			try {
 				predicate = triples.getPredicateTable(pred);
-			} catch (SQLException e) {
+			}
+			catch (SQLException e) {
 				throw new AssertionError(e);
 			}
 			TransactionTable table = findTable(pred);
 			if ((table == null || table.isEmpty()) && predicate.isEmpty())
 				continue;
 			sb.append("SELECT ctx, subj, ");
 			if (predicate.isPredColumnPresent()) {
 				sb.append(" pred,");
-			} else {
+			}
+			else {
 				sb.append(pred).append(" AS pred,");
 			}
-			sb.append(" obj");
+			sb.append(" obj,");
+			sb.append(" expl");
 			sb.append("\nFROM ");
 			sb.append(predicate.getNameWhenReady());
+			sb.append("\nWHERE 1 ");
+			
+			if (ctxs != null && ctxs.length > 0) {
+				sb.append(" AND ctx IN(");
+				for (Number ctx : ctxs) {
+					sb.append(ctx);
+					sb.append(",");
+				}
+				sb.delete(sb.length() - 1, sb.length());				
+				sb.append(")");
+			}
+			if (subj != null) {
+				sb.append(" AND subj = " + subj);
+			}
+			if (obj != null) {
+				sb.append(" AND obj = " + obj);
+			}
 			sb.append(union);
 			predicate.blockUntilReady();
 		}
 		if (sb.length() < union.length())
 			return getEmptyTableName();
 		sb.delete(sb.length() - union.length(), sb.length());
 		sb.append(")");
 		return sb.toString();
 	}
 
-	public String getTableName(Number pred) throws SQLException {
+	public String getTableName(Number pred)
+		throws SQLException
+	{
+		return getTableName(pred, null, null, null);
+	}
+
+	public String getTableName(Number pred, Number subj, Number obj, Number[] ctxs) throws SQLException {
 		if (pred.equals(ValueTable.NIL_ID))
-			return getCombinedTableName();
+			return getCombinedTableName(subj, obj, ctxs);
 		String tableName = triples.getTableName(pred);
 		if (tableName == null)
 			return getEmptyTableName();
 		return tableName;
 	}
 
-	public void committed(boolean locked) throws SQLException {
+	public void committed(boolean locked)
+		throws SQLException
+	{
 		synchronized (tables) {
 			for (TransactionTable table : tables.values()) {
 				table.committed();
 			}
 			tables.clear();
 		}
 		if (removedCount > 0) {
 			triples.removed(removedCount, locked);
 		}
 	}
 
-	public void removed(Number pred, int count) throws SQLException {
+	public void removed(Number pred, int count)
+		throws SQLException
+	{
 		getTable(pred).removed(count);
 		removedCount += count;
 	}
 
 	public Collection<Number> getPredicateIds() {
 		return triples.getPredicateIds();
 	}
 
-	public boolean isPredColumnPresent(Number id) throws SQLException {
+	public boolean isPredColumnPresent(Number id)
+		throws SQLException
+	{
 		if (id.longValue() == ValueTable.NIL_ID)
 			return true;
 		return triples.getPredicateTable(id).isPredColumnPresent();
 	}
 
 	public ValueTypes getObjTypes(Number pred) {
 		TripleTable table = triples.getExistingTable(pred);
 		if (table == null)
 			return ValueTypes.UNKNOWN;
 		return table.getObjTypes();
 	}
 
 	public ValueTypes getSubjTypes(Number pred) {
 		TripleTable table = triples.getExistingTable(pred);
 		if (table == null)
 			return ValueTypes.RESOURCE;
 		return table.getSubjTypes();
 	}
 
-	public boolean isEmpty() throws SQLException {
+	public boolean isEmpty()
+		throws SQLException
+	{
 		for (Number pred : triples.getPredicateIds()) {
 			TripleTable predicate;
 			try {
 				predicate = triples.getPredicateTable(pred);
-			} catch (SQLException e) {
+			}
+			catch (SQLException e) {
 				throw new AssertionError(e);
 			}
 			TransactionTable table = findTable(pred);
 			if (table != null && !table.isEmpty() || !predicate.isEmpty())
 				return false;
 		}
 		return true;
 	}
 
 	protected String getZeroBigInt() {
 		return "0";
 	}
 
-	protected TransactionTable getTable(Number pred) throws SQLException {
+	protected TransactionTable getTable(Number pred)
+		throws SQLException
+	{
 		synchronized (tables) {
 			TransactionTable table = tables.get(pred);
 			if (table == null) {
 				TripleTable predicate = triples.getPredicateTable(pred);
 				Number key = pred;
 				if (predicate.isPredColumnPresent()) {
 					key = ids.idOf(-1);
 					table = tables.get(key);
 					if (table != null)
 						return table;
 				}
 				table = createTransactionTable(predicate);
 				tables.put(key, table);
 			}
 			return table;
 		}
 	}
 
 	protected TransactionTable createTransactionTable(TripleTable predicate)
-			throws SQLException {
+		throws SQLException
+	{
 		if (temporaryTable == null && TEMPORARY_TABLE_USED) {
 			temporaryTable = createTemporaryTable(conn);
 			if (!temporaryTable.isCreated()) {
 				createTemporaryTable(temporaryTable);
 			}
 		}
 		TransactionTable table = createTransactionTable();
 		table.setIdSequence(ids);
 		table.setSailChangedEvent(sailChangedEvent);
 		table.setQueue(batchQueue);
 		table.setTripleTable(predicate);
 		table.setTemporaryTable(temporaryTable);
 		table.setConnection(conn);
 		table.setBatchSize(getBatchSize());
 		return table;
 	}
 
 	protected RdbmsTable createTemporaryTable(Connection conn) {
 		return factory.createTemporaryTable(conn);
 	}
 
 	protected TransactionTable createTransactionTable() {
 		return new TransactionTable();
 	}
 
-	protected void createTemporaryTable(RdbmsTable table) throws SQLException {
+	protected void createTemporaryTable(RdbmsTable table)
+		throws SQLException
+	{
 		String type = ids.getSqlType();
 		StringBuilder sb = new StringBuilder();
 		sb.append("  ctx ").append(type).append(" NOT NULL,\n");
 		sb.append("  subj ").append(type).append(" NOT NULL,\n");
 		sb.append("  pred ").append(type).append(" NOT NULL,\n");
-		sb.append("  obj ").append(type).append(" NOT NULL\n");
+		sb.append("  obj ").append(type).append(" NOT NULL,\n");
+		sb.append("  expl ").append("BOOL").append(" NOT NULL\n");
 		table.createTemporaryTable(sb);
 	}
 
 	private String getEmptyTableName() {
 		StringBuilder sb = new StringBuilder(256);
 		sb.append("(");
 		sb.append("SELECT ");
 		sb.append(getZeroBigInt()).append(" AS ctx, ");
 		sb.append(getZeroBigInt()).append(" AS subj, ");
 		sb.append(getZeroBigInt()).append(" AS pred, ");
-		sb.append(getZeroBigInt()).append(" AS obj ");
+		sb.append(getZeroBigInt()).append(" AS obj, ");
+		sb.append(getZeroBigInt()).append(" AS expl ");
 		sb.append(fromDummy);
 		sb.append("\nWHERE 1=0");
 		sb.append(")");
 		return sb.toString();
 	}
 
 	private TransactionTable findTable(Number pred) {
 		synchronized (tables) {
 			return tables.get(pred);
 		}
 	}
 
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/managers/TripleManager.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/managers/TripleManager.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/managers/TripleManager.java (revision 47)
@@ -1,44 +1,44 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.managers;
 
 import java.sql.SQLException;
 
 import org.openrdf.sail.rdbms.managers.base.ManagerBase;
 
 /**
  * 
  * @author James Leigh
  */
 public class TripleManager extends ManagerBase {
 
 	public static TripleManager instance;
 
 	private TransTableManager statements;
 
 	public TripleManager() {
 		instance = this;
 	}
 
 	public void setTransTableManager(TransTableManager statements) {
 		this.statements = statements;
 	}
 
 	@Override
 	public void close()
 		throws SQLException
 	{
 		super.close();
 		statements.close();
 	}
 
-	public void insert(Number ctx, Number subj, Number pred, Number obj)
+	public void insert(Number ctx, Number subj, Number pred, Number obj, boolean explicit)
 		throws SQLException, InterruptedException
 	{
-		statements.insert(ctx, subj, pred, obj);
+		statements.insert(ctx, subj, pred, obj, explicit);
 	}
 
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/managers/UriManager.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/managers/UriManager.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/managers/UriManager.java (revision 85)
@@ -1,74 +1,80 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.managers;
 
 import java.sql.SQLException;
 
 import org.openrdf.sail.rdbms.managers.base.ValueManagerBase;
 import org.openrdf.sail.rdbms.model.RdbmsURI;
 import org.openrdf.sail.rdbms.schema.URITable;
 
 /**
- * Manages URIs. Including creating, inserting, and looking up their
- * IDs.
+ * Manages URIs. Including creating, inserting, and looking up their IDs.
  * 
  * @author James Leigh
  * 
  */
 public class UriManager extends ValueManagerBase<RdbmsURI> {
 	public static UriManager instance;
 	private URITable table;
 
 	public UriManager() {
 		instance = this;
 	}
 
 	public void setUriTable(URITable shorter) {
 		this.table = shorter;
 	}
 
 	@Override
 	public void close()
 		throws SQLException
 	{
 		super.close();
 		table.close();
 	}
 
 	@Override
-	protected boolean expungeRemovedStatements(int count, String condition)
+	protected boolean expunge(String condition)
 		throws SQLException
 	{
-		return table.expungeRemovedStatements(count, condition);
+		return table.expunge(condition);
 	}
 
 	@Override
 	protected int getBatchSize() {
 		return table.getBatchSize();
 	}
 
 	@Override
 	protected String key(RdbmsURI value) {
 		return value.stringValue();
 	}
 
 	@Override
-	protected void insert(Number id, RdbmsURI resource) throws SQLException, InterruptedException {
+	protected void insert(Number id, RdbmsURI resource)
+		throws SQLException, InterruptedException
+	{
 		String uri = resource.stringValue();
 		if (getIdSequence().isLong(id)) {
 			table.insertLong(id, uri);
-		} else {
+		}
+		else {
 			table.insertShort(id, uri);
 		}
 	}
 
 	@Override
-	protected void optimize() throws SQLException {
+	protected void optimize()
+		throws SQLException
+	{
 		super.optimize();
 		table.optimize();
 	}
 
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/managers/base/ValueManagerBase.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/managers/base/ValueManagerBase.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/managers/base/ValueManagerBase.java (revision 85)
@@ -1,115 +1,123 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.managers.base;
 
 import java.sql.SQLException;
 import java.util.concurrent.atomic.AtomicInteger;
 
 import info.aduna.collections.LRUMap;
 
 import org.openrdf.sail.rdbms.managers.HashManager;
+import org.openrdf.sail.rdbms.model.RdbmsURI;
 import org.openrdf.sail.rdbms.model.RdbmsValue;
 import org.openrdf.sail.rdbms.schema.IdSequence;
 
 public abstract class ValueManagerBase<V extends RdbmsValue> extends ManagerBase {
 	private LRUMap<Object, V> cache;
 	private HashManager hashes;
 	private AtomicInteger version = new AtomicInteger();
 	private IdSequence ids;
 
 	public void setHashManager(HashManager hashes) {
 		this.hashes = hashes;
 	}
 
 	public IdSequence getIdSequence() {
 		return ids;
 	}
 
 	public void setIdSequence(IdSequence ids) {
 		this.ids = ids;
 	}
 
 	public void init() {
 		cache = new LRUMap<Object, V>(getBatchSize());
 	}
 
 	@Override
 	public void flush()
 		throws SQLException, InterruptedException
 	{
 		if (hashes != null) {
 			hashes.flush();
 		}
 		super.flush();
 	}
 
 	public V findInCache(Object key) {
 		synchronized (cache) {
 			if (cache.containsKey(key))
 				return cache.get(key);
 		}
 		return null;
 	}
 
 	public void cache(V value)
 		throws SQLException, InterruptedException
 	{
 		if (value.isExpired(getIdVersion())) {
 			synchronized (cache) {
 				cache.put(key(value), value);
 			}
 			if (hashes != null) {
 				hashes.lookupId(value);
 			}
 		}
 	}
 
 	public Number getInternalId(V value)
 		throws SQLException, InterruptedException
 	{
 		if (value.isExpired(getIdVersion())) {
 			if (hashes == null) {
 				Number id = ids.idOf(value);
 				value.setInternalId(id);
 				value.setVersion(getIdVersion());
 				insert(id, value);
 			}
 			else if (value.isExpired(getIdVersion())) {
 				hashes.assignId(value, getIdVersion());
 			}
 		}
 		return value.getInternalId();
 	}
 
 	public int getIdVersion() {
 		return version.intValue() + (hashes == null ? 0 : hashes.getIdVersion());
 	}
 
-	public void removedStatements(int count, String condition)
+	public void removedStatements(String condition)
 		throws SQLException
 	{
-		if (expungeRemovedStatements(count, condition)) {
+		if (expunge(condition)) {
 			version.addAndGet(1);
 		}
 	}
 
 	protected abstract int getBatchSize();
 
 	protected abstract void insert(Number id, V value)
 			throws SQLException, InterruptedException;
 
 	protected abstract Object key(V value);
 
-	protected abstract boolean expungeRemovedStatements(int count, String condition) throws SQLException;
+	protected abstract boolean expunge(String condition)
+		throws SQLException;
 
 	@Override
-	protected void optimize() throws SQLException {
+	protected void optimize()
+		throws SQLException
+	{
 		if (hashes != null) {
 			hashes.optimize();
 		}
 	}
 
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/managers/base/ManagerBase.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/managers/base/ManagerBase.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/managers/base/ManagerBase.java (revision 85)
@@ -1,171 +1,172 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.managers.base;
 
 import java.lang.reflect.InvocationHandler;
 import java.lang.reflect.Method;
 import java.lang.reflect.Proxy;
 import java.sql.SQLException;
 import java.util.concurrent.BlockingQueue;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 import org.openrdf.sail.rdbms.managers.helpers.BatchBlockingQueue;
 import org.openrdf.sail.rdbms.schema.Batch;
 
 public abstract class ManagerBase {
 	public static int BATCH_SIZE = 8 * 1024;
 
 	public static int MIN_QUEUE = 128;
 
 	public static int MAX_QUEUE = 96 * 1024;
 
 	Exception exc;
 
 	private Logger logger = LoggerFactory.getLogger(ManagerBase.class);
 
 	public final BlockingQueue<Batch> queue = new BatchBlockingQueue(MAX_QUEUE);
 
 	private final Object working = new Object();
 
 	private Batch wb;
 
 	private Thread thread;
 
 	private int count;
 
 	@SuppressWarnings("unchecked")
 	public BlockingQueue<Batch> getQueue() {
 		ClassLoader cl = getClass().getClassLoader();
 		Class<?>[] classes = new Class[] { BlockingQueue.class };
 		InvocationHandler h = new InvocationHandler() {
 
 			public Object invoke(Object proxy, Method method, Object[] args)
 				throws Throwable
 			{
 				Object result = method.invoke(queue, args);
 				checkQueueSize();
 				return result;
 			}
 		};
 		Object proxy = Proxy.newProxyInstance(cl, classes, h);
-		return (BlockingQueue<Batch>) proxy;
+		return (BlockingQueue<Batch>)proxy;
 	}
 
 	public void close()
 		throws SQLException
 	{
 		try {
 			flush();
 			if (thread != null) {
 				queue.put(Batch.CLOSED_SIGNAL);
 				thread.join();
 			}
 		}
 		catch (InterruptedException e) {
 			logger.warn(e.toString(), e);
 		}
 		throwException();
 	}
 
 	public void flush()
 		throws SQLException, InterruptedException
 	{
 		throwException();
 		synchronized (working) {
 			throwException();
 			for (Batch b = queue.poll(); isFlushable(b); b = queue.poll()) {
 				flush(b);
 			}
 			if (wb != null) {
 				flush(wb);
 				wb = null;
 			}
 			count = 0;
 		}
 	}
 
 	public void clear() {
 		queue.clear();
 	}
 
 	protected void optimize()
 		throws SQLException
 	{
 		// allow subclasses to optimise table
 	}
 
 	void checkQueueSize() {
 		if (++count >= MIN_QUEUE && thread == null) {
 			String name = getClass().getSimpleName() + "-flusher";
 			thread = new Thread(new Runnable() {
 
 				public void run() {
 					try {
 						insertThread(working);
 					}
 					catch (Exception e) {
 						exc = e;
 						logger.error(e.toString(), e);
 					}
 				}
 			}, name);
 			thread.start();
 		}
 	}
 
 	protected void flush(Batch batch)
 		throws SQLException
 	{
 		batch.flush();
 	}
 
 	void insertThread(Object working)
 		throws SQLException, InterruptedException
 	{
 		String name = Thread.currentThread().getName();
 		logger.debug("Starting helper thread {}", name);
 		int notReadyCount = 0;
 		for (wb = queue.take(); isFlushable(wb); wb = queue.take()) {
 			if (wb.isReady() || queue.size() <= notReadyCount) {
 				synchronized (working) {
 					if (wb != null) {
 						flush(wb);
 						wb = null;
 					}
 				}
 				optimize();
 				notReadyCount = 0;
 			}
 			else {
 				queue.add(wb);
 				notReadyCount++;
 			}
 		}
 		logger.debug("Closing helper thread {}", name);
 	}
 
 	private boolean isFlushable(Batch batch) {
 		return batch != null && batch != Batch.CLOSED_SIGNAL;
 	}
 
 	private void throwException()
 		throws SQLException
 	{
 		if (exc instanceof SQLException) {
 			SQLException e = (SQLException)exc;
 			exc = null;
 			throw e;
 		}
 		else if (exc instanceof RuntimeException) {
 			RuntimeException e = (RuntimeException)exc;
 			exc = null;
 			throw e;
 		}
 	}
 
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/managers/PredicateManager.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/managers/PredicateManager.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/managers/PredicateManager.java (revision 85)
@@ -1,37 +1,41 @@
 package org.openrdf.sail.rdbms.managers;
 
 import java.sql.SQLException;
 import java.util.Map;
 
 import info.aduna.collections.LRUMap;
 
 import org.openrdf.sail.rdbms.model.RdbmsURI;
 
 public class PredicateManager {
 	private UriManager uris;
 	private Map<Number, String> predicates = new LRUMap<Number, String>(64);
 
 	public void setUriManager(UriManager uris) {
 		this.uris = uris;
 	}
 
-	public Number getIdOfPredicate(RdbmsURI uri) throws SQLException, InterruptedException {
+	public Number getIdOfPredicate(RdbmsURI uri)
+		throws SQLException, InterruptedException
+	{
 		Number id = uris.getInternalId(uri);
-		synchronized(predicates) {
+		synchronized (predicates) {
 			predicates.put(id, uri.stringValue());
 		}
 		return id;
 	}
 
 	public String getPredicateUri(Number id) {
-		synchronized(predicates) {
+		synchronized (predicates) {
 			return predicates.get(id);
 		}
 	}
 
 	public void remove(Number id) {
-		synchronized(predicates) {
+		synchronized (predicates) {
 			predicates.remove(id);
 		}
 	}
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/managers/HashManager.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/managers/HashManager.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/managers/HashManager.java (revision 85)
@@ -1,313 +1,367 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.managers;
 
 
 import java.sql.SQLException;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.concurrent.ArrayBlockingQueue;
 import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.atomic.AtomicInteger;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 import org.openrdf.sail.rdbms.managers.base.ManagerBase;
 import org.openrdf.sail.rdbms.model.RdbmsBNode;
 import org.openrdf.sail.rdbms.model.RdbmsLiteral;
 import org.openrdf.sail.rdbms.model.RdbmsURI;
 import org.openrdf.sail.rdbms.model.RdbmsValue;
 import org.openrdf.sail.rdbms.schema.Batch;
 import org.openrdf.sail.rdbms.schema.HashBatch;
 import org.openrdf.sail.rdbms.schema.HashTable;
 import org.openrdf.sail.rdbms.schema.IdSequence;
 
 /**
  * 
  * @author James Leigh
  */
 public class HashManager extends ManagerBase {
 	public static HashManager instance;
 	private Logger logger = LoggerFactory.getLogger(HashManager.class);
 	private HashTable table;
 	private Map<Long, Number> ids;
 	private AtomicInteger version = new AtomicInteger();
 	private BNodeManager bnodes;
 	private UriManager uris;
 	private LiteralManager literals;
 	private Thread lookupThread;
+
+	private Object assignIds = new Object();
+
 	private Object working = new Object();
 	private BlockingQueue<RdbmsValue> queue;
-	private IdSequence idseq; 
+
+	private IdSequence idseq;
+
 	Exception exc;
 	RdbmsValue closeSignal = new RdbmsValue() {
 		private static final long serialVersionUID = -2211413309013905712L;
 
 		public String stringValue() {
 			return null;
-		}};
+		}
+	};
+	private RdbmsValue taken;
 
 	public HashManager() {
 		instance = this;
 	}
 
 	public void setHashTable(HashTable table) {
 		this.table = table;
 		ids = new HashMap<Long, Number>(table.getBatchSize());
 	}
 
 	public void setBNodeManager(BNodeManager bnodeTable) {
 		this.bnodes = bnodeTable;
 	}
 
 	public void setLiteralManager(LiteralManager literalTable) {
 		this.literals = literalTable;
 	}
 
 	public void setUriManager(UriManager uriTable) {
 		this.uris = uriTable;
 	}
 
 	public void setIdSequence(IdSequence idseq) {
 		this.idseq = idseq;
 	}
 
 	public void init() {
 		queue = new ArrayBlockingQueue<RdbmsValue>(table.getBatchSize());
 		lookupThread = new Thread(new Runnable() {
 			public void run() {
 				try {
-					lookupThread(working);
-				} catch (Exception e) {
+					lookupThread(working, assignIds);
+				}
+				catch (Exception e) {
 					exc = e;
 					logger.error(e.toString(), e);
 				}
 			}
 		}, "id-lookup");
 		lookupThread.start();
 	}
 
 	@Override
 	public void close()
 		throws SQLException
 	{
 		try {
 			flush();
 			if (lookupThread != null) {
 				queue.put(closeSignal);
 				lookupThread.join();
 			}
-		} catch (InterruptedException e) {
+		}
+		catch (InterruptedException e) {
 			logger.warn(e.toString(), e);
 		}
 		super.close();
 		table.close();
 	}
 
 	public int getIdVersion() {
 		return version.intValue();
 	}
 
 	public void optimize()
 		throws SQLException
 	{
 		table.optimize();
 	}
 
-	public boolean removedStatements(int count, String condition) throws SQLException {
+	public boolean removedStatements(int count, String condition)
+		throws SQLException
+	{
 		if (table.expungeRemovedStatements(count, condition)) {
 			version.addAndGet(1);
 			return true;
 		}
 		return false;
 	}
 
-	public void lookupId(RdbmsValue value) throws InterruptedException {
+	public void lookupId(RdbmsValue value)
+		throws InterruptedException
+	{
 		queue.put(value);
 	}
 
 	public void assignId(RdbmsValue value, int version)
 		throws InterruptedException, SQLException
 	{
 		List<RdbmsValue> values = new ArrayList<RdbmsValue>(getChunkSize());
-		synchronized (working) {
+		synchronized (assignIds) {
 			throwException();
 			if (value.isExpired(version)) {
 				Map<Long, Number> map = new HashMap<Long, Number>(getChunkSize());
 				values.add(value);
 				assignIds(values, map);
 			}
 		}
 		for (RdbmsValue v : values) {
 			insert(v);
 		}
 	}
 
 	@Override
 	public void flush()
 		throws SQLException, InterruptedException
 	{
 		throwException();
 		List<RdbmsValue> values = new ArrayList<RdbmsValue>(getChunkSize());
 		Map<Long, Number> map = new HashMap<Long, Number>(getChunkSize());
 		RdbmsValue taken = queue.poll();
 		while (taken != null) {
 			values.clear();
 			values.add(taken);
-			synchronized (working) {
+			synchronized (assignIds) {
 				assignIds(values, map);
 			}
 			for (RdbmsValue v : values) {
 				insert(v);
 			}
 			taken = queue.poll();
 			if (taken == closeSignal) {
 				queue.add(taken);
 				taken = null;
 			}
 		}
+		synchronized (working) {
+			values.clear();
+			synchronized (assignIds) {
+				if (this.taken != null && this.taken != closeSignal) {
+					values.add(this.taken);
+					assignIds(values, map);
+					this.taken = null;
+				}
+			}
+			for (RdbmsValue v : values) {
+				insert(v);
+			}
+		}
 		super.flush();
+	}
+
+	public String getExpungeCondition() {
+		StringBuilder sb = new StringBuilder();
+		sb.append("AND id NOT IN (SELECT id FROM ");
+		sb.append(table.getName()).append(")");
+		return sb.toString();
 	}
 
 	protected int getChunkSize() {
 		return table.getSelectChunkSize();
 	}
 
 	@Override
 	protected void flush(Batch batch)
 		throws SQLException
 	{
 		super.flush(batch);
-		synchronized (working) {
+		synchronized (assignIds) {
 			synchronized (ids) {
-				HashBatch hb = (HashBatch) batch;
+				HashBatch hb = (HashBatch)batch;
 				for (Long hash : hb.getHashes()) {
 					ids.remove(hash);
 				}
 			}
 		}
 	}
 
-	void lookupThread(Object working)
+	void lookupThread(Object working, Object assignIds)
 		throws InterruptedException, SQLException
 	{
 		List<RdbmsValue> values = new ArrayList<RdbmsValue>(getChunkSize());
 		Map<Long, Number> map = new HashMap<Long, Number>(getChunkSize());
-		RdbmsValue taken = queue.take();
+		taken = queue.take();
 		for (; taken != closeSignal; taken = queue.take()) {
-			values.clear();
-			values.add(taken);
 			synchronized (working) {
-				assignIds(values, map);
-			}
-			for (RdbmsValue v : values) {
-				insert(v);
+				values.clear();
+				synchronized (assignIds) {
+					if (taken != null) {
+						values.add(taken);
+						assignIds(values, map);
+						taken = null;
+					}
+				}
+				for (RdbmsValue v : values) {
+					insert(v);
+				}
 			}
 		}
 	}
 
 	private void assignIds(List<RdbmsValue> values, Map<Long, Number> map)
 		throws SQLException, InterruptedException
 	{
 		while (values.size() < getChunkSize()) {
 			RdbmsValue taken = queue.poll();
 			if (taken == closeSignal) {
 				queue.add(taken);
 				break;
 			}
 			if (taken == null)
 				break;
 			values.add(taken);
 		}
 		Map<Long, Number> existing = lookup(values, map);
 		Iterator<RdbmsValue> iter = values.iterator();
 		while (iter.hasNext()) {
 			RdbmsValue value = iter.next();
 			Long hash = idseq.hashOf(value);
 			if (existing.get(hash) != null) {
 				// already in database
-				value.setInternalId(idseq.idOf(existing.get(hash)));
+				Number id = idseq.idOf(existing.get(hash));
+				value.setInternalId(id);
 				value.setVersion(getIdVersion(value));
 				iter.remove();
 			}
 			else {
 				synchronized (ids) {
 					if (ids.containsKey(hash)) {
 						// already inserting this value
-						value.setInternalId(ids.get(hash));
+						Number id = ids.get(hash);
+						value.setInternalId(id);
 						value.setVersion(getIdVersion(value));
 						iter.remove();
 					}
 					else {
 						// new id to be inserted
 						Number id = idseq.nextId(value);
 						value.setInternalId(id);
 						value.setVersion(getIdVersion(value));
 						ids.put(hash, id);
 						// keep on list for later insert
 					}
 				}
 			}
 		}
 	}
 
-	private Map<Long, Number> lookup(Collection<RdbmsValue> values, Map<Long, Number> map) throws SQLException {
+	private Map<Long, Number> lookup(Collection<RdbmsValue> values, Map<Long, Number> map)
+		throws SQLException
+	{
 		assert !values.isEmpty();
 		assert values.size() <= getChunkSize();
 		map.clear();
 		for (RdbmsValue value : values) {
 			map.put(idseq.hashOf(value), null);
 		}
 		return table.load(map);
 	}
 
 	private Integer getIdVersion(RdbmsValue value) {
 		if (value instanceof RdbmsLiteral)
 			return literals.getIdVersion();
 		if (value instanceof RdbmsURI)
 			return uris.getIdVersion();
 		assert value instanceof RdbmsBNode;
 		return bnodes.getIdVersion();
 	}
 
 	private void insert(RdbmsValue value)
 		throws SQLException, InterruptedException
 	{
 		Number id = value.getInternalId();
 		table.insert(id, idseq.hashOf(value));
 		if (value instanceof RdbmsLiteral) {
 			literals.insert(id, (RdbmsLiteral)value);
 		}
 		else if (value instanceof RdbmsURI) {
 			uris.insert(id, (RdbmsURI)value);
 		}
 		else {
 			assert value instanceof RdbmsBNode;
 			bnodes.insert(id, (RdbmsBNode)value);
 		}
 	}
 
 	private void throwException()
 		throws SQLException
 	{
 		if (exc instanceof SQLException) {
 			SQLException e = (SQLException)exc;
 			exc = null;
 			throw e;
 		}
 		else if (exc instanceof RuntimeException) {
 			RuntimeException e = (RuntimeException)exc;
 			exc = null;
 			throw e;
 		}
 	}
 
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/SqlMbrContains.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/SqlMbrContains.java (revision 84)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/SqlMbrContains.java (revision 84)
@@ -0,0 +1,159 @@
+package org.openrdf.sail.rdbms.algebra;
+
+import org.openrdf.query.algebra.QueryModelNode;
+import org.openrdf.query.algebra.QueryModelVisitor;
+import org.openrdf.query.algebra.helpers.QueryModelTreePrinter;
+import org.openrdf.sail.rdbms.algebra.base.RdbmsQueryModelNodeBase;
+import org.openrdf.sail.rdbms.algebra.base.RdbmsQueryModelVisitorBase;
+import org.openrdf.sail.rdbms.algebra.base.SqlExpr;
+import org.openrdf.sail.rdbms.algebra.base.UnarySqlOperator;
+import org.openrdf.sail.rdbms.optimizers.SqlConstantOptimizer;
+
+/**
+ * SqlMbrContains
+ * (code largely based on BinarySqlOperator.java)
+ * 
+ */
+public class SqlMbrContains extends RdbmsQueryModelNodeBase
+		implements SqlExpr {
+	private StringValue pointSW, pointNE;
+	private SqlExpr pointCol;
+//	private LabelColumn pointCol;
+
+	public SqlMbrContains(StringValue pointSW, StringValue pointNE, SqlExpr pointCol) {
+		super();
+		setPointSW(pointSW);
+		setPointNE(pointNE);
+		setPointCol(pointCol);
+	}
+	
+	@Override
+	public <X extends Exception> void visit(
+			RdbmsQueryModelVisitorBase<X> visitor) throws X {
+		visitor.meet(this);
+	}	
+
+	@Override
+	public <X extends Exception> void visitChildren(QueryModelVisitor<X> visitor)
+			throws X {
+		pointSW.visit(visitor);
+		pointNE.visit(visitor);
+		pointCol.visit(visitor);
+	}
+
+	@Override
+	public void replaceChildNode(QueryModelNode current,
+			QueryModelNode replacement) {
+		if (pointSW == current) {
+			setPointSW((StringValue) replacement);
+		} else if (pointNE == current) {
+			setPointNE((StringValue) replacement);
+		} else if (pointCol == current) {
+			setPointCol((PointColumn) replacement);
+		} else {
+			super.replaceChildNode(current, replacement);
+		}
+	}
+
+	@Override
+	public SqlMbrContains clone() {
+		SqlMbrContains clone = (SqlMbrContains) super.clone();
+		clone.setPointSW((StringValue) pointSW.clone());
+		clone.setPointNE((StringValue) pointNE.clone());
+		clone.setPointCol((PointColumn) pointCol.clone());
+		return clone;
+	}
+
+	@Override
+	public int hashCode() {
+		final int prime = 31;
+		int result = 1;
+		result = prime * result + ((pointSW == null) ? 0 : pointSW.hashCode());
+		result = prime * result + ((pointNE == null) ? 0 : pointNE.hashCode());
+		result = prime * result + ((pointCol == null) ? 0 : pointCol.hashCode());
+		return result;
+	}
+
+	@Override
+	public boolean equals(Object obj) {
+		if (this == obj)
+			return true;
+		if (obj == null)
+			return false;
+		if (getClass() != obj.getClass())
+			return false;
+		final SqlMbrContains other = (SqlMbrContains) obj;
+		if (pointSW == null) {
+			if (other.pointSW != null)
+				return false;
+		} else if (!pointSW.equals(other.pointSW))
+			return false;
+		if (pointNE == null) {
+			if (other.pointNE != null)
+				return false;
+		} else if (!pointNE.equals(other.pointNE))
+			return false;
+		if (pointCol == null) {
+			if (other.pointCol != null)
+				return false;
+		} else if (!pointCol.equals(other.pointCol))
+			return false;
+		return true;
+	}
+
+	@Override
+	public String toString() {
+		QueryModelTreePrinter treePrinter = new QueryModelTreePrinter();
+		SqlMbrContains clone = this.clone();
+		UnarySqlOperator parent = new UnarySqlOperator(clone){
+			@Override
+			public <X extends Exception> void visit(
+					RdbmsQueryModelVisitorBase<X> visitor) throws X {
+				visitor.meetOther(this);
+			}};
+		new SqlConstantOptimizer().optimize(clone);
+		parent.getArg().visit(treePrinter);
+		return treePrinter.getTreeString();
+	}
+
+	public StringValue getPointSW() {
+		return pointSW;
+	}
+
+	public void setPointSW(StringValue pointSW) {
+		this.pointSW = pointSW;
+		pointSW.setParentNode(this);
+	}
+
+	public StringValue getPointNE() {
+		return pointNE;
+	}
+
+	public void setPointNE(StringValue pointNE) {
+		this.pointNE = pointNE;
+		pointNE.setParentNode(this);
+	}
+
+	public SqlExpr getPointCol() {
+		return pointCol;
+	}
+
+	public void setPointCol(SqlExpr pointCol) {
+		this.pointCol = pointCol;
+		pointCol.setParentNode(this);
+	}
+
+	/**
+	 * 
+	 * POLYGON((sw_long sw_lat, ne_long sw_lat, ne_long ne_lat, sw_long ne_lat, sw_long sw_lat))
+	 */
+	public SqlExpr toPolygon() {
+		String[] sw = pointSW.getValue().split(" "); /* lat long */
+		String[] ne = pointNE.getValue().split(" "); /* lat long */
+		return new StringValue("POLYGON((" + sw[1] /* sw_long */ + " " + sw[0] /* sw_lat */ + ", "
+										   + ne[1] /* ne_long */ + " " + sw[0] /* sw_lat */ + ", "
+										   + ne[1] /* ne_long */ + " " + ne[0] /* ne_lat */ + ", "
+										   + sw[1] /* sw_long */ + " " + ne[0] /* ne_lat */ + ", "
+										   + sw[1] /* sw_long */ + " " + sw[0] /* sw_lat */ + "))");
+	}
+}
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/factories/PointExprFactory.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/factories/PointExprFactory.java (revision 84)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/factories/PointExprFactory.java (revision 84)
@@ -0,0 +1,88 @@
+package org.openrdf.sail.rdbms.algebra.factories;
+
+import static org.openrdf.sail.rdbms.algebra.base.SqlExprSupport.sqlNull;
+import static org.openrdf.sail.rdbms.algebra.base.SqlExprSupport.str;
+import static org.openrdf.sail.rdbms.algebra.base.SqlExprSupport.unsupported;
+
+import org.openrdf.model.Literal;
+import org.openrdf.model.Value;
+import org.openrdf.query.algebra.Datatype;
+import org.openrdf.query.algebra.Lang;
+import org.openrdf.query.algebra.MathExpr;
+import org.openrdf.query.algebra.QueryModelNode;
+import org.openrdf.query.algebra.Str;
+import org.openrdf.query.algebra.ValueConstant;
+import org.openrdf.query.algebra.ValueExpr;
+import org.openrdf.query.algebra.Var;
+import org.openrdf.query.algebra.helpers.QueryModelVisitorBase;
+import org.openrdf.sail.rdbms.algebra.PointColumn;
+import org.openrdf.sail.rdbms.algebra.SqlNull;
+import org.openrdf.sail.rdbms.algebra.base.SqlExpr;
+import org.openrdf.sail.rdbms.exceptions.UnsupportedRdbmsOperatorException;
+
+/**
+ * Creates an SQL expression of a literal's point value.
+ */
+public class PointExprFactory extends
+		QueryModelVisitorBase<UnsupportedRdbmsOperatorException> {
+	protected SqlExpr result;
+
+	public SqlExpr createPointExpr(ValueExpr expr)
+			throws UnsupportedRdbmsOperatorException {
+		result = null;
+		if (expr == null)
+			return new SqlNull();
+		expr.visit(this);
+		if (result == null)
+			return new SqlNull();
+		return result;
+	}
+
+	@Override
+	public void meet(Datatype node) {
+		result = sqlNull();
+	}
+
+	@Override
+	public void meet(Lang node) throws UnsupportedRdbmsOperatorException {
+		result = sqlNull();
+	}
+
+	@Override
+	public void meet(MathExpr node) throws UnsupportedRdbmsOperatorException {
+		result = sqlNull();
+	}
+
+	@Override
+	public void meet(Str node) {
+		result = sqlNull();
+	}
+
+	@Override
+	public void meet(ValueConstant vc) {
+		result = valueOf(vc.getValue());
+	}
+
+	@Override
+	public void meet(Var var) {
+		if (var.getValue() == null) {
+			result = new PointColumn(var);
+		} else {
+			result = valueOf(var.getValue());
+		}
+	}
+
+	@Override
+	protected void meetNode(QueryModelNode arg)
+			throws UnsupportedRdbmsOperatorException {
+		throw unsupported(arg);
+	}
+
+	private SqlExpr valueOf(Value value) {
+		if (value instanceof Literal) {
+			return str(((Literal) value).getLabel());
+		}
+		return sqlNull();
+	}
+
+}
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/factories/DatatypeExprFactory.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/factories/DatatypeExprFactory.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/factories/DatatypeExprFactory.java (revision 85)
@@ -1,118 +1,129 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.algebra.factories;
 
 import static org.openrdf.model.vocabulary.XMLSchema.DECIMAL;
 import static org.openrdf.model.vocabulary.XMLSchema.DOUBLE;
 import static org.openrdf.model.vocabulary.XMLSchema.FLOAT;
 import static org.openrdf.model.vocabulary.XMLSchema.INTEGER;
 import static org.openrdf.sail.rdbms.algebra.base.SqlExprSupport.in;
 import static org.openrdf.sail.rdbms.algebra.base.SqlExprSupport.sqlNull;
 import static org.openrdf.sail.rdbms.algebra.base.SqlExprSupport.str;
 import static org.openrdf.sail.rdbms.algebra.base.SqlExprSupport.unsupported;
 
 import org.openrdf.model.Literal;
 import org.openrdf.model.URI;
 import org.openrdf.model.Value;
 import org.openrdf.query.algebra.Datatype;
 import org.openrdf.query.algebra.Lang;
 import org.openrdf.query.algebra.MathExpr;
 import org.openrdf.query.algebra.QueryModelNode;
 import org.openrdf.query.algebra.Str;
 import org.openrdf.query.algebra.ValueConstant;
 import org.openrdf.query.algebra.ValueExpr;
 import org.openrdf.query.algebra.Var;
 import org.openrdf.query.algebra.helpers.QueryModelVisitorBase;
 import org.openrdf.sail.rdbms.algebra.DatatypeColumn;
 import org.openrdf.sail.rdbms.algebra.SqlCase;
 import org.openrdf.sail.rdbms.algebra.SqlNull;
 import org.openrdf.sail.rdbms.algebra.TrueValue;
 import org.openrdf.sail.rdbms.algebra.base.SqlExpr;
 import org.openrdf.sail.rdbms.exceptions.UnsupportedRdbmsOperatorException;
 
 /**
  * Creates a datatype SQL expression.
  * 
  * @author James Leigh
  * 
  */
-public class DatatypeExprFactory extends
-		QueryModelVisitorBase<UnsupportedRdbmsOperatorException> {
+public class DatatypeExprFactory extends QueryModelVisitorBase<UnsupportedRdbmsOperatorException> {
+
 	protected SqlExpr result;
 
 	public SqlExpr createDatatypeExpr(ValueExpr expr)
-			throws UnsupportedRdbmsOperatorException {
+		throws UnsupportedRdbmsOperatorException
+	{
 		result = null;
 		if (expr == null)
 			return new SqlNull();
 		expr.visit(this);
 		if (result == null)
 			return new SqlNull();
 		return result;
 	}
 
 	@Override
 	public void meet(Datatype node) {
 		result = sqlNull();
 	}
 
 	@Override
-	public void meet(Lang node) throws UnsupportedRdbmsOperatorException {
+	public void meet(Lang node)
+		throws UnsupportedRdbmsOperatorException
+	{
 		result = sqlNull();
 	}
 
 	@Override
-	public void meet(MathExpr node) throws UnsupportedRdbmsOperatorException {
+	public void meet(MathExpr node)
+		throws UnsupportedRdbmsOperatorException
+	{
 		boolean divide = node.getParentNode().equals(MathExpr.MathOp.DIVIDE);
 		ValueExpr left = node.getLeftArg();
 		ValueExpr right = node.getRightArg();
 		SqlCase sqlCase = new SqlCase();
 		sqlCase.when(in(str(DOUBLE), type(left), type(right)), str(DOUBLE));
 		sqlCase.when(in(str(FLOAT), type(left), type(right)), str(FLOAT));
 		sqlCase.when(in(str(DECIMAL), type(left), type(right)), str(DECIMAL));
 		sqlCase.when(new TrueValue(), divide ? str(DECIMAL) : str(INTEGER));
 		result = sqlCase;
 	}
 
 	@Override
-	public void meet(Str node) throws UnsupportedRdbmsOperatorException {
+	public void meet(Str node)
+		throws UnsupportedRdbmsOperatorException
+	{
 		result = sqlNull();
 	}
 
 	@Override
 	public void meet(ValueConstant vc) {
 		result = valueOf(vc.getValue());
 	}
 
 	@Override
 	public void meet(Var var) {
 		if (var.getValue() == null) {
 			result = new DatatypeColumn(var);
-		} else {
+		}
+		else {
 			result = valueOf(var.getValue());
 		}
 	}
 
 	@Override
 	protected void meetNode(QueryModelNode arg)
-			throws UnsupportedRdbmsOperatorException {
+		throws UnsupportedRdbmsOperatorException
+	{
 		throw unsupported(arg);
 	}
 
 	private SqlExpr valueOf(Value value) {
 		if (value instanceof Literal) {
-			URI datatype = ((Literal) value).getDatatype();
+			URI datatype = ((Literal)value).getDatatype();
 			if (datatype != null)
 				return str(datatype.stringValue());
 		}
 		return sqlNull();
 	}
 
-	private SqlExpr type(ValueExpr expr) throws UnsupportedRdbmsOperatorException {
+	private SqlExpr type(ValueExpr expr)
+		throws UnsupportedRdbmsOperatorException
+	{
 		return createDatatypeExpr(expr);
 	}
 
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/factories/TimeExprFactory.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/factories/TimeExprFactory.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/factories/TimeExprFactory.java (revision 85)
@@ -1,106 +1,114 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.algebra.factories;
 
 import static org.openrdf.sail.rdbms.algebra.base.SqlExprSupport.sqlNull;
 import static org.openrdf.sail.rdbms.algebra.base.SqlExprSupport.unsupported;
 import static org.openrdf.sail.rdbms.managers.LiteralManager.getCalendarValue;
 
 import org.openrdf.model.Literal;
 import org.openrdf.model.URI;
 import org.openrdf.model.Value;
 import org.openrdf.model.datatypes.XMLDatatypeUtil;
 import org.openrdf.query.algebra.Datatype;
 import org.openrdf.query.algebra.Lang;
 import org.openrdf.query.algebra.MathExpr;
 import org.openrdf.query.algebra.QueryModelNode;
 import org.openrdf.query.algebra.Str;
 import org.openrdf.query.algebra.ValueConstant;
 import org.openrdf.query.algebra.ValueExpr;
 import org.openrdf.query.algebra.Var;
 import org.openrdf.query.algebra.helpers.QueryModelVisitorBase;
 import org.openrdf.sail.rdbms.algebra.DateTimeColumn;
 import org.openrdf.sail.rdbms.algebra.NumberValue;
 import org.openrdf.sail.rdbms.algebra.SqlNull;
 import org.openrdf.sail.rdbms.algebra.base.SqlExpr;
 import org.openrdf.sail.rdbms.exceptions.UnsupportedRdbmsOperatorException;
 
 /**
  * Creates an SQL expression for a literal's time value.
  * 
  * @author James Leigh
  * 
  */
-public class TimeExprFactory extends
-		QueryModelVisitorBase<UnsupportedRdbmsOperatorException> {
+public class TimeExprFactory extends QueryModelVisitorBase<UnsupportedRdbmsOperatorException> {
+
 	protected SqlExpr result;
 
 	public SqlExpr createTimeExpr(ValueExpr expr)
-			throws UnsupportedRdbmsOperatorException {
+		throws UnsupportedRdbmsOperatorException
+	{
 		result = null;
 		if (expr == null)
 			return new SqlNull();
 		expr.visit(this);
 		if (result == null)
 			return new SqlNull();
 		return result;
 	}
 
 	@Override
 	public void meet(Datatype node) {
 		result = sqlNull();
 	}
 
 	@Override
-	public void meet(Lang node) throws UnsupportedRdbmsOperatorException {
+	public void meet(Lang node)
+		throws UnsupportedRdbmsOperatorException
+	{
 		result = sqlNull();
 	}
 
 	@Override
-	public void meet(MathExpr node) throws UnsupportedRdbmsOperatorException {
+	public void meet(MathExpr node)
+		throws UnsupportedRdbmsOperatorException
+	{
 		result = sqlNull();
 	}
 
 	@Override
 	public void meet(Str node) {
 		result = sqlNull();
 	}
 
 	@Override
 	public void meet(ValueConstant vc) {
 		result = valueOf(vc.getValue());
 	}
 
 	@Override
 	public void meet(Var node) {
 		if (node.getValue() == null) {
 			result = new DateTimeColumn(node);
-		} else {
+		}
+		else {
 			result = valueOf(node.getValue());
 		}
 	}
 
 	@Override
 	protected void meetNode(QueryModelNode arg)
-			throws UnsupportedRdbmsOperatorException {
+		throws UnsupportedRdbmsOperatorException
+	{
 		throw unsupported(arg);
 	}
 
 	private SqlExpr valueOf(Value value) {
 		if (value instanceof Literal) {
-			Literal lit = (Literal) value;
+			Literal lit = (Literal)value;
 			URI dt = lit.getDatatype();
 			if (dt != null && XMLDatatypeUtil.isCalendarDatatype(dt)) {
 				try {
 					return new NumberValue(getCalendarValue(lit.calendarValue()));
-				} catch (IllegalArgumentException e) {
+				}
+				catch (IllegalArgumentException e) {
 					return null;
 				}
 			}
 		}
 		return null;
 	}
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/factories/BooleanExprFactory.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/factories/BooleanExprFactory.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/factories/BooleanExprFactory.java (revision 85)
@@ -1,342 +1,428 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.algebra.factories;
 
 import static org.openrdf.sail.rdbms.algebra.base.SqlExprSupport.abs;
 import static org.openrdf.sail.rdbms.algebra.base.SqlExprSupport.and;
 import static org.openrdf.sail.rdbms.algebra.base.SqlExprSupport.cmp;
 import static org.openrdf.sail.rdbms.algebra.base.SqlExprSupport.concat;
 import static org.openrdf.sail.rdbms.algebra.base.SqlExprSupport.eq;
 import static org.openrdf.sail.rdbms.algebra.base.SqlExprSupport.eqComparingNull;
 import static org.openrdf.sail.rdbms.algebra.base.SqlExprSupport.eqIfNotNull;
 import static org.openrdf.sail.rdbms.algebra.base.SqlExprSupport.gt;
 import static org.openrdf.sail.rdbms.algebra.base.SqlExprSupport.isNotNull;
 import static org.openrdf.sail.rdbms.algebra.base.SqlExprSupport.isNull;
 import static org.openrdf.sail.rdbms.algebra.base.SqlExprSupport.like;
 import static org.openrdf.sail.rdbms.algebra.base.SqlExprSupport.lowercase;
 import static org.openrdf.sail.rdbms.algebra.base.SqlExprSupport.neq;
 import static org.openrdf.sail.rdbms.algebra.base.SqlExprSupport.not;
 import static org.openrdf.sail.rdbms.algebra.base.SqlExprSupport.num;
 import static org.openrdf.sail.rdbms.algebra.base.SqlExprSupport.or;
 import static org.openrdf.sail.rdbms.algebra.base.SqlExprSupport.regex;
 import static org.openrdf.sail.rdbms.algebra.base.SqlExprSupport.simple;
 import static org.openrdf.sail.rdbms.algebra.base.SqlExprSupport.sqlNull;
 import static org.openrdf.sail.rdbms.algebra.base.SqlExprSupport.str;
 import static org.openrdf.sail.rdbms.algebra.base.SqlExprSupport.sub;
 import static org.openrdf.sail.rdbms.algebra.base.SqlExprSupport.unsupported;
 
+import java.util.List;
+
 import org.openrdf.model.Literal;
 import org.openrdf.model.Value;
 import org.openrdf.model.vocabulary.XMLSchema;
 import org.openrdf.query.algebra.And;
 import org.openrdf.query.algebra.Bound;
 import org.openrdf.query.algebra.Compare;
+import org.openrdf.query.algebra.FunctionCall;
 import org.openrdf.query.algebra.IsBNode;
 import org.openrdf.query.algebra.IsLiteral;
 import org.openrdf.query.algebra.IsResource;
 import org.openrdf.query.algebra.IsURI;
 import org.openrdf.query.algebra.LangMatches;
 import org.openrdf.query.algebra.Not;
 import org.openrdf.query.algebra.Or;
 import org.openrdf.query.algebra.QueryModelNode;
 import org.openrdf.query.algebra.Regex;
 import org.openrdf.query.algebra.SameTerm;
 import org.openrdf.query.algebra.ValueConstant;
 import org.openrdf.query.algebra.ValueExpr;
 import org.openrdf.query.algebra.Var;
 import org.openrdf.query.algebra.Compare.CompareOp;
 import org.openrdf.query.algebra.helpers.QueryModelVisitorBase;
 import org.openrdf.sail.rdbms.algebra.FalseValue;
 import org.openrdf.sail.rdbms.algebra.RefIdColumn;
 import org.openrdf.sail.rdbms.algebra.SqlCase;
+import org.openrdf.sail.rdbms.algebra.SqlMbrContains;
 import org.openrdf.sail.rdbms.algebra.SqlNull;
+import org.openrdf.sail.rdbms.algebra.StringValue;
 import org.openrdf.sail.rdbms.algebra.TrueValue;
 import org.openrdf.sail.rdbms.algebra.base.SqlExpr;
 import org.openrdf.sail.rdbms.exceptions.UnsupportedRdbmsOperatorException;
 
 /**
  * Boolean SQL expression factory. This factory can convert a number of core
  * algebra nodes into an SQL expression.
  * 
  * @author James Leigh
  * 
  */
-public class BooleanExprFactory extends
-		QueryModelVisitorBase<UnsupportedRdbmsOperatorException> {
+public class BooleanExprFactory extends QueryModelVisitorBase<UnsupportedRdbmsOperatorException> {
+
 	private static final double HR14 = 14 * 60 * 60 * 1000;
 	protected SqlExpr result;
 	private SqlExprFactory sql;
 
 	public SqlExpr createBooleanExpr(ValueExpr expr)
-			throws UnsupportedRdbmsOperatorException {
+		throws UnsupportedRdbmsOperatorException
+	{
 		result = null;
 		if (expr == null)
 			return new SqlNull();
 		expr.visit(this);
 		if (result == null)
 			return new SqlNull();
 		return result;
 	}
 
 	@Override
-	public void meet(And node) throws UnsupportedRdbmsOperatorException {
+	public void meet(And node)
+		throws UnsupportedRdbmsOperatorException
+	{
 		result = and(bool(node.getLeftArg()), bool(node.getRightArg()));
 	}
 
 	@Override
-	public void meet(Bound node) throws UnsupportedRdbmsOperatorException {
+	public void meet(Bound node)
+		throws UnsupportedRdbmsOperatorException
+	{
 		result = not(isNull(new RefIdColumn(node.getArg())));
 	}
 
 	@Override
-	public void meet(Compare compare) throws UnsupportedRdbmsOperatorException {
+	public void meet(Compare compare)
+		throws UnsupportedRdbmsOperatorException
+	{
 		ValueExpr left = compare.getLeftArg();
 		ValueExpr right = compare.getRightArg();
 		CompareOp op = compare.getOperator();
 		switch (op) {
-		case EQ:
-			if (isTerm(left) && isTerm(right)) {
-				result = termsEqual(left, right);
-			} else {
-				result = equal(left, right);
-			}
-			break;
-		case NE:
-			if (isTerm(left) && isTerm(right)) {
-				result = not(termsEqual(left, right));
-			} else {
-				result = not(equal(left, right));
-			}
-			break;
-		case GE:
-		case GT:
-		case LE:
-		case LT:
-			SqlExpr simple = and(simple(type(left)), simple(type(right)));
-			SqlExpr labels = and(cmp(label(left), op, label(right)), simple);
-			SqlExpr time = cmp(time(left), op, time(right));
-			SqlExpr within = cmp(time(left), op, sub(time(right), num(HR14)));
-			SqlExpr comp = or(eq(zoned(left), zoned(right)), within);
-			SqlExpr dateTime = and(eq(type(left), type(right)), and(comp, time));
-			result = or(cmp(numeric(left), op, numeric(right)), or(dateTime, labels));
-			break;
-		}
-	}
-
-	@Override
-	public void meet(IsBNode node) throws UnsupportedRdbmsOperatorException {
+			case EQ:
+				if (isTerm(left) && isTerm(right)) {
+					result = termsEqual(left, right);
+				}
+				else {
+					result = equal(left, right);
+				}
+				break;
+			case NE:
+				if (isTerm(left) && isTerm(right)) {
+					result = not(termsEqual(left, right));
+				}
+				else {
+					result = not(equal(left, right));
+				}
+				break;
+			case GE:
+			case GT:
+			case LE:
+			case LT:
+				SqlExpr simple = and(simple(type(left)), simple(type(right)));
+				SqlExpr labels = and(cmp(label(left), op, label(right)), simple);
+				SqlExpr time = cmp(time(left), op, time(right));
+				SqlExpr within = cmp(time(left), op, sub(time(right), num(HR14)));
+				SqlExpr comp = or(eq(zoned(left), zoned(right)), within);
+				SqlExpr dateTime = and(eq(type(left), type(right)), and(comp, time));
+				result = or(cmp(numeric(left), op, numeric(right)), or(dateTime, labels));
+				break;
+		}
+	}
+
+	@Override
+	public void meet(IsBNode node)
+		throws UnsupportedRdbmsOperatorException
+	{
 		result = isNotNull(sql.createBNodeExpr(node.getArg()));
 	}
 
 	@Override
-	public void meet(IsLiteral node) throws UnsupportedRdbmsOperatorException {
+	public void meet(IsLiteral node)
+		throws UnsupportedRdbmsOperatorException
+	{
 		result = isNotNull(sql.createLabelExpr(node.getArg()));
 	}
 
 	@Override
-	public void meet(IsResource node) throws UnsupportedRdbmsOperatorException {
+	public void meet(IsResource node)
+		throws UnsupportedRdbmsOperatorException
+	{
 		SqlExpr isBNode = isNotNull(sql.createBNodeExpr(node.getArg()));
 		result = or(isBNode, isNotNull(sql.createUriExpr(node.getArg())));
 	}
 
 	@Override
-	public void meet(IsURI node) throws UnsupportedRdbmsOperatorException {
+	public void meet(IsURI node)
+		throws UnsupportedRdbmsOperatorException
+	{
 		result = isNotNull(sql.createUriExpr(node.getArg()));
 	}
 
 	@Override
-	public void meet(LangMatches node) throws UnsupportedRdbmsOperatorException {
+	public void meet(LangMatches node)
+		throws UnsupportedRdbmsOperatorException
+	{
 		ValueExpr left = node.getLeftArg();
 		ValueExpr right = node.getRightArg();
 		SqlCase sqlCase = new SqlCase();
 		sqlCase.when(eq(label(right), str("*")), neq(label(left), str("")));
 		SqlExpr pattern = concat(lowercase(label(right)), str("%"));
 		sqlCase.when(new TrueValue(), like(label(left), pattern));
 		result = sqlCase;
 	}
 
 	@Override
-	public void meet(Not node) throws UnsupportedRdbmsOperatorException {
+	public void meet(Not node)
+		throws UnsupportedRdbmsOperatorException
+	{
 		result = not(bool(node.getArg()));
 	}
 
 	@Override
-	public void meet(Or node) throws UnsupportedRdbmsOperatorException {
+	public void meet(Or node)
+		throws UnsupportedRdbmsOperatorException
+	{
 		result = or(bool(node.getLeftArg()), bool(node.getRightArg()));
 	}
 
 	@Override
-	public void meet(Regex node) throws UnsupportedRdbmsOperatorException {
-		result = regex(label(node.getArg()), label(node.getPatternArg()),
-				label(node.getFlagsArg()));
-	}
-
-	@Override
-	public void meet(SameTerm node) throws UnsupportedRdbmsOperatorException {
+	public void meet(Regex node)
+		throws UnsupportedRdbmsOperatorException
+	{
+		result = regex(label(node.getArg()), label(node.getPatternArg()), label(node.getFlagsArg()));
+	}
+
+	@Override
+	public void meet(SameTerm node)
+		throws UnsupportedRdbmsOperatorException
+	{
 		ValueExpr left = node.getLeftArg();
 		ValueExpr right = node.getRightArg();
 		boolean leftIsVar = left instanceof Var;
 		boolean rightIsVar = right instanceof Var;
 		boolean leftIsConst = left instanceof ValueConstant;
 		boolean rightIsConst = right instanceof ValueConstant;
 		if (leftIsVar && rightIsVar) {
-			result = eq(new RefIdColumn((Var) left), new RefIdColumn((Var) right));
-		} else if ((leftIsVar || leftIsConst) && (rightIsVar || rightIsConst)) {
+			result = eq(new RefIdColumn((Var)left), new RefIdColumn((Var)right));
+		}
+		else if ((leftIsVar || leftIsConst) && (rightIsVar || rightIsConst)) {
 			result = eq(hash(left), hash(right));
-		} else {
+		}
+		else {
 			SqlExpr bnodes = eqComparingNull(bNode(left), bNode(right));
 			SqlExpr uris = eqComparingNull(uri(left), uri(right));
 			SqlExpr langs = eqComparingNull(lang(left), lang(right));
 			SqlExpr datatype = eqComparingNull(type(left), type(right));
 			SqlExpr labels = eqComparingNull(label(left), label(right));
 
 			SqlExpr literals = and(langs, and(datatype, labels));
 			result = and(bnodes, and(uris, literals));
 		}
 	}
 
 	@Override
-	public void meet(ValueConstant vc) throws UnsupportedRdbmsOperatorException {
+	public void meet(ValueConstant vc)
+		throws UnsupportedRdbmsOperatorException
+	{
 		result = valueOf(vc.getValue());
 	}
 
 	@Override
-	public void meet(Var var) throws UnsupportedRdbmsOperatorException {
+	public void meet(Var var)
+		throws UnsupportedRdbmsOperatorException
+	{
 		if (var.getValue() == null) {
 			result = effectiveBooleanValue(var);
-		} else {
+		}
+		else {
 			result = valueOf(var.getValue());
 		}
 	}
 
 	public void setSqlExprFactory(SqlExprFactory sql) {
 		this.sql = sql;
 	}
 
 	protected SqlExpr bNode(ValueExpr arg)
+		throws UnsupportedRdbmsOperatorException
+	{
+		return sql.createBNodeExpr(arg);
+	}
+
+	protected SqlExpr bool(ValueExpr arg)
+		throws UnsupportedRdbmsOperatorException
+	{
+		return sql.createBooleanExpr(arg);
+	}
+
+	protected SqlExpr label(ValueExpr arg)
+		throws UnsupportedRdbmsOperatorException
+	{
+		return sql.createLabelExpr(arg);
+	}
+
+	protected SqlExpr lang(ValueExpr arg)
+		throws UnsupportedRdbmsOperatorException
+	{
+		return sql.createLanguageExpr(arg);
+	}
+
+	protected SqlExpr hash(ValueExpr arg)
+		throws UnsupportedRdbmsOperatorException
+	{
+		return sql.createHashExpr(arg);
+	}
+
+	@Override
+	protected void meetNode(QueryModelNode arg)
+		throws UnsupportedRdbmsOperatorException
+	{
+		if (arg instanceof FunctionCall) {
+			result = functionCall((FunctionCall) arg);	
+		}
+		else if (arg instanceof ValueExpr) {
+			result = effectiveBooleanValue((ValueExpr)arg);
+		}
+		else {
+			throw unsupported(arg);
+		}
+	}
+	
+	protected SqlExpr point(ValueExpr arg)
 			throws UnsupportedRdbmsOperatorException {
-		return sql.createBNodeExpr(arg);
-	}
-
-	protected SqlExpr bool(ValueExpr arg)
-			throws UnsupportedRdbmsOperatorException {
-		return sql.createBooleanExpr(arg);
-	}
-
-	protected SqlExpr label(ValueExpr arg)
-			throws UnsupportedRdbmsOperatorException {
-		return sql.createLabelExpr(arg);
-	}
-
-	protected SqlExpr lang(ValueExpr arg)
-			throws UnsupportedRdbmsOperatorException {
-		return sql.createLanguageExpr(arg);
-	}
-
-	protected SqlExpr hash(ValueExpr arg)
-		throws UnsupportedRdbmsOperatorException
-	{
-		return sql.createHashExpr(arg);
-	}
-
-	@Override
-	protected void meetNode(QueryModelNode arg)
-			throws UnsupportedRdbmsOperatorException {
-		if (arg instanceof ValueExpr) {
-			result = effectiveBooleanValue((ValueExpr) arg);
-		} else {
-			throw unsupported(arg);
-		}
-	}
+		return sql.createPointExpr(arg);
+	}	
 
 	protected SqlExpr numeric(ValueExpr arg)
-			throws UnsupportedRdbmsOperatorException {
+		throws UnsupportedRdbmsOperatorException
+	{
 		return sql.createNumericExpr(arg);
 	}
 
 	protected SqlExpr time(ValueExpr arg)
-			throws UnsupportedRdbmsOperatorException {
+		throws UnsupportedRdbmsOperatorException
+	{
 		return sql.createTimeExpr(arg);
 	}
 
 	protected SqlExpr type(ValueExpr arg)
-			throws UnsupportedRdbmsOperatorException {
+		throws UnsupportedRdbmsOperatorException
+	{
 		return sql.createDatatypeExpr(arg);
 	}
 
-	protected SqlExpr uri(ValueExpr arg) throws UnsupportedRdbmsOperatorException {
+	protected SqlExpr uri(ValueExpr arg)
+		throws UnsupportedRdbmsOperatorException
+	{
 		return sql.createUriExpr(arg);
 	}
 
 	protected SqlExpr zoned(ValueExpr arg)
-			throws UnsupportedRdbmsOperatorException {
+		throws UnsupportedRdbmsOperatorException
+	{
 		return sql.createZonedExpr(arg);
 	}
 
 	private SqlExpr effectiveBooleanValue(ValueExpr v)
-			throws UnsupportedRdbmsOperatorException {
+		throws UnsupportedRdbmsOperatorException
+	{
 		String bool = XMLSchema.BOOLEAN.stringValue();
 		SqlCase sqlCase = new SqlCase();
 		sqlCase.when(eq(type(v), str(bool)), eq(label(v), str("true")));
 		sqlCase.when(simple(type(v)), not(eq(label(v), str(""))));
 		sqlCase.when(isNotNull(numeric(v)), not(eq(numeric(v), num(0))));
 		return sqlCase;
 	}
 
 	private SqlExpr equal(ValueExpr left, ValueExpr right)
-			throws UnsupportedRdbmsOperatorException {
+		throws UnsupportedRdbmsOperatorException
+	{
 		SqlExpr bnodes = eq(bNode(left), bNode(right));
 		SqlExpr uris = eq(uri(left), uri(right));
 		SqlCase scase = new SqlCase();
 		scase.when(or(isNotNull(bNode(left)), isNotNull(bNode(right))), bnodes);
 		scase.when(or(isNotNull(uri(left)), isNotNull(uri(right))), uris);
 		return literalEqual(left, right, scase);
 	}
 
 	private boolean isTerm(ValueExpr node) {
 		return node instanceof Var || node instanceof ValueConstant;
 	}
 
 	private SqlExpr literalEqual(ValueExpr left, ValueExpr right, SqlCase scase)
-			throws UnsupportedRdbmsOperatorException {
+		throws UnsupportedRdbmsOperatorException
+	{
 		// TODO What about xsd:booleans?
 		SqlExpr labels = eq(label(left), label(right));
 		SqlExpr langs = and(eqIfNotNull(lang(left), lang(right)), labels.clone());
 		SqlExpr numeric = eq(numeric(left), numeric(right));
 		SqlExpr time = eq(time(left), time(right));
 
 		SqlExpr bothCalendar = and(isNotNull(time(left)), isNotNull(time(right)));
 		SqlExpr over14 = gt(abs(sub(time(left), time(right))), num(HR14 / 2));
 		SqlExpr comparable = and(bothCalendar, or(eq(zoned(left), zoned(right)), over14));
 
 		scase.when(or(isNotNull(lang(left)), isNotNull(lang(right))), langs);
 		scase.when(and(simple(type(left)), simple(type(right))), labels.clone());
 		scase.when(and(isNotNull(numeric(left)), isNotNull(numeric(right))), numeric);
 		scase.when(comparable, time);
 		scase.when(and(eq(type(left), type(right)), labels.clone()), new TrueValue());
 		return scase;
 	}
 
 	private SqlExpr termsEqual(ValueExpr left, ValueExpr right)
-			throws UnsupportedRdbmsOperatorException {
+		throws UnsupportedRdbmsOperatorException
+	{
 		SqlExpr bnodes = eqIfNotNull(bNode(left), bNode(right));
 		SqlExpr uris = eqIfNotNull(uri(left), uri(right));
 		SqlCase scase = new SqlCase();
 		scase.when(or(isNotNull(bNode(left)), isNotNull(bNode(right))), bnodes);
 		scase.when(or(isNotNull(uri(left)), isNotNull(uri(right))), uris);
 		return literalEqual(left, right, scase);
 	}
 
 	private SqlExpr valueOf(Value value) {
 		if (value instanceof Literal) {
-			if (((Literal) value).booleanValue()) {
+			if (((Literal)value).booleanValue()) {
 				return new TrueValue();
 			}
 			return new FalseValue();
 		}
 		return sqlNull();
 	}
+	
+	private SqlExpr functionCall(FunctionCall functionCall) throws UnsupportedRdbmsOperatorException {
+		if (functionCall.getURI().equals("http://beckr.org#boxContains")) {
+			return boxContains(functionCall);
+		}
+		else {
+			throw unsupported(functionCall);
+		}
+	}
+
+	private SqlExpr boxContains(FunctionCall functionCall) throws UnsupportedRdbmsOperatorException {
+		List<ValueExpr> args = functionCall.getArgs();
+		if (!(args.size() >= 3 && args.get(0) instanceof ValueConstant && args.get(1) instanceof ValueConstant && args.get(2) instanceof Var))
+			throw unsupported(functionCall);
+		
+		/*ValueConstant sw = (ValueConstant) args.get(0);
+		ValueConstant ne = (ValueConstant) args.get(1);
+		Var point = (Var) args.get(2);*/
+		
+		SqlMbrContains sqlMbrContains = new SqlMbrContains((StringValue)point(args.get(0)), (StringValue)point(args.get(1)), point(args.get(2)));
+		return sqlMbrContains;
+	}
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/factories/LabelExprFactory.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/factories/LabelExprFactory.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/factories/LabelExprFactory.java (revision 85)
@@ -1,121 +1,140 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.algebra.factories;
 
 import static org.openrdf.sail.rdbms.algebra.base.SqlExprSupport.coalesce;
 import static org.openrdf.sail.rdbms.algebra.base.SqlExprSupport.isNotNull;
 import static org.openrdf.sail.rdbms.algebra.base.SqlExprSupport.sqlNull;
 import static org.openrdf.sail.rdbms.algebra.base.SqlExprSupport.str;
+import static org.openrdf.sail.rdbms.algebra.base.SqlExprSupport.text;
 import static org.openrdf.sail.rdbms.algebra.base.SqlExprSupport.unsupported;
 
 import org.openrdf.model.Literal;
 import org.openrdf.model.Value;
 import org.openrdf.query.algebra.Datatype;
 import org.openrdf.query.algebra.Lang;
 import org.openrdf.query.algebra.MathExpr;
 import org.openrdf.query.algebra.QueryModelNode;
 import org.openrdf.query.algebra.Str;
 import org.openrdf.query.algebra.ValueConstant;
 import org.openrdf.query.algebra.ValueExpr;
 import org.openrdf.query.algebra.Var;
 import org.openrdf.query.algebra.helpers.QueryModelVisitorBase;
 import org.openrdf.sail.rdbms.algebra.LabelColumn;
 import org.openrdf.sail.rdbms.algebra.LongLabelColumn;
 import org.openrdf.sail.rdbms.algebra.SqlCase;
 import org.openrdf.sail.rdbms.algebra.SqlNull;
 import org.openrdf.sail.rdbms.algebra.base.SqlExpr;
 import org.openrdf.sail.rdbms.exceptions.UnsupportedRdbmsOperatorException;
 
 /**
  * Creates a SQl expression of a literal label.
  * 
  * @author James Leigh
  * 
  */
-public class LabelExprFactory extends
-		QueryModelVisitorBase<UnsupportedRdbmsOperatorException> {
+public class LabelExprFactory extends QueryModelVisitorBase<UnsupportedRdbmsOperatorException> {
+
 	protected SqlExpr result;
 	private SqlExprFactory sql;
 
 	public void setSqlExprFactory(SqlExprFactory sql) {
 		this.sql = sql;
 	}
 
 	public SqlExpr createLabelExpr(ValueExpr expr)
-			throws UnsupportedRdbmsOperatorException {
+		throws UnsupportedRdbmsOperatorException
+	{
 		result = null;
 		if (expr == null)
 			return new SqlNull();
 		expr.visit(this);
 		if (result == null)
 			return new SqlNull();
 		return result;
 	}
 
 	@Override
-	public void meet(Datatype node) throws UnsupportedRdbmsOperatorException {
+	public void meet(Datatype node)
+		throws UnsupportedRdbmsOperatorException
+	{
 		result = sqlNull();
 	}
 
 	@Override
-	public void meet(Lang node) throws UnsupportedRdbmsOperatorException {
+	public void meet(Lang node)
+		throws UnsupportedRdbmsOperatorException
+	{
 		SqlCase sqlCase = new SqlCase();
 		sqlCase.when(isNotNull(lang(node.getArg())), lang(node.getArg()));
 		sqlCase.when(isNotNull(createLabelExpr(node.getArg())), str(""));
 		result = sqlCase;
 	}
 
 	@Override
-	public void meet(MathExpr node) throws UnsupportedRdbmsOperatorException {
-		result = num(node);
+	public void meet(MathExpr node)
+		throws UnsupportedRdbmsOperatorException
+	{
+		result = text(num(node));
 	}
 
 	@Override
-	public void meet(Str str) throws UnsupportedRdbmsOperatorException {
+	public void meet(Str str)
+		throws UnsupportedRdbmsOperatorException
+	{
 		ValueExpr arg = str.getArg();
 		result = coalesce(uri(arg), createLabelExpr(arg));
 	}
 
 	@Override
 	public void meet(ValueConstant vc) {
 		result = valueOf(vc.getValue());
 	}
 
 	@Override
 	public void meet(Var var) {
 		if (var.getValue() == null) {
 			result = coalesce(new LabelColumn(var), new LongLabelColumn(var));
-		} else {
+		}
+		else {
 			result = valueOf(var.getValue());
 		}
 	}
 
 	@Override
 	protected void meetNode(QueryModelNode arg)
-			throws UnsupportedRdbmsOperatorException {
+		throws UnsupportedRdbmsOperatorException
+	{
 		throw unsupported(arg);
 	}
 
-	private SqlExpr lang(ValueExpr arg) throws UnsupportedRdbmsOperatorException {
+	private SqlExpr lang(ValueExpr arg)
+		throws UnsupportedRdbmsOperatorException
+	{
 		return sql.createLanguageExpr(arg);
 	}
 
-	private SqlExpr uri(ValueExpr arg) throws UnsupportedRdbmsOperatorException {
+	private SqlExpr uri(ValueExpr arg)
+		throws UnsupportedRdbmsOperatorException
+	{
 		return sql.createUriExpr(arg);
 	}
 
-	private SqlExpr num(ValueExpr arg) throws UnsupportedRdbmsOperatorException {
+	private SqlExpr num(ValueExpr arg)
+		throws UnsupportedRdbmsOperatorException
+	{
 		return sql.createNumericExpr(arg);
 	}
 
 	private SqlExpr valueOf(Value value) {
 		if (value instanceof Literal) {
-			return str(((Literal) value).getLabel());
+			return str(((Literal)value).getLabel());
 		}
 		return sqlNull();
 	}
 
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/factories/SqlExprFactory.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/factories/SqlExprFactory.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/factories/SqlExprFactory.java (revision 85)
@@ -1,121 +1,151 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.algebra.factories;
 
 import org.openrdf.query.algebra.ValueExpr;
 import org.openrdf.sail.rdbms.algebra.base.SqlExpr;
 import org.openrdf.sail.rdbms.exceptions.UnsupportedRdbmsOperatorException;
 
 /**
  * Boolean SQL expression factory. This factory can convert a number of core
  * algebra nodes into an SQL expression.
  * 
  * @author James Leigh
  * 
  */
 public class SqlExprFactory {
 	private BNodeExprFactory bnode;
 	private BooleanExprFactory bool;
 	private DatatypeExprFactory datatype;
 	private LabelExprFactory label;
 	private LanguageExprFactory language;
 	private NumericExprFactory numeric;
 	private TimeExprFactory time;
 	private URIExprFactory uri;
 	private ZonedExprFactory zoned;
 	private HashExprFactory hash;
+	private PointExprFactory point;
 
 	public void setBNodeExprFactory(BNodeExprFactory bnode) {
 		this.bnode = bnode;
 	}
 
 	public void setBooleanExprFactory(BooleanExprFactory bool) {
 		this.bool = bool;
 	}
 
 	public void setDatatypeExprFactory(DatatypeExprFactory datatype) {
 		this.datatype = datatype;
 	}
 
 	public void setLabelExprFactory(LabelExprFactory label) {
 		this.label = label;
 	}
 
 	public void setLanguageExprFactory(LanguageExprFactory language) {
 		this.language = language;
 	}
 
 	public void setNumericExprFactory(NumericExprFactory numeric) {
 		this.numeric = numeric;
 	}
 
 	public void setTimeExprFactory(TimeExprFactory time) {
 		this.time = time;
 	}
 
 	public void setURIExprFactory(URIExprFactory uri) {
 		this.uri = uri;
 	}
 
 	public void setZonedExprFactory(ZonedExprFactory zoned) {
 		this.zoned = zoned;
 	}
 
 	public void setHashExprFactory(HashExprFactory hash) {
 		this.hash = hash;
 	}
+	
+	public void setPointExprFactory(PointExprFactory point) {
+		this.point = point;
+	}	
 
 	public SqlExpr createBNodeExpr(ValueExpr arg)
-			throws UnsupportedRdbmsOperatorException {
+		throws UnsupportedRdbmsOperatorException
+	{
 		return bnode.createBNodeExpr(arg);
 	}
 
 	public SqlExpr createBooleanExpr(ValueExpr arg)
-			throws UnsupportedRdbmsOperatorException {
+		throws UnsupportedRdbmsOperatorException
+	{
 		return bool.createBooleanExpr(arg);
 	}
 
 	public SqlExpr createLabelExpr(ValueExpr arg)
-			throws UnsupportedRdbmsOperatorException {
+		throws UnsupportedRdbmsOperatorException
+	{
 		return label.createLabelExpr(arg);
 	}
 
 	public SqlExpr createLanguageExpr(ValueExpr arg)
-			throws UnsupportedRdbmsOperatorException {
+		throws UnsupportedRdbmsOperatorException
+	{
 		return language.createLanguageExpr(arg);
 	}
 
 	public SqlExpr createNumericExpr(ValueExpr arg)
-			throws UnsupportedRdbmsOperatorException {
+		throws UnsupportedRdbmsOperatorException
+	{
 		return numeric.createNumericExpr(arg);
 	}
 
 	public SqlExpr createTimeExpr(ValueExpr arg)
-			throws UnsupportedRdbmsOperatorException {
+		throws UnsupportedRdbmsOperatorException
+	{
 		return time.createTimeExpr(arg);
 	}
 
 	public SqlExpr createZonedExpr(ValueExpr arg)
-			throws UnsupportedRdbmsOperatorException {
+		throws UnsupportedRdbmsOperatorException
+	{
 		return zoned.createZonedExpr(arg);
 	}
 
 	public SqlExpr createDatatypeExpr(ValueExpr arg)
-			throws UnsupportedRdbmsOperatorException {
+		throws UnsupportedRdbmsOperatorException
+	{
 		return datatype.createDatatypeExpr(arg);
 	}
 
 	public SqlExpr createUriExpr(ValueExpr arg)
-			throws UnsupportedRdbmsOperatorException {
+		throws UnsupportedRdbmsOperatorException
+	{
 		return uri.createUriExpr(arg);
 	}
 
 	public SqlExpr createHashExpr(ValueExpr arg)
 		throws UnsupportedRdbmsOperatorException
 	{
 		return hash.createHashExpr(arg);
 	}
+	
+	public SqlExpr createPointExpr(ValueExpr arg)
+	throws UnsupportedRdbmsOperatorException
+	{
+		return point.createPointExpr(arg);
+	}	
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/factories/URIExprFactory.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/factories/URIExprFactory.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/factories/URIExprFactory.java (revision 85)
@@ -1,126 +1,140 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.algebra.factories;
 
 import static org.openrdf.sail.rdbms.algebra.base.SqlExprSupport.and;
 import static org.openrdf.sail.rdbms.algebra.base.SqlExprSupport.coalesce;
 import static org.openrdf.sail.rdbms.algebra.base.SqlExprSupport.isNotNull;
 import static org.openrdf.sail.rdbms.algebra.base.SqlExprSupport.isNull;
 import static org.openrdf.sail.rdbms.algebra.base.SqlExprSupport.sqlNull;
 import static org.openrdf.sail.rdbms.algebra.base.SqlExprSupport.str;
 import static org.openrdf.sail.rdbms.algebra.base.SqlExprSupport.unsupported;
 
 import org.openrdf.model.URI;
 import org.openrdf.model.Value;
 import org.openrdf.model.vocabulary.XMLSchema;
 import org.openrdf.query.algebra.Datatype;
 import org.openrdf.query.algebra.Lang;
 import org.openrdf.query.algebra.MathExpr;
 import org.openrdf.query.algebra.QueryModelNode;
 import org.openrdf.query.algebra.Str;
 import org.openrdf.query.algebra.ValueConstant;
 import org.openrdf.query.algebra.ValueExpr;
 import org.openrdf.query.algebra.Var;
 import org.openrdf.query.algebra.helpers.QueryModelVisitorBase;
 import org.openrdf.sail.rdbms.algebra.LongURIColumn;
 import org.openrdf.sail.rdbms.algebra.SqlCase;
 import org.openrdf.sail.rdbms.algebra.SqlNull;
 import org.openrdf.sail.rdbms.algebra.URIColumn;
 import org.openrdf.sail.rdbms.algebra.base.SqlExpr;
 import org.openrdf.sail.rdbms.exceptions.UnsupportedRdbmsOperatorException;
 
 /**
  * Creates an SQL expression for a URI's string value.
  * 
  * @author James Leigh
  * 
  */
-public class URIExprFactory extends
-		QueryModelVisitorBase<UnsupportedRdbmsOperatorException> {
+public class URIExprFactory extends QueryModelVisitorBase<UnsupportedRdbmsOperatorException> {
+
 	protected SqlExpr result;
 	private SqlExprFactory sql;
 
 	public void setSqlExprFactory(SqlExprFactory sql) {
 		this.sql = sql;
 	}
 
 	public SqlExpr createUriExpr(ValueExpr expr)
-			throws UnsupportedRdbmsOperatorException {
+		throws UnsupportedRdbmsOperatorException
+	{
 		result = null;
 		if (expr == null)
 			return new SqlNull();
 		expr.visit(this);
 		if (result == null)
 			return new SqlNull();
 		return result;
 	}
 
 	@Override
-	public void meet(Datatype node) throws UnsupportedRdbmsOperatorException {
+	public void meet(Datatype node)
+		throws UnsupportedRdbmsOperatorException
+	{
 		SqlCase sqlCase = new SqlCase();
 		sqlCase.when(isNotNull(type(node.getArg())), type(node.getArg()));
-		sqlCase.when(and(isNull(lang(node.getArg())), isNotNull(label(node.getArg()))), str(XMLSchema.STRING.stringValue()));
+		sqlCase.when(and(isNull(lang(node.getArg())), isNotNull(label(node.getArg()))),
+				str(XMLSchema.STRING.stringValue()));
 		result = sqlCase;
 	}
 
 	@Override
-	public void meet(Lang node) throws UnsupportedRdbmsOperatorException {
+	public void meet(Lang node)
+		throws UnsupportedRdbmsOperatorException
+	{
 		result = sqlNull();
 	}
 
 	@Override
-	public void meet(MathExpr node) throws UnsupportedRdbmsOperatorException {
+	public void meet(MathExpr node)
+		throws UnsupportedRdbmsOperatorException
+	{
 		result = sqlNull();
 	}
 
 	@Override
 	public void meet(Str node) {
 		result = sqlNull();
 	}
 
 	@Override
 	public void meet(ValueConstant vc) {
 		result = valueOf(vc.getValue());
 	}
 
 	@Override
 	public void meet(Var var) {
 		if (var.getValue() == null) {
 			result = coalesce(new URIColumn(var), new LongURIColumn(var));
-		} else {
+		}
+		else {
 			result = valueOf(var.getValue());
 		}
 	}
 
 	@Override
 	protected void meetNode(QueryModelNode arg)
-			throws UnsupportedRdbmsOperatorException {
+		throws UnsupportedRdbmsOperatorException
+	{
 		throw unsupported(arg);
 	}
 
 	private SqlExpr label(ValueExpr arg)
-			throws UnsupportedRdbmsOperatorException {
+		throws UnsupportedRdbmsOperatorException
+	{
 		return sql.createLabelExpr(arg);
 	}
 
 	private SqlExpr lang(ValueExpr arg)
-			throws UnsupportedRdbmsOperatorException {
+		throws UnsupportedRdbmsOperatorException
+	{
 		return sql.createLanguageExpr(arg);
 	}
 
 	private SqlExpr type(ValueExpr arg)
-			throws UnsupportedRdbmsOperatorException {
+		throws UnsupportedRdbmsOperatorException
+	{
 		return sql.createDatatypeExpr(arg);
 	}
 
 	private SqlExpr valueOf(Value value) {
 		if (value instanceof URI) {
-			return str(((URI) value).stringValue());
+			return str(((URI)value).stringValue());
 		}
 		return sqlNull();
 	}
 
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/factories/ZonedExprFactory.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/factories/ZonedExprFactory.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/factories/ZonedExprFactory.java (revision 85)
@@ -1,103 +1,111 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.algebra.factories;
 
 import static org.openrdf.sail.rdbms.algebra.base.SqlExprSupport.num;
 import static org.openrdf.sail.rdbms.algebra.base.SqlExprSupport.sqlNull;
 import static org.openrdf.sail.rdbms.algebra.base.SqlExprSupport.unsupported;
 
 import org.openrdf.model.Literal;
 import org.openrdf.model.Value;
 import org.openrdf.query.algebra.Datatype;
 import org.openrdf.query.algebra.Lang;
 import org.openrdf.query.algebra.MathExpr;
 import org.openrdf.query.algebra.QueryModelNode;
 import org.openrdf.query.algebra.Str;
 import org.openrdf.query.algebra.ValueConstant;
 import org.openrdf.query.algebra.ValueExpr;
 import org.openrdf.query.algebra.Var;
 import org.openrdf.query.algebra.helpers.QueryModelVisitorBase;
 import org.openrdf.sail.rdbms.algebra.RefIdColumn;
 import org.openrdf.sail.rdbms.algebra.SqlNull;
 import org.openrdf.sail.rdbms.algebra.SqlShift;
 import org.openrdf.sail.rdbms.algebra.base.SqlExpr;
 import org.openrdf.sail.rdbms.exceptions.UnsupportedRdbmsOperatorException;
 import org.openrdf.sail.rdbms.schema.IdSequence;
 
 /**
  * Creates a binary SQL expression for a dateTime zoned value.
  * 
  * @author James Leigh
  * 
  */
-public class ZonedExprFactory extends
-		QueryModelVisitorBase<UnsupportedRdbmsOperatorException> {
+public class ZonedExprFactory extends QueryModelVisitorBase<UnsupportedRdbmsOperatorException> {
+
 	protected SqlExpr result;
 	private IdSequence ids;
 
 	public ZonedExprFactory(IdSequence ids) {
 		super();
 		this.ids = ids;
 	}
 
 	public SqlExpr createZonedExpr(ValueExpr expr)
-			throws UnsupportedRdbmsOperatorException {
+		throws UnsupportedRdbmsOperatorException
+	{
 		result = null;
 		if (expr == null)
 			return new SqlNull();
 		expr.visit(this);
 		if (result == null)
 			return new SqlNull();
 		return result;
 	}
 
 	@Override
 	public void meet(Datatype node) {
 		result = sqlNull();
 	}
 
 	@Override
-	public void meet(Lang node) throws UnsupportedRdbmsOperatorException {
+	public void meet(Lang node)
+		throws UnsupportedRdbmsOperatorException
+	{
 		result = sqlNull();
 	}
 
 	@Override
-	public void meet(MathExpr node) throws UnsupportedRdbmsOperatorException {
+	public void meet(MathExpr node)
+		throws UnsupportedRdbmsOperatorException
+	{
 		result = sqlNull();
 	}
 
 	@Override
 	public void meet(Str node) {
 		result = sqlNull();
 	}
 
 	@Override
 	public void meet(ValueConstant vc) {
 		result = valueOf(vc.getValue());
 	}
 
 	@Override
 	public void meet(Var node) {
 		if (node.getValue() == null) {
 			result = new SqlShift(new RefIdColumn(node), ids.getShift(), ids.getMod());
-		} else {
+		}
+		else {
 			result = valueOf(node.getValue());
 		}
 	}
 
 	@Override
 	protected void meetNode(QueryModelNode arg)
-			throws UnsupportedRdbmsOperatorException {
+		throws UnsupportedRdbmsOperatorException
+	{
 		throw unsupported(arg);
 	}
 
 	private SqlExpr valueOf(Value value) {
 		if (value instanceof Literal) {
-			return num(ids.code((Literal) value));
+			return num(ids.code((Literal)value));
 		}
 		return null;
 	}
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/factories/NumericExprFactory.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/factories/NumericExprFactory.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/factories/NumericExprFactory.java (revision 85)
@@ -1,111 +1,119 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.algebra.factories;
 
 import static org.openrdf.sail.rdbms.algebra.base.SqlExprSupport.sqlNull;
 import static org.openrdf.sail.rdbms.algebra.base.SqlExprSupport.unsupported;
 
 import org.openrdf.model.Literal;
 import org.openrdf.model.URI;
 import org.openrdf.model.Value;
 import org.openrdf.model.datatypes.XMLDatatypeUtil;
 import org.openrdf.query.algebra.Datatype;
 import org.openrdf.query.algebra.Lang;
 import org.openrdf.query.algebra.MathExpr;
 import org.openrdf.query.algebra.QueryModelNode;
 import org.openrdf.query.algebra.Str;
 import org.openrdf.query.algebra.ValueConstant;
 import org.openrdf.query.algebra.ValueExpr;
 import org.openrdf.query.algebra.Var;
 import org.openrdf.query.algebra.MathExpr.MathOp;
 import org.openrdf.query.algebra.helpers.QueryModelVisitorBase;
 import org.openrdf.sail.rdbms.algebra.DoubleValue;
 import org.openrdf.sail.rdbms.algebra.NumericColumn;
 import org.openrdf.sail.rdbms.algebra.SqlMathExpr;
 import org.openrdf.sail.rdbms.algebra.SqlNull;
 import org.openrdf.sail.rdbms.algebra.base.SqlExpr;
 import org.openrdf.sail.rdbms.exceptions.UnsupportedRdbmsOperatorException;
 
 /**
  * Creates an SQL expression of a literal's numeric value.
  * 
  * @author James Leigh
  * 
  */
-public class NumericExprFactory extends
-		QueryModelVisitorBase<UnsupportedRdbmsOperatorException> {
+public class NumericExprFactory extends QueryModelVisitorBase<UnsupportedRdbmsOperatorException> {
+
 	protected SqlExpr result;
 
 	public SqlExpr createNumericExpr(ValueExpr expr)
-			throws UnsupportedRdbmsOperatorException {
+		throws UnsupportedRdbmsOperatorException
+	{
 		result = null;
 		if (expr == null)
 			return new SqlNull();
 		expr.visit(this);
 		if (result == null)
 			return new SqlNull();
 		return result;
 	}
 
 	@Override
 	public void meet(Datatype node) {
 		result = sqlNull();
 	}
 
 	@Override
-	public void meet(Lang node) throws UnsupportedRdbmsOperatorException {
+	public void meet(Lang node)
+		throws UnsupportedRdbmsOperatorException
+	{
 		result = sqlNull();
 	}
 
 	@Override
-	public void meet(MathExpr node) throws UnsupportedRdbmsOperatorException {
+	public void meet(MathExpr node)
+		throws UnsupportedRdbmsOperatorException
+	{
 		SqlExpr left = createNumericExpr(node.getLeftArg());
 		SqlExpr right = createNumericExpr(node.getRightArg());
 		MathOp op = node.getOperator();
 		result = new SqlMathExpr(left, op, right);
 	}
 
 	@Override
 	public void meet(Str node) {
 		result = sqlNull();
 	}
 
 	@Override
 	public void meet(ValueConstant vc) {
 		result = valueOf(vc.getValue());
 	}
 
 	@Override
 	public void meet(Var var) {
 		if (var.getValue() == null) {
 			result = new NumericColumn(var);
-		} else {
+		}
+		else {
 			result = valueOf(var.getValue());
 		}
 	}
 
 	@Override
 	protected void meetNode(QueryModelNode arg)
-			throws UnsupportedRdbmsOperatorException {
+		throws UnsupportedRdbmsOperatorException
+	{
 		throw unsupported(arg);
 	}
 
 	private SqlExpr valueOf(Value value) {
 		if (value instanceof Literal) {
-			Literal lit = (Literal) value;
+			Literal lit = (Literal)value;
 			URI dt = lit.getDatatype();
 			if (dt != null && XMLDatatypeUtil.isNumericDatatype(dt)) {
 				try {
 					return new DoubleValue(lit.doubleValue());
-				} catch (NumberFormatException e) {
+				}
+				catch (NumberFormatException e) {
 					return null;
 				}
 			}
 		}
 		return null;
 	}
 
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/factories/HashExprFactory.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/factories/HashExprFactory.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/factories/HashExprFactory.java (revision 85)
@@ -1,80 +1,83 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.algebra.factories;
 
 import static org.openrdf.sail.rdbms.algebra.base.SqlExprSupport.unsupported;
 
 import org.openrdf.model.Value;
 import org.openrdf.query.algebra.QueryModelNode;
 import org.openrdf.query.algebra.ValueConstant;
 import org.openrdf.query.algebra.ValueExpr;
 import org.openrdf.query.algebra.Var;
 import org.openrdf.query.algebra.helpers.QueryModelVisitorBase;
 import org.openrdf.sail.rdbms.RdbmsValueFactory;
 import org.openrdf.sail.rdbms.algebra.NumberValue;
 import org.openrdf.sail.rdbms.algebra.RefIdColumn;
 import org.openrdf.sail.rdbms.algebra.SqlNull;
 import org.openrdf.sail.rdbms.algebra.base.SqlExpr;
 import org.openrdf.sail.rdbms.exceptions.RdbmsException;
 import org.openrdf.sail.rdbms.exceptions.RdbmsRuntimeException;
 import org.openrdf.sail.rdbms.exceptions.UnsupportedRdbmsOperatorException;
 
 
 /**
  *
  * @author James Leigh
  */
-public class HashExprFactory extends
-		QueryModelVisitorBase<UnsupportedRdbmsOperatorException> {
+public class HashExprFactory extends QueryModelVisitorBase<UnsupportedRdbmsOperatorException> {
+
 	protected SqlExpr result;
 	private RdbmsValueFactory vf;
 
 	public HashExprFactory(RdbmsValueFactory vf) {
 		super();
 		this.vf = vf;
 	}
 
 	public SqlExpr createHashExpr(ValueExpr expr)
-			throws UnsupportedRdbmsOperatorException {
+		throws UnsupportedRdbmsOperatorException
+	{
 		result = null;
 		if (expr == null)
 			return new SqlNull();
 		expr.visit(this);
 		if (result == null)
 			return new SqlNull();
 		return result;
 	}
 
 	@Override
 	public void meet(ValueConstant vc) {
 		result = valueOf(vc.getValue());
 	}
 
 	@Override
 	public void meet(Var var) {
 		if (var.getValue() == null) {
 			result = new RefIdColumn(var);
-		} else {
+		}
+		else {
 			result = valueOf(var.getValue());
 		}
 	}
 
 	@Override
 	protected void meetNode(QueryModelNode arg)
-			throws UnsupportedRdbmsOperatorException {
+		throws UnsupportedRdbmsOperatorException
+	{
 		throw unsupported(arg);
 	}
 
 	public SqlExpr valueOf(Value value) {
 		try {
 			return new NumberValue(vf.getInternalId(value));
 		}
 		catch (RdbmsException e) {
 			throw new RdbmsRuntimeException(e);
 		}
 	}
 
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/factories/LanguageExprFactory.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/factories/LanguageExprFactory.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/factories/LanguageExprFactory.java (revision 85)
@@ -1,97 +1,108 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.algebra.factories;
 
 import static org.openrdf.sail.rdbms.algebra.base.SqlExprSupport.sqlNull;
 import static org.openrdf.sail.rdbms.algebra.base.SqlExprSupport.str;
 import static org.openrdf.sail.rdbms.algebra.base.SqlExprSupport.unsupported;
 
 import org.openrdf.model.Literal;
 import org.openrdf.model.Value;
 import org.openrdf.query.algebra.Datatype;
 import org.openrdf.query.algebra.Lang;
 import org.openrdf.query.algebra.MathExpr;
 import org.openrdf.query.algebra.QueryModelNode;
 import org.openrdf.query.algebra.Str;
 import org.openrdf.query.algebra.ValueConstant;
 import org.openrdf.query.algebra.ValueExpr;
 import org.openrdf.query.algebra.Var;
 import org.openrdf.query.algebra.helpers.QueryModelVisitorBase;
 import org.openrdf.sail.rdbms.algebra.LanguageColumn;
 import org.openrdf.sail.rdbms.algebra.SqlNull;
 import org.openrdf.sail.rdbms.algebra.base.SqlExpr;
 import org.openrdf.sail.rdbms.exceptions.UnsupportedRdbmsOperatorException;
 
 /**
  * Creates an SQL expression of a literal's language.
  * 
  * @author James Leigh
  * 
  */
-public class LanguageExprFactory extends
-		QueryModelVisitorBase<UnsupportedRdbmsOperatorException> {
+public class LanguageExprFactory extends QueryModelVisitorBase<UnsupportedRdbmsOperatorException> {
+
 	protected SqlExpr result;
 
 	public SqlExpr createLanguageExpr(ValueExpr expr)
-			throws UnsupportedRdbmsOperatorException {
+		throws UnsupportedRdbmsOperatorException
+	{
 		result = null;
 		if (expr == null)
 			return new SqlNull();
 		expr.visit(this);
 		if (result == null)
 			return new SqlNull();
 		return result;
 	}
 
 	@Override
-	public void meet(Datatype node) throws UnsupportedRdbmsOperatorException {
+	public void meet(Datatype node)
+		throws UnsupportedRdbmsOperatorException
+	{
 		result = sqlNull();
 	}
 
 	@Override
-	public void meet(Lang node) throws UnsupportedRdbmsOperatorException {
+	public void meet(Lang node)
+		throws UnsupportedRdbmsOperatorException
+	{
 		result = sqlNull();
 	}
 
 	@Override
-	public void meet(MathExpr node) throws UnsupportedRdbmsOperatorException {
+	public void meet(MathExpr node)
+		throws UnsupportedRdbmsOperatorException
+	{
 		result = sqlNull();
 	}
 
 	@Override
-	public void meet(Str node) throws UnsupportedRdbmsOperatorException {
+	public void meet(Str node)
+		throws UnsupportedRdbmsOperatorException
+	{
 		result = sqlNull();
 	}
 
 	@Override
 	public void meet(ValueConstant vc) {
 		result = valueOf(vc.getValue());
 	}
 
 	@Override
 	public void meet(Var var) {
 		if (var.getValue() == null) {
 			result = new LanguageColumn(var);
-		} else {
+		}
+		else {
 			result = valueOf(var.getValue());
 		}
 	}
 
 	@Override
 	protected void meetNode(QueryModelNode arg)
-			throws UnsupportedRdbmsOperatorException {
+		throws UnsupportedRdbmsOperatorException
+	{
 		throw unsupported(arg);
 	}
 
 	private SqlExpr valueOf(Value value) {
 		if (value instanceof Literal) {
-			Literal lit = (Literal) value;
+			Literal lit = (Literal)value;
 			return str(lit.getLanguage());
 		}
 		return sqlNull();
 	}
 
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/factories/BNodeExprFactory.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/factories/BNodeExprFactory.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/factories/BNodeExprFactory.java (revision 85)
@@ -1,96 +1,103 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.algebra.factories;
 
 import static org.openrdf.sail.rdbms.algebra.base.SqlExprSupport.sqlNull;
 import static org.openrdf.sail.rdbms.algebra.base.SqlExprSupport.str;
 import static org.openrdf.sail.rdbms.algebra.base.SqlExprSupport.unsupported;
 
 import org.openrdf.model.BNode;
 import org.openrdf.model.Value;
 import org.openrdf.query.algebra.Datatype;
 import org.openrdf.query.algebra.Lang;
 import org.openrdf.query.algebra.MathExpr;
 import org.openrdf.query.algebra.QueryModelNode;
 import org.openrdf.query.algebra.Str;
 import org.openrdf.query.algebra.ValueConstant;
 import org.openrdf.query.algebra.ValueExpr;
 import org.openrdf.query.algebra.Var;
 import org.openrdf.query.algebra.helpers.QueryModelVisitorBase;
 import org.openrdf.sail.rdbms.algebra.BNodeColumn;
 import org.openrdf.sail.rdbms.algebra.SqlNull;
 import org.openrdf.sail.rdbms.algebra.StringValue;
 import org.openrdf.sail.rdbms.algebra.base.SqlExpr;
 import org.openrdf.sail.rdbms.exceptions.UnsupportedRdbmsOperatorException;
 
 /**
  * BNode expression factory - creates a {@link BNodeColumn} or a
  * {@link StringValue} of the BNode ID.
  * 
  * @author James Leigh
  * 
  */
-public class BNodeExprFactory extends
-		QueryModelVisitorBase<UnsupportedRdbmsOperatorException> {
+public class BNodeExprFactory extends QueryModelVisitorBase<UnsupportedRdbmsOperatorException> {
+
 	protected SqlExpr result;
 
 	public SqlExpr createBNodeExpr(ValueExpr expr)
-			throws UnsupportedRdbmsOperatorException {
+		throws UnsupportedRdbmsOperatorException
+	{
 		result = null;
 		if (expr == null)
 			return new SqlNull();
 		expr.visit(this);
 		if (result == null)
 			return new SqlNull();
 		return result;
 	}
 
 	@Override
 	public void meet(Datatype node) {
 		result = sqlNull();
 	}
 
 	@Override
-	public void meet(Lang node) throws UnsupportedRdbmsOperatorException {
+	public void meet(Lang node)
+		throws UnsupportedRdbmsOperatorException
+	{
 		result = sqlNull();
 	}
 
 	@Override
-	public void meet(MathExpr node) throws UnsupportedRdbmsOperatorException {
+	public void meet(MathExpr node)
+		throws UnsupportedRdbmsOperatorException
+	{
 		result = sqlNull();
 	}
 
 	@Override
 	public void meet(Str node) {
 		result = sqlNull();
 	}
 
 	@Override
 	public void meet(ValueConstant vc) {
 		result = valueOf(vc.getValue());
 	}
 
 	@Override
 	public void meet(Var var) {
 		if (var.getValue() == null) {
 			result = new BNodeColumn(var);
-		} else {
+		}
+		else {
 			result = valueOf(var.getValue());
 		}
 	}
 
 	@Override
 	protected void meetNode(QueryModelNode arg)
-			throws UnsupportedRdbmsOperatorException {
+		throws UnsupportedRdbmsOperatorException
+	{
 		throw unsupported(arg);
 	}
 
 	private SqlExpr valueOf(Value value) {
 		if (value instanceof BNode)
-			return str(((BNode) value).stringValue());
+			return str(((BNode)value).stringValue());
 		return sqlNull();
 	}
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/StringValue.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/StringValue.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/StringValue.java (revision 85)
@@ -1,29 +1,30 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.algebra;
 
 import org.openrdf.sail.rdbms.algebra.base.RdbmsQueryModelVisitorBase;
 import org.openrdf.sail.rdbms.algebra.base.SqlConstant;
 
 /**
  * An SQL VARCHAR expression.
  * 
  * @author James Leigh
  * 
  */
 public class StringValue extends SqlConstant<String> {
 
 	public StringValue(String value) {
 		super(value);
 		assert value != null;
 	}
 
 	@Override
-	public <X extends Exception> void visit(
-			RdbmsQueryModelVisitorBase<X> visitor) throws X {
+	public <X extends Exception> void visit(RdbmsQueryModelVisitorBase<X> visitor)
+		throws X
+	{
 		visitor.meet(this);
 	}
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/SqlLowerCase.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/SqlLowerCase.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/SqlLowerCase.java (revision 85)
@@ -1,29 +1,31 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.algebra;
 
 import org.openrdf.sail.rdbms.algebra.base.RdbmsQueryModelVisitorBase;
 import org.openrdf.sail.rdbms.algebra.base.SqlExpr;
 import org.openrdf.sail.rdbms.algebra.base.UnarySqlOperator;
 
 /**
  * The SQL LOWER function.
  * 
  * @author James Leigh
  * 
  */
 public class SqlLowerCase extends UnarySqlOperator {
 	public SqlLowerCase(SqlExpr arg) {
 		super(arg);
 	}
 
 	@Override
-	public <X extends Exception> void visit(
-			RdbmsQueryModelVisitorBase<X> visitor) throws X {
+	public <X extends Exception> void visit(RdbmsQueryModelVisitorBase<X> visitor)
+		throws X
+	{
 		visitor.meet(this);
 	}
 
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/BNodeColumn.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/BNodeColumn.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/BNodeColumn.java (revision 85)
@@ -1,33 +1,34 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.algebra;
 
 import org.openrdf.query.algebra.Var;
 import org.openrdf.sail.rdbms.algebra.base.RdbmsQueryModelVisitorBase;
 import org.openrdf.sail.rdbms.algebra.base.ValueColumnBase;
 
 /**
  * Represents the BNode value of a variable.
  * 
  * @author James Leigh
  * 
  */
 public class BNodeColumn extends ValueColumnBase {
 
 	public BNodeColumn(ColumnVar var) {
 		super(var);
 	}
 
 	public BNodeColumn(Var var) {
 		super(var);
 	}
 
 	@Override
-	public <X extends Exception> void visit(
-			RdbmsQueryModelVisitorBase<X> visitor) throws X {
+	public <X extends Exception> void visit(RdbmsQueryModelVisitorBase<X> visitor)
+		throws X
+	{
 		visitor.meet(this);
 	}
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/RefIdColumn.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/RefIdColumn.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/RefIdColumn.java (revision 85)
@@ -1,38 +1,39 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.algebra;
 
 import org.openrdf.query.algebra.Var;
 import org.openrdf.sail.rdbms.algebra.base.RdbmsQueryModelVisitorBase;
 import org.openrdf.sail.rdbms.algebra.base.ValueColumnBase;
 
 /**
  * Represents a variable's internal id value in an SQL expression.
  * 
  * @author James Leigh
  * 
  */
 public class RefIdColumn extends ValueColumnBase {
 
 	public RefIdColumn(ColumnVar var) {
 		super(var);
 	}
 
 	public RefIdColumn(Var var) {
 		super(var);
 	}
 
 	@Override
-	public <X extends Exception> void visit(
-			RdbmsQueryModelVisitorBase<X> visitor) throws X {
+	public <X extends Exception> void visit(RdbmsQueryModelVisitorBase<X> visitor)
+		throws X
+	{
 		visitor.meet(this);
 	}
 
 	@Override
 	public RefIdColumn clone() {
-		return (RefIdColumn) super.clone();
+		return (RefIdColumn)super.clone();
 	}
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/UnionItem.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/UnionItem.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/UnionItem.java (revision 85)
@@ -1,154 +1,157 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.algebra;
 
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 
 import org.openrdf.query.algebra.QueryModelNode;
 import org.openrdf.query.algebra.QueryModelVisitor;
 import org.openrdf.sail.rdbms.algebra.base.FromItem;
 import org.openrdf.sail.rdbms.algebra.base.RdbmsQueryModelVisitorBase;
 import org.openrdf.sail.rdbms.schema.ValueTypes;
 
 /**
  * An SQL UNION expression between two {@link FromItem}s.
  * 
  * @author James Leigh
  * 
  */
 public class UnionItem extends FromItem {
 	private List<FromItem> union = new ArrayList<FromItem>();
 
 	public UnionItem(String alias) {
 		super(alias);
 	}
 
 	@Override
 	public FromItem getFromItem(String alias) {
 		for (FromItem from : union) {
 			FromItem item = from.getFromItem(alias);
 			if (item != null)
 				return item;
 		}
 		return super.getFromItem(alias);
 	}
 
 	public List<String> getSelectVarNames() {
 		List<ColumnVar> vars = new ArrayList<ColumnVar>();
 		for (FromItem from : union) {
 			from.appendVars(vars);
 		}
 		List<String> selectVars = new ArrayList<String>();
 		for (ColumnVar var : vars) {
 			if (var.isHidden())
 				continue;
 			if (!selectVars.contains(var.getName())) {
 				selectVars.add(var.getName());
 			}
 		}
 		return selectVars;
 	}
 
 	public List<ColumnVar> getSelectColumns() {
 		List<ColumnVar> vars = new ArrayList<ColumnVar>();
 		for (FromItem from : union) {
 			from.appendVars(vars);
 		}
 		List<ColumnVar> columns = new ArrayList<ColumnVar>();
 		Map<String, ColumnVar> selectVars = new HashMap<String, ColumnVar>();
 		for (ColumnVar var : vars) {
 			if (var.isHidden())
 				continue;
 			if (selectVars.containsKey(var.getName())) {
 				ValueTypes types = selectVars.get(var.getName()).getTypes();
 				types = types.clone().merge(var.getTypes());
 				selectVars.get(var.getName()).setTypes(types);
-			} else {
+			}
+			else {
 				String name = var.getAlias() + var.getColumn();
 				ColumnVar as = var.as(getAlias(), name);
 				columns.add(as);
 				selectVars.put(var.getName(), as);
 			}
 		}
 		return columns;
 	}
 
 	@Override
 	public List<ColumnVar> appendVars(List<ColumnVar> columns) {
 		columns.addAll(getSelectColumns());
 		return super.appendVars(columns);
 	}
 
 	@Override
 	public ColumnVar getVar(String name) {
 		for (ColumnVar var : appendVars(new ArrayList<ColumnVar>())) {
 			if (var.getName().equals(name)) {
 				return var;
 			}
 		}
 		return null;
 	}
 
 	@Override
 	public ColumnVar getVarForChildren(String name) {
 		for (FromItem join : union) {
 			ColumnVar var = join.getVar(name);
 			if (var != null)
 				return var;
 		}
 		return super.getVarForChildren(name);
 	}
 
 	public void addUnion(FromItem from) {
 		union.add(from);
 		from.setParentNode(this);
 	}
 
 	public List<FromItem> getUnion() {
 		return union;
 	}
 
 	@Override
 	public UnionItem clone() {
-		UnionItem clone = (UnionItem) super.clone();
+		UnionItem clone = (UnionItem)super.clone();
 		clone.union = new ArrayList<FromItem>();
 		for (FromItem from : union) {
 			clone.addUnion(from.clone());
 		}
 		return clone;
 	}
 
 	@Override
-	public <X extends Exception> void visit(
-			RdbmsQueryModelVisitorBase<X> visitor) throws X {
+	public <X extends Exception> void visit(RdbmsQueryModelVisitorBase<X> visitor)
+		throws X
+	{
 		visitor.meet(this);
 	}
 
 	@Override
-	public void replaceChildNode(QueryModelNode current,
-			QueryModelNode replacement) {
+	public void replaceChildNode(QueryModelNode current, QueryModelNode replacement) {
 		for (int i = 0, n = union.size(); i < n; i++) {
 			if (current == union.get(i)) {
-				union.set(i, (FromItem) replacement);
+				union.set(i, (FromItem)replacement);
 				return;
 			}
 		}
 		super.replaceChildNode(current, replacement);
 	}
 
 	@Override
 	public <X extends Exception> void visitChildren(QueryModelVisitor<X> visitor)
-			throws X {
+		throws X
+	{
 		super.visitChildren(visitor);
 		for (FromItem join : new ArrayList<FromItem>(union)) {
 			join.visit(visitor);
 		}
 	}
 
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/SqlCast.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/SqlCast.java (revision 85)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/SqlCast.java (revision 85)
@@ -0,0 +1,43 @@
+/*
+ * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
+ *
+ * Licensed under the Aduna BSD-style license.
+ */
+package org.openrdf.sail.rdbms.algebra;
+
+import org.openrdf.sail.rdbms.algebra.base.RdbmsQueryModelVisitorBase;
+import org.openrdf.sail.rdbms.algebra.base.SqlExpr;
+import org.openrdf.sail.rdbms.algebra.base.UnarySqlOperator;
+
+/**
+ * The SQL IS CAST expression.
+ * 
+ * @author James Leigh
+ * 
+ */
+public class SqlCast extends UnarySqlOperator {
+
+	private int type;
+
+	public SqlCast(SqlExpr arg, int type) {
+		super(arg);
+		this.type = type;
+	}
+
+	@Override
+	public <X extends Exception> void visit(RdbmsQueryModelVisitorBase<X> visitor)
+		throws X
+	{
+		visitor.meet(this);
+	}
+
+	public int getType() {
+		return type;
+	}
+
+	@Override
+	public String getSignature() {
+		return super.getSignature() + " AS " + type;
+	}
+
+}
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/DateTimeColumn.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/DateTimeColumn.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/DateTimeColumn.java (revision 85)
@@ -1,29 +1,31 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.algebra;
 
 import org.openrdf.query.algebra.Var;
 import org.openrdf.sail.rdbms.algebra.base.RdbmsQueryModelVisitorBase;
 import org.openrdf.sail.rdbms.algebra.base.ValueColumnBase;
 
 /**
  * Represents a variable's time value in an SQL expression.
+ * 
  * @author James Leigh
  *
  */
 public class DateTimeColumn extends ValueColumnBase {
 
 	public DateTimeColumn(Var var) {
 		super(var);
 	}
 
 	@Override
-	public <X extends Exception> void visit(
-			RdbmsQueryModelVisitorBase<X> visitor) throws X {
+	public <X extends Exception> void visit(RdbmsQueryModelVisitorBase<X> visitor)
+		throws X
+	{
 		visitor.meet(this);
 	}
 
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/SelectProjection.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/SelectProjection.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/SelectProjection.java (revision 85)
@@ -1,164 +1,176 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.algebra;
 
 import org.openrdf.query.algebra.QueryModelNode;
 import org.openrdf.query.algebra.QueryModelVisitor;
 import org.openrdf.sail.rdbms.algebra.base.RdbmsQueryModelNodeBase;
 import org.openrdf.sail.rdbms.algebra.base.RdbmsQueryModelVisitorBase;
 import org.openrdf.sail.rdbms.algebra.base.SqlExpr;
 
 /**
  * A collection of SQL expressions that form an RDF value binding.
  * 
  * @author James Leigh
  * 
  */
 public class SelectProjection extends RdbmsQueryModelNodeBase {
 	private ColumnVar var;
 	private RefIdColumn id;
 	private SqlExpr stringValue;
 	private SqlExpr datatype;
 	private SqlExpr language;
 
 	public ColumnVar getVar() {
 		return var;
 	}
 
 	public void setVar(ColumnVar var) {
 		this.var = var;
 	}
 
 	public RefIdColumn getId() {
 		return id;
 	}
 
 	public void setId(RefIdColumn id) {
 		this.id = id;
 		id.setParentNode(this);
 	}
 
 	public SqlExpr getStringValue() {
 		return stringValue;
 	}
 
 	public void setStringValue(SqlExpr stringValue) {
 		this.stringValue = stringValue;
 		stringValue.setParentNode(this);
 	}
 
 	public SqlExpr getDatatype() {
 		return datatype;
 	}
 
 	public void setDatatype(SqlExpr datatype) {
 		this.datatype = datatype;
 		datatype.setParentNode(this);
 	}
 
 	public SqlExpr getLanguage() {
 		return language;
 	}
 
 	public void setLanguage(SqlExpr language) {
 		this.language = language;
 		language.setParentNode(this);
 	}
 
 	@Override
-	public <X extends Exception> void visit(
-			RdbmsQueryModelVisitorBase<X> visitor) throws X {
+	public <X extends Exception> void visit(RdbmsQueryModelVisitorBase<X> visitor)
+		throws X
+	{
 		visitor.meet(this);
 	}
 
 	@Override
 	public <X extends Exception> void visitChildren(QueryModelVisitor<X> visitor)
-			throws X {
+		throws X
+	{
 		id.visit(visitor);
 		stringValue.visit(visitor);
 		datatype.visit(visitor);
 		language.visit(visitor);
 	}
 
 	@Override
-	public void replaceChildNode(QueryModelNode current,
-			QueryModelNode replacement) {
+	public void replaceChildNode(QueryModelNode current, QueryModelNode replacement) {
 		if (id == current) {
-			setId((RefIdColumn) replacement);
-		} else if (stringValue == current) {
-			setStringValue((SqlExpr) replacement);
-		} else if (datatype == current) {
-			setDatatype((SqlExpr) replacement);
-		} else if (language == current) {
-			setLanguage((SqlExpr) replacement);
-		} else {
+			setId((RefIdColumn)replacement);
+		}
+		else if (stringValue == current) {
+			setStringValue((SqlExpr)replacement);
+		}
+		else if (datatype == current) {
+			setDatatype((SqlExpr)replacement);
+		}
+		else if (language == current) {
+			setLanguage((SqlExpr)replacement);
+		}
+		else {
 			super.replaceChildNode(current, replacement);
 		}
 	}
 
 	@Override
 	public SelectProjection clone() {
-		SelectProjection clone = (SelectProjection) super.clone();
+		SelectProjection clone = (SelectProjection)super.clone();
 		clone.setId(getId().clone());
 		clone.setStringValue(getStringValue().clone());
 		clone.setDatatype(getDatatype().clone());
 		clone.setLanguage(getLanguage().clone());
 		return clone;
 	}
 
 	@Override
 	public int hashCode() {
 		final int prime = 31;
 		int result = 1;
-		result = prime * result
-				+ ((datatype == null) ? 0 : datatype.hashCode());
+		result = prime * result + ((datatype == null) ? 0 : datatype.hashCode());
 		result = prime * result + ((id == null) ? 0 : id.hashCode());
-		result = prime * result
-				+ ((language == null) ? 0 : language.hashCode());
-		result = prime * result
-				+ ((stringValue == null) ? 0 : stringValue.hashCode());
+		result = prime * result + ((language == null) ? 0 : language.hashCode());
+		result = prime * result + ((stringValue == null) ? 0 : stringValue.hashCode());
 		result = prime * result + ((var == null) ? 0 : var.hashCode());
 		return result;
 	}
 
 	@Override
 	public boolean equals(Object obj) {
 		if (this == obj)
 			return true;
 		if (obj == null)
 			return false;
 		if (getClass() != obj.getClass())
 			return false;
-		final SelectProjection other = (SelectProjection) obj;
+		final SelectProjection other = (SelectProjection)obj;
 		if (datatype == null) {
 			if (other.datatype != null)
 				return false;
-		} else if (!datatype.equals(other.datatype))
+		}
+		else if (!datatype.equals(other.datatype))
 			return false;
 		if (id == null) {
 			if (other.id != null)
 				return false;
-		} else if (!id.equals(other.id))
+		}
+		else if (!id.equals(other.id))
 			return false;
 		if (language == null) {
 			if (other.language != null)
 				return false;
-		} else if (!language.equals(other.language))
+		}
+		else if (!language.equals(other.language))
 			return false;
 		if (stringValue == null) {
 			if (other.stringValue != null)
 				return false;
-		} else if (!stringValue.equals(other.stringValue))
+		}
+		else if (!stringValue.equals(other.stringValue))
 			return false;
 		if (var == null) {
 			if (other.var != null)
 				return false;
-		} else if (!var.equals(other.var))
+		}
+		else if (!var.equals(other.var))
 			return false;
 		return true;
 	}
 
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/SqlNot.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/SqlNot.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/SqlNot.java (revision 85)
@@ -1,30 +1,31 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.algebra;
 
 import org.openrdf.sail.rdbms.algebra.base.RdbmsQueryModelVisitorBase;
 import org.openrdf.sail.rdbms.algebra.base.SqlExpr;
 import org.openrdf.sail.rdbms.algebra.base.UnarySqlOperator;
 
 /**
  * The SQL NOT expression.
  * 
  * @author James Leigh
  * 
  */
 public class SqlNot extends UnarySqlOperator {
 
 	public SqlNot(SqlExpr arg) {
 		super(arg);
 	}
 
 	@Override
-	public <X extends Exception> void visit(
-			RdbmsQueryModelVisitorBase<X> visitor) throws X {
+	public <X extends Exception> void visit(RdbmsQueryModelVisitorBase<X> visitor)
+		throws X
+	{
 		visitor.meet(this);
 	}
 
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/NumericColumn.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/NumericColumn.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/NumericColumn.java (revision 85)
@@ -1,30 +1,31 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.algebra;
 
 import org.openrdf.query.algebra.Var;
 import org.openrdf.sail.rdbms.algebra.base.RdbmsQueryModelVisitorBase;
 import org.openrdf.sail.rdbms.algebra.base.ValueColumnBase;
 
 /**
  * Represents a variable's numeric value in an SQL expression.
  * 
  * @author James Leigh
  * 
  */
 public class NumericColumn extends ValueColumnBase {
 
 	public NumericColumn(Var var) {
 		super(var);
 	}
 
 	@Override
-	public <X extends Exception> void visit(
-			RdbmsQueryModelVisitorBase<X> visitor) throws X {
+	public <X extends Exception> void visit(RdbmsQueryModelVisitorBase<X> visitor)
+		throws X
+	{
 		visitor.meet(this);
 	}
 
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/SqlAnd.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/SqlAnd.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/SqlAnd.java (revision 85)
@@ -1,29 +1,30 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.algebra;
 
 import org.openrdf.sail.rdbms.algebra.base.BinarySqlOperator;
 import org.openrdf.sail.rdbms.algebra.base.RdbmsQueryModelVisitorBase;
 import org.openrdf.sail.rdbms.algebra.base.SqlExpr;
 
 /**
  * The SQL AND expression.
  * 
  * @author James Leigh
  * 
  */
 public class SqlAnd extends BinarySqlOperator {
 
 	public SqlAnd(SqlExpr leftArg, SqlExpr rightArg) {
 		super(leftArg, rightArg);
 	}
 
 	@Override
-	public <X extends Exception> void visit(
-			RdbmsQueryModelVisitorBase<X> visitor) throws X {
+	public <X extends Exception> void visit(RdbmsQueryModelVisitorBase<X> visitor)
+		throws X
+	{
 		visitor.meet(this);
 	}
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/NumberValue.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/NumberValue.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/NumberValue.java (revision 85)
@@ -1,28 +1,29 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.algebra;
 
 import org.openrdf.sail.rdbms.algebra.base.RdbmsQueryModelVisitorBase;
 import org.openrdf.sail.rdbms.algebra.base.SqlConstant;
 
 /**
  * A static long value in an SQL expression.
  * 
  * @author James Leigh
  * 
  */
 public class NumberValue extends SqlConstant<Number> {
 
 	public NumberValue(Number value) {
 		super(value);
 	}
 
 	@Override
-	public <X extends Exception> void visit(
-			RdbmsQueryModelVisitorBase<X> visitor) throws X {
+	public <X extends Exception> void visit(RdbmsQueryModelVisitorBase<X> visitor)
+		throws X
+	{
 		visitor.meet(this);
 	}
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/FalseValue.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/FalseValue.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/FalseValue.java (revision 85)
@@ -1,28 +1,29 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.algebra;
 
 import org.openrdf.sail.rdbms.algebra.base.BooleanValue;
 import org.openrdf.sail.rdbms.algebra.base.RdbmsQueryModelVisitorBase;
 
 /**
  * Represents the value false in an SQL expression.
  * 
  * @author James Leigh
  * 
  */
 public class FalseValue extends BooleanValue {
 
 	public FalseValue() {
 		super(false);
 	}
 
 	@Override
-	public <X extends Exception> void visit(
-			RdbmsQueryModelVisitorBase<X> visitor) throws X {
+	public <X extends Exception> void visit(RdbmsQueryModelVisitorBase<X> visitor)
+		throws X
+	{
 		visitor.meet(this);
 	}
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/SqlNull.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/SqlNull.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/SqlNull.java (revision 85)
@@ -1,28 +1,29 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.algebra;
 
 import org.openrdf.sail.rdbms.algebra.base.RdbmsQueryModelVisitorBase;
 import org.openrdf.sail.rdbms.algebra.base.SqlConstant;
 
 /**
  * The SQL NULL expression.
  * 
  * @author James Leigh
  * 
  */
 public class SqlNull extends SqlConstant<Object> {
 
 	public SqlNull() {
 		super(null);
 	}
 
 	@Override
-	public <X extends Exception> void visit(
-			RdbmsQueryModelVisitorBase<X> visitor) throws X {
+	public <X extends Exception> void visit(RdbmsQueryModelVisitorBase<X> visitor)
+		throws X
+	{
 		visitor.meet(this);
 	}
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/SqlCase.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/SqlCase.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/SqlCase.java (revision 85)
@@ -1,171 +1,177 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.algebra;
 
 import java.util.ArrayList;
 import java.util.List;
 
 import org.openrdf.query.algebra.QueryModelNode;
 import org.openrdf.query.algebra.QueryModelVisitor;
 import org.openrdf.sail.rdbms.algebra.base.RdbmsQueryModelNodeBase;
 import org.openrdf.sail.rdbms.algebra.base.RdbmsQueryModelVisitorBase;
 import org.openrdf.sail.rdbms.algebra.base.SqlExpr;
 
 /**
  * The SQL CASE WHEN THEN END expression.
  * 
  * @author James Leigh
  * 
  */
 public class SqlCase extends RdbmsQueryModelNodeBase implements SqlExpr {
 	private List<Entry> entries = new ArrayList<Entry>();
 
 	public class Entry {
 		private SqlExpr condition;
 		private SqlExpr result;
 
 		public Entry(SqlExpr condition, SqlExpr result) {
 			super();
 			this.condition = condition;
 			this.result = result;
 		}
 
 		public SqlExpr getCondition() {
 			return condition;
 		}
 
 		public void setCondition(SqlExpr condition) {
 			this.condition = condition;
 			condition.setParentNode(SqlCase.this);
 		}
 
 		public SqlExpr getResult() {
 			return result;
 		}
 
 		public void setResult(SqlExpr result) {
 			this.result = result;
 			result.setParentNode(SqlCase.this);
 		}
 
 		@Override
 		public int hashCode() {
 			final int prime = 31;
 			int result = 1;
-			result = prime * result
-					+ ((condition == null) ? 0 : condition.hashCode());
-			result = prime * result
-					+ ((this.result == null) ? 0 : this.result.hashCode());
+			result = prime * result + ((condition == null) ? 0 : condition.hashCode());
+			result = prime * result + ((this.result == null) ? 0 : this.result.hashCode());
 			return result;
 		}
 
 		@Override
 		public boolean equals(Object obj) {
 			if (this == obj)
 				return true;
 			if (obj == null)
 				return false;
 			if (getClass() != obj.getClass())
 				return false;
-			final Entry other = (Entry) obj;
+			final Entry other = (Entry)obj;
 			if (condition == null) {
 				if (other.condition != null)
 					return false;
-			} else if (!condition.equals(other.condition))
+			}
+			else if (!condition.equals(other.condition))
 				return false;
 			if (result == null) {
 				if (other.result != null)
 					return false;
-			} else if (!result.equals(other.result))
+			}
+			else if (!result.equals(other.result))
 				return false;
 			return true;
 		}
 	}
 
 	public void when(SqlExpr condition, SqlExpr expr) {
 		entries.add(new Entry(condition, expr));
 		condition.setParentNode(this);
 		expr.setParentNode(this);
 	}
 
 	public List<Entry> getEntries() {
 		return new ArrayList<Entry>(entries);
 	}
 
 	@Override
 	public <X extends Exception> void visitChildren(QueryModelVisitor<X> visitor)
-			throws X {
+		throws X
+	{
 		for (Entry e : entries) {
 			e.getCondition().visit(visitor);
 			e.getResult().visit(visitor);
 		}
 	}
 
 	@Override
-	public void replaceChildNode(QueryModelNode current,
-			QueryModelNode replacement) {
+	public void replaceChildNode(QueryModelNode current, QueryModelNode replacement) {
 		for (Entry e : entries) {
 			if (e.getCondition() == current) {
-				e.setCondition((SqlExpr) replacement);
-			} else if (e.getResult() == current) {
-				e.setResult((SqlExpr) replacement);
+				e.setCondition((SqlExpr)replacement);
+			}
+			else if (e.getResult() == current) {
+				e.setResult((SqlExpr)replacement);
 			}
 		}
 	}
 
 	@Override
 	public SqlCase clone() {
-		SqlCase clone = (SqlCase) super.clone();
+		SqlCase clone = (SqlCase)super.clone();
 		clone.entries = new ArrayList<Entry>();
 		for (Entry e : entries) {
 			clone.when(e.getCondition().clone(), e.getResult().clone());
 		}
 		return clone;
 	}
 
 	@Override
-	public <X extends Exception> void visit(
-			RdbmsQueryModelVisitorBase<X> visitor) throws X {
+	public <X extends Exception> void visit(RdbmsQueryModelVisitorBase<X> visitor)
+		throws X
+	{
 		visitor.meet(this);
 	}
 
 	public void removeEntry(Entry e) {
 		entries.remove(e);
 	}
 
 	public void truncateEntries(Entry e) {
 		int idx = entries.indexOf(e) + 1;
 		if (idx < entries.size()) {
 			entries = entries.subList(0, idx);
 		}
 	}
 
 	@Override
 	public int hashCode() {
 		final int prime = 31;
 		int result = 1;
 		result = prime * result + ((entries == null) ? 0 : entries.hashCode());
 		return result;
 	}
 
 	@Override
 	public boolean equals(Object obj) {
 		if (this == obj)
 			return true;
 		if (obj == null)
 			return false;
 		if (getClass() != obj.getClass())
 			return false;
-		final SqlCase other = (SqlCase) obj;
+		final SqlCase other = (SqlCase)obj;
 		if (entries == null) {
 			if (other.entries != null)
 				return false;
-		} else if (!entries.equals(other.entries))
+		}
+		else if (!entries.equals(other.entries))
 			return false;
 		return true;
 	}
 
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/LabelColumn.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/LabelColumn.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/LabelColumn.java (revision 85)
@@ -1,34 +1,35 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.algebra;
 
 import org.openrdf.query.algebra.Var;
 import org.openrdf.sail.rdbms.algebra.base.RdbmsQueryModelVisitorBase;
 import org.openrdf.sail.rdbms.algebra.base.ValueColumnBase;
 
 /**
  * Represents a variable's label value in an SQL expression.
  * 
  * @author James Leigh
  * 
  */
 public class LabelColumn extends ValueColumnBase {
 
 	public LabelColumn(Var var) {
 		super(var);
 	}
 
 	public LabelColumn(ColumnVar var) {
 		super(var);
 	}
 
 	@Override
-	public <X extends Exception> void visit(
-			RdbmsQueryModelVisitorBase<X> visitor) throws X {
+	public <X extends Exception> void visit(RdbmsQueryModelVisitorBase<X> visitor)
+		throws X
+	{
 		visitor.meet(this);
 	}
 
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/SqlShift.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/SqlShift.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/SqlShift.java (revision 85)
@@ -1,42 +1,45 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.algebra;
 
 import org.openrdf.sail.rdbms.algebra.base.RdbmsQueryModelVisitorBase;
 import org.openrdf.sail.rdbms.algebra.base.SqlExpr;
 import org.openrdf.sail.rdbms.algebra.base.UnarySqlOperator;
 
 /**
  * The SQL binary shift right (>>) expression.
  * 
  * @author James Leigh
  * 
  */
 public class SqlShift extends UnarySqlOperator {
 	private int shift;
 	private int range;
 
 	public SqlShift(SqlExpr arg, int shift, int range) {
 		super(arg);
 		this.shift = shift;
 		this.range = range;
 	}
 
 	public int getRightShift() {
 		return shift;
 	}
 
 	public int getRange() {
 		return range;
 	}
 
 	@Override
-	public <X extends Exception> void visit(
-			RdbmsQueryModelVisitorBase<X> visitor) throws X {
+	public <X extends Exception> void visit(RdbmsQueryModelVisitorBase<X> visitor)
+		throws X
+	{
 		visitor.meet(this);
 	}
 
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/SqlOr.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/SqlOr.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/SqlOr.java (revision 85)
@@ -1,29 +1,30 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.algebra;
 
 import org.openrdf.sail.rdbms.algebra.base.BinarySqlOperator;
 import org.openrdf.sail.rdbms.algebra.base.RdbmsQueryModelVisitorBase;
 import org.openrdf.sail.rdbms.algebra.base.SqlExpr;
 
 /**
  * The SQL OR expression.
  * 
  * @author James Leigh
  * 
  */
 public class SqlOr extends BinarySqlOperator {
 
 	public SqlOr(SqlExpr leftArg, SqlExpr rightArg) {
 		super(leftArg, rightArg);
 	}
 
 	@Override
-	public <X extends Exception> void visit(
-			RdbmsQueryModelVisitorBase<X> visitor) throws X {
+	public <X extends Exception> void visit(RdbmsQueryModelVisitorBase<X> visitor)
+		throws X
+	{
 		visitor.meet(this);
 	}
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/HashColumn.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/HashColumn.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/HashColumn.java (revision 85)
@@ -1,33 +1,34 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.algebra;
 
 import org.openrdf.query.algebra.Var;
 import org.openrdf.sail.rdbms.algebra.base.RdbmsQueryModelVisitorBase;
 import org.openrdf.sail.rdbms.algebra.base.ValueColumnBase;
 
 /**
  * Represents the Hash value of a variable.
  * 
  * @author James Leigh
  * 
  */
 public class HashColumn extends ValueColumnBase {
 
 	public HashColumn(ColumnVar var) {
 		super(var);
 	}
 
 	public HashColumn(Var var) {
 		super(var);
 	}
 
 	@Override
-	public <X extends Exception> void visit(
-			RdbmsQueryModelVisitorBase<X> visitor) throws X {
+	public <X extends Exception> void visit(RdbmsQueryModelVisitorBase<X> visitor)
+		throws X
+	{
 		visitor.meet(this);
 	}
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/LanguageColumn.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/LanguageColumn.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/LanguageColumn.java (revision 85)
@@ -1,34 +1,35 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.algebra;
 
 import org.openrdf.query.algebra.Var;
 import org.openrdf.sail.rdbms.algebra.base.RdbmsQueryModelVisitorBase;
 import org.openrdf.sail.rdbms.algebra.base.ValueColumnBase;
 
 /**
  * Represents a variables language value in an SQL expression.
  * 
  * @author James Leigh
  * 
  */
 public class LanguageColumn extends ValueColumnBase {
 
 	public LanguageColumn(Var var) {
 		super(var);
 	}
 
 	public LanguageColumn(ColumnVar var) {
 		super(var);
 	}
 
 	@Override
-	public <X extends Exception> void visit(
-			RdbmsQueryModelVisitorBase<X> visitor) throws X {
+	public <X extends Exception> void visit(RdbmsQueryModelVisitorBase<X> visitor)
+		throws X
+	{
 		visitor.meet(this);
 	}
 
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/SqlLike.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/SqlLike.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/SqlLike.java (revision 85)
@@ -1,29 +1,31 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.algebra;
 
 import org.openrdf.sail.rdbms.algebra.base.BinarySqlOperator;
 import org.openrdf.sail.rdbms.algebra.base.RdbmsQueryModelVisitorBase;
 import org.openrdf.sail.rdbms.algebra.base.SqlExpr;
 
 /**
  * The SQL LIKE operator.
  * 
  * @author James Leigh
  * 
  */
 public class SqlLike extends BinarySqlOperator {
 	public SqlLike(SqlExpr left, SqlExpr right) {
 		super(left, right);
 	}
 
 	@Override
-	public <X extends Exception> void visit(
-			RdbmsQueryModelVisitorBase<X> visitor) throws X {
+	public <X extends Exception> void visit(RdbmsQueryModelVisitorBase<X> visitor)
+		throws X
+	{
 		visitor.meet(this);
 	}
 
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/SelectQuery.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/SelectQuery.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/SelectQuery.java (revision 85)
@@ -1,270 +1,279 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.algebra;
 
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 
 import org.openrdf.query.algebra.QueryModelNode;
 import org.openrdf.query.algebra.QueryModelVisitor;
 import org.openrdf.query.algebra.TupleExpr;
 import org.openrdf.sail.rdbms.algebra.base.FromItem;
 import org.openrdf.sail.rdbms.algebra.base.RdbmsQueryModelNodeBase;
 import org.openrdf.sail.rdbms.algebra.base.RdbmsQueryModelVisitorBase;
 import org.openrdf.sail.rdbms.algebra.base.SqlConstant;
 import org.openrdf.sail.rdbms.algebra.base.SqlExpr;
 
 /**
  * An SQL query.
  * 
  * @author James Leigh
  * 
  */
 public class SelectQuery extends RdbmsQueryModelNodeBase implements TupleExpr {
 	public static class OrderElem {
 		public final SqlExpr sqlExpr;
 		public final boolean isAscending;
 
 		protected OrderElem(SqlExpr sqlExpr, boolean isAscending) {
 			this.sqlExpr = sqlExpr;
 			this.isAscending = isAscending;
 		}
 	}
 
 	private Map<String, SelectProjection> projections = new HashMap();
 	private Map<String, String> bindingNames;
 	private boolean distinct;
 	private FromItem from;
 	private List<OrderElem> order = new ArrayList<OrderElem>();
 	private Integer offset;
 	private Integer limit;
 
 	public boolean isDistinct() {
 		return distinct;
 	}
 
 	public void setDistinct(boolean b) {
 		distinct = b;
 	}
 
 	public boolean isComplex() {
 		if (offset != null || limit != null)
 			return true;
 		return isDistinct() || !order.isEmpty();
 	}
 
 	public FromItem getFrom() {
 		return from;
 	}
 
 	public void setFrom(FromItem from) {
 		this.from = from;
 		from.setParentNode(this);
 	}
 
 	public List<OrderElem> getOrderElems() {
 		return order;
 	}
 
 	public void addOrder(SqlExpr order, boolean isAscending) {
 		if (order instanceof SqlNull)
 			return;
 		if (order instanceof SqlConstant<?>)
 			return;
 		this.order.add(new OrderElem(order, isAscending));
 		order.setParentNode(this);
 	}
 
 	public Integer getOffset() {
 		return offset;
 	}
 
 	public void setOffset(Integer offset) {
 		this.offset = offset;
 	}
 
 	public Integer getLimit() {
 		return limit;
 	}
 
 	public void setLimit(Integer limit) {
 		this.limit = limit;
 	}
 
 	public String getBindingName(ColumnVar var) {
 		if (bindingNames == null)
 			return var.getName();
 		return bindingNames.get(var.getName());
 	}
 
 	public Set<String> getBindingNames() {
 		if (bindingNames == null) {
 			Set<String> names = new HashSet<String>();
 			for (ColumnVar var : getVars()) {
 				names.add(var.getName());
 			}
 			return names;
 		}
 		return new HashSet<String>(bindingNames.values());
 	}
 
 	public void setBindingNames(Map<String, String> bindingNames) {
 		this.bindingNames = bindingNames;
 	}
 
 	public Collection<SelectProjection> getSqlSelectVar() {
 		return projections.values();
 	}
 
 	public void setSqlSelectVar(Collection<SelectProjection> projections) {
 		this.projections.clear();
 		for (SelectProjection p : projections) {
 			addSqlSelectVar(p);
 		}
 	}
 
 	public SelectProjection getSelectProjection(String name) {
 		return projections.get(name);
 	}
 
 	@Override
-	public void replaceChildNode(QueryModelNode current,
-			QueryModelNode replacement) {
+	public void replaceChildNode(QueryModelNode current, QueryModelNode replacement) {
 		for (String name : projections.keySet()) {
 			if (projections.get(name) == current) {
-				projections.put(name, (SelectProjection) replacement);
+				projections.put(name, (SelectProjection)replacement);
 				replacement.setParentNode(this);
 				return;
 			}
 		}
 		if (from == current) {
-			from = (FromItem) replacement;
+			from = (FromItem)replacement;
 			replacement.setParentNode(this);
 			return;
 		}
 		for (int i = 0, n = order.size(); i < n; i++) {
 			if (order.get(i).sqlExpr == current) {
-				if (replacement instanceof SqlNull
-						|| order instanceof SqlConstant<?>) {
+				if (replacement instanceof SqlNull || order instanceof SqlConstant<?>) {
 					order.remove(i);
 					return;
 				}
 				boolean asc = order.get(i).isAscending;
-				order.set(i, new OrderElem((SqlExpr) replacement, asc));
+				order.set(i, new OrderElem((SqlExpr)replacement, asc));
 				replacement.setParentNode(this);
 				return;
 			}
 		}
 		super.replaceChildNode(current, replacement);
 	}
 
 	@Override
 	public <X extends Exception> void visitChildren(QueryModelVisitor<X> visitor)
-			throws X {
+		throws X
+	{
 		super.visitChildren(visitor);
 		from.visit(visitor);
 		ArrayList<SelectProjection> list = new ArrayList(projections.values());
 		for (SelectProjection expr : list) {
 			expr.visit(visitor);
 		}
 		for (OrderElem by : new ArrayList<OrderElem>(order)) {
 			by.sqlExpr.visit(visitor);
 		}
 	}
 
 	@Override
 	public SelectQuery clone() {
-		SelectQuery clone = (SelectQuery) super.clone();
+		SelectQuery clone = (SelectQuery)super.clone();
 		clone.distinct = distinct;
 		clone.projections = new HashMap<String, SelectProjection>();
 		for (SelectProjection expr : projections.values()) {
 			clone.addSqlSelectVar(expr.clone());
 		}
 		clone.from = from.clone();
 		clone.order = new ArrayList<OrderElem>(order);
 		return clone;
 	}
 
 	@Override
-	public <X extends Exception> void visit(
-			RdbmsQueryModelVisitorBase<X> visitor) throws X {
+	public <X extends Exception> void visit(RdbmsQueryModelVisitorBase<X> visitor)
+		throws X
+	{
 		visitor.meet(this);
 	}
 
 	public boolean hasSqlSelectVar(SelectProjection node) {
 		return projections.containsKey(node.getVar().getName());
 	}
 
 	public void addSqlSelectVar(SelectProjection node) {
 		projections.put(node.getVar().getName(), node);
 		node.setParentNode(this);
 	}
 
 	public Collection<ColumnVar> getProjections() {
 		List<ColumnVar> vars = new ArrayList<ColumnVar>();
 		for (SelectProjection proj : projections.values()) {
 			ColumnVar var = proj.getVar();
 			if (bindingNames != null) {
 				var = var.as(bindingNames.get(var.getName()));
 			}
 			vars.add(var);
 		}
 		return vars;
 	}
 
 	public Collection<ColumnVar> getVars() {
 		List<ColumnVar> vars = new ArrayList<ColumnVar>();
 		from.appendVars(vars);
 		return vars;
 	}
 
 	public ColumnVar getVar(String varName) {
 		return from.getVar(varName);
 	}
 
 	public void addFilter(SqlExpr sql) {
 		from.addFilter(sql);
 	}
 
 	public void addJoin(SelectQuery right) {
 		from.addJoin(right.getFrom());
 	}
 
 	public void addLeftJoin(SelectQuery right) {
 		FromItem join = right.getFrom();
 		join.setLeft(true);
 		from.addJoin(join);
 	}
 
 	public FromItem getFromItem(String alias) {
 		return from.getFromItem(alias);
 	}
 
 	public List<SqlExpr> getFilters() {
 		return from.getFilters();
 	}
 
 	public void removeFilter(SqlExpr sqlExpr) {
 		from.removeFilter(sqlExpr);
 	}
 
 	public Map<String, ColumnVar> getVarMap() {
 		Collection<ColumnVar> vars = getVars();
 		Map<String, ColumnVar> map = new HashMap<String, ColumnVar>(vars.size());
 		for (ColumnVar var : vars) {
 			if (!map.containsKey(var.getName())) {
 				map.put(var.getName(), var);
 			}
 		}
 		return map;
 	}
 
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/SqlCompare.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/SqlCompare.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/SqlCompare.java (revision 85)
@@ -1,85 +1,91 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.algebra;
 
 import org.openrdf.query.algebra.Compare.CompareOp;
 import org.openrdf.sail.rdbms.algebra.base.BinarySqlOperator;
 import org.openrdf.sail.rdbms.algebra.base.RdbmsQueryModelVisitorBase;
 import org.openrdf.sail.rdbms.algebra.base.SqlExpr;
 
 /**
  * The SQL compare expressions (>, <, >=, <=).
  * 
  * @author James Leigh
  * 
  */
 public class SqlCompare extends BinarySqlOperator {
 	public enum Operator {
-		GT, LT, GE, LE
+		GT,
+		LT,
+		GE,
+		LE
 	}
 
 	private Operator op;
 
 	public SqlCompare(SqlExpr leftArg, CompareOp op, SqlExpr rightArg) {
 		super(leftArg, rightArg);
 		switch (op) {
 		case GT:
 			this.op = Operator.GT;
 			break;
 		case LT:
 			this.op = Operator.LT;
 			break;
 		case GE:
 			this.op = Operator.GE;
 			break;
 		case LE:
 			this.op = Operator.LE;
 			break;
 		default:
 			throw new AssertionError(op);
 		}
 	}
 
 	public Operator getOperator() {
 		return op;
 	}
 
 	@Override
 	public String getSignature() {
 		return super.getSignature() + " (" + op + ")";
 	}
 
 	@Override
-	public <X extends Exception> void visit(
-			RdbmsQueryModelVisitorBase<X> visitor) throws X {
+	public <X extends Exception> void visit(RdbmsQueryModelVisitorBase<X> visitor)
+		throws X
+	{
 		visitor.meet(this);
 	}
 
 	@Override
 	public int hashCode() {
 		final int prime = 31;
 		int result = super.hashCode();
 		result = prime * result + ((op == null) ? 0 : op.hashCode());
 		return result;
 	}
 
 	@Override
 	public boolean equals(Object obj) {
 		if (this == obj)
 			return true;
 		if (!super.equals(obj))
 			return false;
 		if (getClass() != obj.getClass())
 			return false;
-		final SqlCompare other = (SqlCompare) obj;
+		final SqlCompare other = (SqlCompare)obj;
 		if (op == null) {
 			if (other.op != null)
 				return false;
-		} else if (!op.equals(other.op))
+		}
+		else if (!op.equals(other.op))
 			return false;
 		return true;
 	}
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/ColumnVar.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/ColumnVar.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/ColumnVar.java (revision 85)
@@ -1,216 +1,229 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.algebra;
 
 import org.openrdf.model.Resource;
 import org.openrdf.model.URI;
 import org.openrdf.model.Value;
 import org.openrdf.query.algebra.Var;
 import org.openrdf.sail.rdbms.model.RdbmsResource;
 import org.openrdf.sail.rdbms.model.RdbmsURI;
 import org.openrdf.sail.rdbms.schema.ValueTypes;
 
 /**
  * Represents a variable in an SQL expression.
  * 
  * @author James Leigh
  * 
  */
 public class ColumnVar implements Cloneable {
 	private int index;
 	private boolean anonymous;
 	private boolean hidden;
 	private boolean implied;
 	private String name;
 	private Value value;
 	private String alias;
 	private String column;
 	private boolean nullable;
 	private ValueTypes types;
 
 	private ColumnVar() {
 	}
 
 	public static ColumnVar createSubj(String alias, Var v, Resource resource) {
 		ColumnVar var = new ColumnVar();
 		var.alias = alias;
 		var.column = "subj";
 		var.name = v.getName();
 		var.anonymous = v.isAnonymous();
 		var.value = resource;
 		var.types = ValueTypes.RESOURCE;
 		if (resource instanceof RdbmsURI) {
 			var.types = ValueTypes.URI;
 		}
 		return var;
 	}
 
 	public static ColumnVar createPred(String alias, Var v, URI uri, boolean implied) {
 		ColumnVar var = createSubj(alias, v, uri);
 		var.column = "pred";
 		var.implied = uri != null && implied;
 		var.types = ValueTypes.URI;
 		return var;
 	}
 
 	public static ColumnVar createObj(String alias, Var v, Value value) {
 		ColumnVar var = new ColumnVar();
 		var.alias = alias;
 		var.column = "obj";
 		var.name = v.getName();
 		var.anonymous = v.isAnonymous();
 		var.value = value;
 		var.types = ValueTypes.UNKNOWN;
 		if (value instanceof RdbmsURI) {
 			var.types = ValueTypes.URI;
-		} else if (value instanceof RdbmsResource) {
+		}
+		else if (value instanceof RdbmsResource) {
 			var.types = ValueTypes.RESOURCE;
 		}
 		return var;
 	}
 
 	public static ColumnVar createCtx(String alias, Var v, Resource resource) {
 		ColumnVar var = new ColumnVar();
 		var.alias = alias;
 		var.column = "ctx";
 		if (v == null) {
-			var.name = "__ctx"
-					+ Integer.toHexString(System.identityHashCode(var));
+			var.name = "__ctx" + Integer.toHexString(System.identityHashCode(var));
 			var.anonymous = true;
 			var.hidden = true;
-		} else {
+		}
+		else {
 			var.name = v.getName();
 			var.anonymous = v.isAnonymous();
 		}
 		var.value = resource;
 		var.types = ValueTypes.RESOURCE;
 		if (resource instanceof RdbmsURI) {
 			var.types = ValueTypes.URI;
 		}
 		return var;
 	}
 
 	public ValueTypes getTypes() {
 		return types;
 	}
 
 	public void setTypes(ValueTypes types) {
 		this.types = types;
 	}
 
 	public boolean isAnonymous() {
 		return anonymous;
 	}
 
 	public boolean isHidden() {
 		return hidden || value != null;
 	}
 
 	public boolean isImplied() {
 		return implied;
 	}
 
 	public boolean isResource() {
 		return !types.isLiterals();
 	}
 
 	public boolean isURI() {
 		return !types.isLiterals() && !types.isBNodes();
 	}
 
 	public boolean isNullable() {
 		return nullable;
 	}
 
 	public int getIndex() {
 		return index;
 	}
 
 	public void setIndex(int index) {
 		this.index = index;
 	}
 
 	public String getName() {
 		return name;
 	}
 
 	public Value getValue() {
 		return value;
 	}
 
 	public void setValue(Value value) {
 		this.value = value;
 	}
 
 	public String getColumn() {
 		return column;
 	}
 
 	public boolean isPredicate() {
 		return "pred".equals(column);
 	}
 
 	public String getAlias() {
 		return alias;
 	}
 
 	public ColumnVar as(String name) {
 		try {
-			ColumnVar clone = (ColumnVar) super.clone();
+			ColumnVar clone = (ColumnVar)super.clone();
 			clone.name = name;
 			return clone;
-		} catch (CloneNotSupportedException e) {
+		}
+		catch (CloneNotSupportedException e) {
 			throw new AssertionError(e);
 		}
 	}
 
 	public ColumnVar as(String alias, String column) {
 		try {
-			ColumnVar clone = (ColumnVar) super.clone();
+			ColumnVar clone = (ColumnVar)super.clone();
 			clone.alias = alias;
 			clone.column = column;
 			clone.nullable = true;
 			return clone;
-		} catch (CloneNotSupportedException e) {
+		}
+		catch (CloneNotSupportedException e) {
 			throw new AssertionError(e);
 		}
 	}
 
 	@Override
 	public boolean equals(Object other) {
 		if (other instanceof ColumnVar) {
-			return name.equals(((ColumnVar) other).name);
+			return name.equals(((ColumnVar)other).name);
 		}
 
 		return false;
 	}
 
 	@Override
 	public int hashCode() {
 		return name.hashCode();
 	}
 
 	@Override
 	public String toString() {
 		StringBuilder sb = new StringBuilder(128);
 
 		sb.append(alias).append(".").append(column);
 
 		sb.append(" (name=").append(name);
 
 		if (value != null) {
 			sb.append(", value=").append(value.toString());
 		}
 
 		sb.append(")");
 		if (index > 0) {
 			sb.append("#").append(index);
 		}
 
 		return sb.toString();
 	}
 
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/DoubleValue.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/DoubleValue.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/DoubleValue.java (revision 85)
@@ -1,28 +1,29 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.algebra;
 
 import org.openrdf.sail.rdbms.algebra.base.RdbmsQueryModelVisitorBase;
 import org.openrdf.sail.rdbms.algebra.base.SqlConstant;
 
 /**
  * A static number in an SQL expression.
  * 
  * @author James Leigh
  * 
  */
 public class DoubleValue extends SqlConstant<Double> {
 
 	public DoubleValue(Double value) {
 		super(value);
 	}
 
 	@Override
-	public <X extends Exception> void visit(
-			RdbmsQueryModelVisitorBase<X> visitor) throws X {
+	public <X extends Exception> void visit(RdbmsQueryModelVisitorBase<X> visitor)
+		throws X
+	{
 		visitor.meet(this);
 	}
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/PointColumn.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/PointColumn.java (revision 84)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/PointColumn.java (revision 84)
@@ -0,0 +1,22 @@
+package org.openrdf.sail.rdbms.algebra;
+
+import org.openrdf.query.algebra.Var;
+import org.openrdf.sail.rdbms.algebra.base.RdbmsQueryModelVisitorBase;
+import org.openrdf.sail.rdbms.algebra.base.ValueColumnBase;
+
+/**
+ * Represents a point value in an SQL expression.
+ */
+public class PointColumn extends ValueColumnBase {
+
+	public PointColumn(Var var) {
+		super(var);
+	}
+
+	@Override
+	public <X extends Exception> void visit(
+			RdbmsQueryModelVisitorBase<X> visitor) throws X {
+		visitor.meet(this);
+	}
+
+}
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/SqlMathExpr.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/SqlMathExpr.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/SqlMathExpr.java (revision 85)
@@ -1,36 +1,38 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.algebra;
 
 import org.openrdf.query.algebra.MathExpr.MathOp;
 import org.openrdf.sail.rdbms.algebra.base.BinarySqlOperator;
 import org.openrdf.sail.rdbms.algebra.base.RdbmsQueryModelVisitorBase;
 import org.openrdf.sail.rdbms.algebra.base.SqlExpr;
 
 /**
  * The SQL subtraction (-) expression.
  * 
  * @author James Leigh
  * 
  */
 public class SqlMathExpr extends BinarySqlOperator {
 	private MathOp op;
 
 	public SqlMathExpr(SqlExpr leftArg, MathOp op, SqlExpr rightArg) {
 		super(leftArg, rightArg);
 		this.op = op;
 	}
 
 	public MathOp getOperator() {
 		return op;
 	}
 
 	@Override
-	public <X extends Exception> void visit(
-			RdbmsQueryModelVisitorBase<X> visitor) throws X {
+	public <X extends Exception> void visit(RdbmsQueryModelVisitorBase<X> visitor)
+		throws X
+	{
 		visitor.meet(this);
 	}
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/IdColumn.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/IdColumn.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/IdColumn.java (revision 85)
@@ -1,94 +1,99 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.algebra;
 
 import org.openrdf.sail.rdbms.algebra.base.RdbmsQueryModelNodeBase;
 import org.openrdf.sail.rdbms.algebra.base.RdbmsQueryModelVisitorBase;
 import org.openrdf.sail.rdbms.algebra.base.SqlExpr;
 
 /**
  * A particular column in an SQL expression.
  * 
  * @author James Leigh
  * 
  */
 public class IdColumn extends RdbmsQueryModelNodeBase implements SqlExpr {
 	private String alias;
 	private String column;
 
 	public IdColumn(String alias) {
 		super();
 		this.alias = alias;
 		this.column = "id";
 	}
 
 	public IdColumn(ColumnVar var) {
 		super();
 		this.alias = var.getAlias();
 		this.column = var.getColumn();
 	}
 
 	public IdColumn(String alias, String column) {
 		super();
 		this.alias = alias;
 		this.column = column;
 	}
 
 	public String getAlias() {
 		return alias;
 	}
 
 	public String getColumn() {
 		return column;
 	}
 
 	@Override
 	public String getSignature() {
 		return super.getSignature() + " " + alias + "." + column;
 	}
 
 	@Override
-	public <X extends Exception> void visit(
-			RdbmsQueryModelVisitorBase<X> visitor) throws X {
+	public <X extends Exception> void visit(RdbmsQueryModelVisitorBase<X> visitor)
+		throws X
+	{
 		visitor.meet(this);
 	}
 
 	@Override
 	public IdColumn clone() {
-		return (IdColumn) super.clone();
+		return (IdColumn)super.clone();
 	}
 
 	@Override
 	public int hashCode() {
 		final int prime = 31;
 		int result = 1;
 		result = prime * result + ((alias == null) ? 0 : alias.hashCode());
 		result = prime * result + ((column == null) ? 0 : column.hashCode());
 		return result;
 	}
 
 	@Override
 	public boolean equals(Object obj) {
 		if (this == obj)
 			return true;
 		if (obj == null)
 			return false;
 		if (getClass() != obj.getClass())
 			return false;
-		final IdColumn other = (IdColumn) obj;
+		final IdColumn other = (IdColumn)obj;
 		if (alias == null) {
 			if (other.alias != null)
 				return false;
-		} else if (!alias.equals(other.alias))
+		}
+		else if (!alias.equals(other.alias))
 			return false;
 		if (column == null) {
 			if (other.column != null)
 				return false;
-		} else if (!column.equals(other.column))
+		}
+		else if (!column.equals(other.column))
 			return false;
 		return true;
 	}
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/TrueValue.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/TrueValue.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/TrueValue.java (revision 85)
@@ -1,28 +1,29 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.algebra;
 
 import org.openrdf.sail.rdbms.algebra.base.BooleanValue;
 import org.openrdf.sail.rdbms.algebra.base.RdbmsQueryModelVisitorBase;
 
 /**
  * The boolean SQL expression of true.
  * 
  * @author James Leigh
  * 
  */
 public class TrueValue extends BooleanValue {
 
 	public TrueValue() {
 		super(true);
 	}
 
 	@Override
-	public <X extends Exception> void visit(
-			RdbmsQueryModelVisitorBase<X> visitor) throws X {
+	public <X extends Exception> void visit(RdbmsQueryModelVisitorBase<X> visitor)
+		throws X
+	{
 		visitor.meet(this);
 	}
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/LongLabelColumn.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/LongLabelColumn.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/LongLabelColumn.java (revision 85)
@@ -1,34 +1,35 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.algebra;
 
 import org.openrdf.query.algebra.Var;
 import org.openrdf.sail.rdbms.algebra.base.RdbmsQueryModelVisitorBase;
 import org.openrdf.sail.rdbms.algebra.base.ValueColumnBase;
 
 /**
  * Represents a variable's long label value in an SQL expression.
  * 
  * @author James Leigh
  * 
  */
 public class LongLabelColumn extends ValueColumnBase {
 
 	public LongLabelColumn(Var var) {
 		super(var);
 	}
 
 	public LongLabelColumn(ColumnVar var) {
 		super(var);
 	}
 
 	@Override
-	public <X extends Exception> void visit(
-			RdbmsQueryModelVisitorBase<X> visitor) throws X {
+	public <X extends Exception> void visit(RdbmsQueryModelVisitorBase<X> visitor)
+		throws X
+	{
 		visitor.meet(this);
 	}
 
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/URIColumn.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/URIColumn.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/URIColumn.java (revision 85)
@@ -1,34 +1,35 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.algebra;
 
 import org.openrdf.query.algebra.Var;
 import org.openrdf.sail.rdbms.algebra.base.RdbmsQueryModelVisitorBase;
 import org.openrdf.sail.rdbms.algebra.base.ValueColumnBase;
 
 /**
  * Represents a variable's URI value in an SQL expression.
  * 
  * @author James Leigh
  * 
  */
 public class URIColumn extends ValueColumnBase {
 
 	public URIColumn(Var var) {
 		super(var);
 	}
 
 	public URIColumn(ColumnVar var) {
 		super(var);
 	}
 
 	@Override
-	public <X extends Exception> void visit(
-			RdbmsQueryModelVisitorBase<X> visitor) throws X {
+	public <X extends Exception> void visit(RdbmsQueryModelVisitorBase<X> visitor)
+		throws X
+	{
 		visitor.meet(this);
 	}
 
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/JoinItem.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/JoinItem.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/JoinItem.java (revision 85)
@@ -1,89 +1,93 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.algebra;
 
 import java.util.ArrayList;
 import java.util.List;
 
 import org.openrdf.sail.rdbms.algebra.base.FromItem;
 import org.openrdf.sail.rdbms.algebra.base.RdbmsQueryModelVisitorBase;
 
 /**
  * An SQL join.
  * 
  * @author James Leigh
  * 
  */
 public class JoinItem extends FromItem {
 	private String tableName;
 	private Number predId;
 	private List<ColumnVar> vars = new ArrayList<ColumnVar>();
 
 	public JoinItem(String alias, String tableName, Number predId) {
 		super(alias);
 		this.tableName = tableName;
 		this.predId = predId;
 	}
 
 	public JoinItem(String alias, String tableName) {
 		super(alias);
 		this.tableName = tableName;
 		this.predId = 0;
 	}
 
 	public String getTableName() {
 		return tableName;
 	}
 
 	public Number getPredId() {
 		return predId;
 	}
 
 	public void addVar(ColumnVar var) {
 		this.vars.add(var);
 	}
 
 	@Override
 	public ColumnVar getVarForChildren(String name) {
 		for (ColumnVar var : vars) {
 			if (var.getName().equals(name))
 				return var;
 		}
 		return super.getVarForChildren(name);
 	}
 
 	@Override
 	public List<ColumnVar> appendVars(List<ColumnVar> vars) {
 		vars.addAll(this.vars);
 		return super.appendVars(vars);
 	}
 
 	@Override
 	public String getSignature() {
 		StringBuilder sb = new StringBuilder();
 		if (isLeft()) {
 			sb.append("LEFT ");
 		}
 		sb.append(super.getSignature());
 		sb.append(" ").append(tableName);
 		sb.append(" ").append(getAlias());
 		return sb.toString();
 	}
 
 	@Override
 	public JoinItem clone() {
-		JoinItem clone = (JoinItem) super.clone();
+		JoinItem clone = (JoinItem)super.clone();
 		clone.vars = new ArrayList<ColumnVar>(vars);
 		return clone;
 	}
 
 	@Override
-	public <X extends Exception> void visit(
-			RdbmsQueryModelVisitorBase<X> visitor) throws X {
+	public <X extends Exception> void visit(RdbmsQueryModelVisitorBase<X> visitor)
+		throws X
+	{
 		visitor.meet(this);
 	}
 
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/SqlEq.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/SqlEq.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/SqlEq.java (revision 85)
@@ -1,29 +1,30 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.algebra;
 
 import org.openrdf.sail.rdbms.algebra.base.BinarySqlOperator;
 import org.openrdf.sail.rdbms.algebra.base.RdbmsQueryModelVisitorBase;
 import org.openrdf.sail.rdbms.algebra.base.SqlExpr;
 
 /**
  * The SQL equals expression (=).
  * 
  * @author James Leigh
  * 
  */
 public class SqlEq extends BinarySqlOperator {
 
 	public SqlEq(SqlExpr leftArg, SqlExpr rightArg) {
 		super(leftArg, rightArg);
 	}
 
 	@Override
-	public <X extends Exception> void visit(
-			RdbmsQueryModelVisitorBase<X> visitor) throws X {
+	public <X extends Exception> void visit(RdbmsQueryModelVisitorBase<X> visitor)
+		throws X
+	{
 		visitor.meet(this);
 	}
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/SqlAbs.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/SqlAbs.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/SqlAbs.java (revision 85)
@@ -1,29 +1,30 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.algebra;
 
 import org.openrdf.sail.rdbms.algebra.base.RdbmsQueryModelVisitorBase;
 import org.openrdf.sail.rdbms.algebra.base.SqlExpr;
 import org.openrdf.sail.rdbms.algebra.base.UnarySqlOperator;
 
 /**
  * The SQL ABS expression.
  * 
  * @author James Leigh
  * 
  */
 public class SqlAbs extends UnarySqlOperator {
 
 	public SqlAbs(SqlExpr arg) {
 		super(arg);
 	}
 
 	@Override
-	public <X extends Exception> void visit(
-			RdbmsQueryModelVisitorBase<X> visitor) throws X {
+	public <X extends Exception> void visit(RdbmsQueryModelVisitorBase<X> visitor)
+		throws X
+	{
 		visitor.meet(this);
 	}
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/SqlIsNull.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/SqlIsNull.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/SqlIsNull.java (revision 85)
@@ -1,30 +1,31 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.algebra;
 
 import org.openrdf.sail.rdbms.algebra.base.RdbmsQueryModelVisitorBase;
 import org.openrdf.sail.rdbms.algebra.base.SqlExpr;
 import org.openrdf.sail.rdbms.algebra.base.UnarySqlOperator;
 
 /**
  * The SQL IS NULL expression.
  * 
  * @author James Leigh
  * 
  */
 public class SqlIsNull extends UnarySqlOperator {
 
 	public SqlIsNull(SqlExpr arg) {
 		super(arg);
 	}
 
 	@Override
-	public <X extends Exception> void visit(
-			RdbmsQueryModelVisitorBase<X> visitor) throws X {
+	public <X extends Exception> void visit(RdbmsQueryModelVisitorBase<X> visitor)
+		throws X
+	{
 		visitor.meet(this);
 	}
 
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/SqlConcat.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/SqlConcat.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/SqlConcat.java (revision 85)
@@ -1,29 +1,30 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.algebra;
 
 import org.openrdf.sail.rdbms.algebra.base.BinarySqlOperator;
 import org.openrdf.sail.rdbms.algebra.base.RdbmsQueryModelVisitorBase;
 import org.openrdf.sail.rdbms.algebra.base.SqlExpr;
 
 /**
  * The SQL concatenate expression (||).
  * 
  * @author James Leigh
  * 
  */
 public class SqlConcat extends BinarySqlOperator {
 
 	public SqlConcat(SqlExpr leftArg, SqlExpr rightArg) {
 		super(leftArg, rightArg);
 	}
 
 	@Override
-	public <X extends Exception> void visit(
-			RdbmsQueryModelVisitorBase<X> visitor) throws X {
+	public <X extends Exception> void visit(RdbmsQueryModelVisitorBase<X> visitor)
+		throws X
+	{
 		visitor.meet(this);
 	}
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/DatatypeColumn.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/DatatypeColumn.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/DatatypeColumn.java (revision 85)
@@ -1,33 +1,35 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.algebra;
 
 import org.openrdf.query.algebra.Var;
 import org.openrdf.sail.rdbms.algebra.base.RdbmsQueryModelVisitorBase;
 import org.openrdf.sail.rdbms.algebra.base.ValueColumnBase;
 
 /**
  * Represents a variable's datatype value in an SQL expression.
+ * 
  * @author James Leigh
  *
  */
 public class DatatypeColumn extends ValueColumnBase {
 
 	public DatatypeColumn(Var var) {
 		super(var);
 	}
 
 	public DatatypeColumn(ColumnVar var) {
 		super(var);
 	}
 
 	@Override
-	public <X extends Exception> void visit(
-			RdbmsQueryModelVisitorBase<X> visitor) throws X {
+	public <X extends Exception> void visit(RdbmsQueryModelVisitorBase<X> visitor)
+		throws X
+	{
 		visitor.meet(this);
 	}
 
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/SqlRegex.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/SqlRegex.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/SqlRegex.java (revision 85)
@@ -1,120 +1,122 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.algebra;
 
 import org.openrdf.query.algebra.QueryModelVisitor;
 import org.openrdf.sail.rdbms.algebra.base.BinarySqlOperator;
 import org.openrdf.sail.rdbms.algebra.base.RdbmsQueryModelVisitorBase;
 import org.openrdf.sail.rdbms.algebra.base.SqlExpr;
 
 /**
  * The regular SQL expression - notation varies between databases.
  * 
  * @author James Leigh
  * 
  */
 public class SqlRegex extends BinarySqlOperator {
 
 	/*-----------*
 	 * Variables *
 	 *-----------*/
 
 	private SqlExpr flagsArg;
 
 	/*--------------*
 	 * Constructors *
 	 *--------------*/
 
 	public SqlRegex() {
 	}
 
 	public SqlRegex(SqlExpr expr, SqlExpr pattern) {
 		super(expr, pattern);
 	}
 
 	public SqlRegex(SqlExpr expr, SqlExpr pattern, SqlExpr flags) {
 		super(expr, pattern);
 		setFlagsArg(flags);
 	}
 
 	/*---------*
 	 * Methods *
 	 *---------*/
 
 	public SqlExpr getArg() {
 		return super.getLeftArg();
 	}
 
 	public void setArg(SqlExpr leftArg) {
 		super.setLeftArg(leftArg);
 	}
 
 	public SqlExpr getPatternArg() {
 		return super.getRightArg();
 	}
 
 	public void setPatternArg(SqlExpr rightArg) {
 		super.setRightArg(rightArg);
 	}
 
 	public void setFlagsArg(SqlExpr flags) {
 		this.flagsArg = flags;
 	}
 
 	public SqlExpr getFlagsArg() {
 		return flagsArg;
 	}
 
 	@Override
 	public <X extends Exception> void visitChildren(QueryModelVisitor<X> visitor)
-			throws X {
+		throws X
+	{
 		super.visitChildren(visitor);
 		if (flagsArg != null) {
 			flagsArg.visit(visitor);
 		}
 	}
 
 	@Override
 	public SqlRegex clone() {
-		SqlRegex clone = (SqlRegex) super.clone();
+		SqlRegex clone = (SqlRegex)super.clone();
 		if (flagsArg != null) {
 			clone.setFlagsArg(flagsArg.clone());
 		}
 		return clone;
 	}
 
 	@Override
-	public <X extends Exception> void visit(
-			RdbmsQueryModelVisitorBase<X> visitor) throws X {
+	public <X extends Exception> void visit(RdbmsQueryModelVisitorBase<X> visitor)
+		throws X
+	{
 		visitor.meet(this);
 	}
 
 	@Override
 	public int hashCode() {
 		final int prime = 31;
 		int result = super.hashCode();
-		result = prime * result
-				+ ((flagsArg == null) ? 0 : flagsArg.hashCode());
+		result = prime * result + ((flagsArg == null) ? 0 : flagsArg.hashCode());
 		return result;
 	}
 
 	@Override
 	public boolean equals(Object obj) {
 		if (this == obj)
 			return true;
 		if (!super.equals(obj))
 			return false;
 		if (getClass() != obj.getClass())
 			return false;
-		final SqlRegex other = (SqlRegex) obj;
+		final SqlRegex other = (SqlRegex)obj;
 		if (flagsArg == null) {
 			if (other.flagsArg != null)
 				return false;
-		} else if (!flagsArg.equals(other.flagsArg))
+		}
+		else if (!flagsArg.equals(other.flagsArg))
 			return false;
 		return true;
 	}
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/base/RdbmsQueryModelNodeBase.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/base/RdbmsQueryModelNodeBase.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/base/RdbmsQueryModelNodeBase.java (revision 85)
@@ -1,30 +1,32 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.algebra.base;
 
 import org.openrdf.query.algebra.QueryModelNodeBase;
 import org.openrdf.query.algebra.QueryModelVisitor;
 
 /**
  * An extension to {@link QueryModelNodeBase} for SQL query algebra.
  * 
  * @author James Leigh
  * 
  */
 public abstract class RdbmsQueryModelNodeBase extends QueryModelNodeBase {
 
 	public <X extends Exception> void visit(QueryModelVisitor<X> visitor)
-			throws X {
+		throws X
+	{
 		if (visitor instanceof RdbmsQueryModelVisitorBase) {
-			visit((RdbmsQueryModelVisitorBase<X>) visitor);
-		} else {
+			visit((RdbmsQueryModelVisitorBase<X>)visitor);
+		}
+		else {
 			visitor.meetOther(this);
 		}
 	}
 
-	public abstract <X extends Exception> void visit(
-			RdbmsQueryModelVisitorBase<X> visitor) throws X;
+	public abstract <X extends Exception> void visit(RdbmsQueryModelVisitorBase<X> visitor)
+		throws X;
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/base/BinarySqlOperator.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/base/BinarySqlOperator.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/base/BinarySqlOperator.java (revision 85)
@@ -1,125 +1,132 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.algebra.base;
 
 import org.openrdf.query.algebra.QueryModelNode;
 import org.openrdf.query.algebra.QueryModelVisitor;
 import org.openrdf.query.algebra.helpers.QueryModelTreePrinter;
 import org.openrdf.sail.rdbms.optimizers.SqlConstantOptimizer;
 
 /**
  * An abstract binary sql operator with two arguments.
  * 
  * @author James Leigh
  * 
  */
-public abstract class BinarySqlOperator extends RdbmsQueryModelNodeBase
-		implements SqlExpr {
+public abstract class BinarySqlOperator extends RdbmsQueryModelNodeBase implements SqlExpr {
+
 	private SqlExpr leftArg;
 	private SqlExpr rightArg;
 
 	public BinarySqlOperator() {
 		super();
 	}
 
 	public BinarySqlOperator(SqlExpr leftArg, SqlExpr rightArg) {
 		super();
 		setLeftArg(leftArg);
 		setRightArg(rightArg);
 	}
 
 	public SqlExpr getLeftArg() {
 		return leftArg;
 	}
 
 	public void setLeftArg(SqlExpr leftArg) {
 		this.leftArg = leftArg;
 		leftArg.setParentNode(this);
 	}
 
 	public SqlExpr getRightArg() {
 		return rightArg;
 	}
 
 	public void setRightArg(SqlExpr rightArg) {
 		this.rightArg = rightArg;
 		rightArg.setParentNode(this);
 	}
 
 	@Override
 	public <X extends Exception> void visitChildren(QueryModelVisitor<X> visitor)
-			throws X {
+		throws X
+	{
 		leftArg.visit(visitor);
 		rightArg.visit(visitor);
 	}
 
 	@Override
-	public void replaceChildNode(QueryModelNode current,
-			QueryModelNode replacement) {
+	public void replaceChildNode(QueryModelNode current, QueryModelNode replacement) {
 		if (leftArg == current) {
-			setLeftArg((SqlExpr) replacement);
-		} else if (rightArg == current) {
-			setRightArg((SqlExpr) replacement);
-		} else {
+			setLeftArg((SqlExpr)replacement);
+		}
+		else if (rightArg == current) {
+			setRightArg((SqlExpr)replacement);
+		}
+		else {
 			super.replaceChildNode(current, replacement);
 		}
 	}
 
 	@Override
 	public BinarySqlOperator clone() {
-		BinarySqlOperator clone = (BinarySqlOperator) super.clone();
+		BinarySqlOperator clone = (BinarySqlOperator)super.clone();
 		clone.setLeftArg(leftArg.clone());
 		clone.setRightArg(rightArg.clone());
 		return clone;
 	}
 
 	@Override
 	public int hashCode() {
 		final int prime = 31;
 		int result = 1;
 		result = prime * result + ((leftArg == null) ? 0 : leftArg.hashCode());
-		result = prime * result
-				+ ((rightArg == null) ? 0 : rightArg.hashCode());
+		result = prime * result + ((rightArg == null) ? 0 : rightArg.hashCode());
 		return result;
 	}
 
 	@Override
 	public boolean equals(Object obj) {
 		if (this == obj)
 			return true;
 		if (obj == null)
 			return false;
 		if (getClass() != obj.getClass())
 			return false;
-		final BinarySqlOperator other = (BinarySqlOperator) obj;
+		final BinarySqlOperator other = (BinarySqlOperator)obj;
 		if (leftArg == null) {
 			if (other.leftArg != null)
 				return false;
-		} else if (!leftArg.equals(other.leftArg))
+		}
+		else if (!leftArg.equals(other.leftArg))
 			return false;
 		if (rightArg == null) {
 			if (other.rightArg != null)
 				return false;
-		} else if (!rightArg.equals(other.rightArg))
+		}
+		else if (!rightArg.equals(other.rightArg))
 			return false;
 		return true;
 	}
 
 	@Override
 	public String toString() {
 		QueryModelTreePrinter treePrinter = new QueryModelTreePrinter();
 		BinarySqlOperator clone = this.clone();
-		UnarySqlOperator parent = new UnarySqlOperator(clone){
+		UnarySqlOperator parent = new UnarySqlOperator(clone) {
+
 			@Override
-			public <X extends Exception> void visit(
-					RdbmsQueryModelVisitorBase<X> visitor) throws X {
+			public <X extends Exception> void visit(RdbmsQueryModelVisitorBase<X> visitor)
+				throws X
+			{
 				visitor.meetOther(this);
-			}};
+			}
+		};
 		new SqlConstantOptimizer().optimize(clone);
 		parent.getArg().visit(treePrinter);
 		return treePrinter.getTreeString();
 	}
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/base/FromItem.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/base/FromItem.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/base/FromItem.java (revision 85)
@@ -1,174 +1,178 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.algebra.base;
 
 import java.util.ArrayList;
 import java.util.List;
 
 import org.openrdf.query.algebra.QueryModelNode;
 import org.openrdf.query.algebra.QueryModelVisitor;
 import org.openrdf.sail.rdbms.algebra.ColumnVar;
 
 /**
  * An item in the SQL from clause.
  * 
  * @author James Leigh
  * 
  */
 public abstract class FromItem extends RdbmsQueryModelNodeBase {
 	private String alias;
 	private boolean left;
 	private List<FromItem> joins = new ArrayList<FromItem>();
 	private List<SqlExpr> filters = new ArrayList<SqlExpr>();
 
 	public FromItem(String alias) {
 		super();
 		this.alias = alias;
 	}
 
 	public String getAlias() {
 		return alias;
 	}
 
 	public boolean isLeft() {
 		return left;
 	}
 
 	public void setLeft(boolean left) {
 		this.left = left;
 	}
 
 	public List<SqlExpr> getFilters() {
 		return filters;
 	}
 
 	public void addFilter(SqlExpr filter) {
 		this.filters.add(filter);
 		filter.setParentNode(this);
 	}
 
 	public List<FromItem> getJoins() {
 		return joins;
 	}
 
 	public ColumnVar getVarForChildren(String name) {
 		for (FromItem join : joins) {
 			ColumnVar var = join.getVar(name);
 			if (var != null)
 				return var;
 		}
 		return null;
 	}
 
 	public ColumnVar getVar(String name) {
 		return getVarForChildren(name);
 	}
 
 	public void addJoin(FromItem join) {
 		joins.add(join);
 		joinAdded(join);
 	}
 
 	public void addJoinBefore(FromItem valueJoin, FromItem join) {
 		for (int i = 0, n = joins.size(); i < n; i++) {
 			if (joins.get(i) == join) {
 				joins.add(i, valueJoin);
 				joinAdded(valueJoin);
 				return;
 			}
 		}
 		addJoin(valueJoin);
 	}
 
 	protected void joinAdded(FromItem valueJoin) {
 		valueJoin.setParentNode(this);
 	}
 
 	public FromItem getFromItem(String alias) {
 		if (this.alias.equals(alias))
 			return this;
 		for (FromItem join : joins) {
 			FromItem result = join.getFromItem(alias);
 			if (result != null)
 				return result;
 		}
 		return null;
 	}
 
 	public void removeFilter(SqlExpr sqlExpr) {
 		for (int i = filters.size() - 1; i >= 0; i--) {
 			if (filters.get(i) == sqlExpr) {
 				filters.remove(i);
 				break;
 			}
 		}
 	}
 
 	public List<ColumnVar> appendVars(List<ColumnVar> vars) {
 		for (FromItem join : joins) {
 			join.appendVars(vars);
 		}
 		return vars;
 	}
 
 	@Override
 	public String getSignature() {
 		StringBuilder sb = new StringBuilder();
 		if (left) {
 			sb.append("LEFT ");
 		}
 		sb.append(super.getSignature());
 		sb.append(" ").append(alias);
 		return sb.toString();
 	}
 
 	@Override
 	public FromItem clone() {
-		FromItem clone = (FromItem) super.clone();
+		FromItem clone = (FromItem)super.clone();
 		clone.joins = new ArrayList<FromItem>();
 		for (FromItem join : joins) {
 			clone.addJoin(join.clone());
 		}
 		clone.filters = new ArrayList<SqlExpr>();
 		for (SqlExpr expr : filters) {
 			clone.addFilter(expr.clone());
 		}
 		return clone;
 	}
 
 	@Override
 	public <X extends Exception> void visitChildren(QueryModelVisitor<X> visitor)
-			throws X {
+		throws X
+	{
 		super.visitChildren(visitor);
 		for (FromItem join : new ArrayList<FromItem>(joins)) {
 			join.visit(visitor);
 		}
 		for (SqlExpr expr : new ArrayList<SqlExpr>(filters)) {
 			expr.visit(visitor);
 		}
 	}
 
 	@Override
-	public void replaceChildNode(QueryModelNode current,
-			QueryModelNode replacement) {
+	public void replaceChildNode(QueryModelNode current, QueryModelNode replacement) {
 		for (int i = 0, n = joins.size(); i < n; i++) {
 			if (current == joins.get(i)) {
-				joins.set(i, (FromItem) replacement);
-				joinAdded((FromItem) replacement);
+				joins.set(i, (FromItem)replacement);
+				joinAdded((FromItem)replacement);
 				return;
 			}
 		}
 		for (int i = 0, n = filters.size(); i < n; i++) {
 			if (current == filters.get(i)) {
-				filters.set(i, (SqlExpr) replacement);
+				filters.set(i, (SqlExpr)replacement);
 				replacement.setParentNode(this);
 				return;
 			}
 		}
 		super.replaceChildNode(current, replacement);
 	}
 
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/base/ValueColumnBase.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/base/ValueColumnBase.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/base/ValueColumnBase.java (revision 85)
@@ -1,89 +1,91 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.algebra.base;
 
 import org.openrdf.query.algebra.Var;
 import org.openrdf.sail.rdbms.algebra.ColumnVar;
 
 /**
  * A column in an SQL expression.
  * 
  * @author James Leigh
  * 
  */
-public abstract class ValueColumnBase extends RdbmsQueryModelNodeBase implements
-		SqlExpr {
+public abstract class ValueColumnBase extends RdbmsQueryModelNodeBase implements SqlExpr {
+
 	private String name;
 	private ColumnVar var;
 
 	public ValueColumnBase(Var var) {
 		this.name = var.getName();
 	}
 
 	public ValueColumnBase(ColumnVar var) {
 		this.name = var.getName();
 		setRdbmsVar(var);
 	}
 
 	public String getVarName() {
 		return name;
 	}
 
 	public ColumnVar getRdbmsVar() {
 		return var;
 	}
 
 	public void setRdbmsVar(ColumnVar var) {
 		assert var != null;
 		this.var = var;
 	}
 
 	public String getAlias() {
 		return var.getAlias();
 	}
 
 	public String getColumn() {
 		return var.getColumn();
 	}
 
 	@Override
 	public String getSignature() {
 		if (var != null)
 			return super.getSignature() + " " + var;
 		return super.getSignature() + " " + name;
 	}
 
 	@Override
 	public ValueColumnBase clone() {
-		return (ValueColumnBase) super.clone();
+		return (ValueColumnBase)super.clone();
 	}
 
 	@Override
 	public int hashCode() {
 		final int prime = 31;
 		int result = 1;
 		result = prime * result + ((name == null) ? 0 : name.hashCode());
 		return result;
 	}
 
 	@Override
 	public boolean equals(Object obj) {
 		if (this == obj)
 			return true;
 		if (obj == null)
 			return false;
 		if (getClass() != obj.getClass())
 			return false;
-		final ValueColumnBase other = (ValueColumnBase) obj;
+		final ValueColumnBase other = (ValueColumnBase)obj;
 		if (name == null) {
 			if (other.name != null)
 				return false;
-		} else if (!name.equals(other.name))
+		}
+		else if (!name.equals(other.name))
 			return false;
 		return true;
 	}
 
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/base/RdbmsQueryModelVisitorBase.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/base/RdbmsQueryModelVisitorBase.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/base/RdbmsQueryModelVisitorBase.java (revision 85)
@@ -1,222 +1,327 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.algebra.base;
 
 import org.openrdf.query.algebra.helpers.QueryModelVisitorBase;
 import org.openrdf.sail.rdbms.algebra.BNodeColumn;
 import org.openrdf.sail.rdbms.algebra.DatatypeColumn;
 import org.openrdf.sail.rdbms.algebra.DateTimeColumn;
 import org.openrdf.sail.rdbms.algebra.DoubleValue;
 import org.openrdf.sail.rdbms.algebra.FalseValue;
 import org.openrdf.sail.rdbms.algebra.HashColumn;
 import org.openrdf.sail.rdbms.algebra.IdColumn;
 import org.openrdf.sail.rdbms.algebra.JoinItem;
 import org.openrdf.sail.rdbms.algebra.LabelColumn;
 import org.openrdf.sail.rdbms.algebra.LanguageColumn;
 import org.openrdf.sail.rdbms.algebra.LongLabelColumn;
 import org.openrdf.sail.rdbms.algebra.LongURIColumn;
 import org.openrdf.sail.rdbms.algebra.NumberValue;
 import org.openrdf.sail.rdbms.algebra.NumericColumn;
+import org.openrdf.sail.rdbms.algebra.PointColumn;
 import org.openrdf.sail.rdbms.algebra.RefIdColumn;
 import org.openrdf.sail.rdbms.algebra.SelectProjection;
 import org.openrdf.sail.rdbms.algebra.SelectQuery;
 import org.openrdf.sail.rdbms.algebra.SqlAbs;
 import org.openrdf.sail.rdbms.algebra.SqlAnd;
 import org.openrdf.sail.rdbms.algebra.SqlCase;
+import org.openrdf.sail.rdbms.algebra.SqlCast;
 import org.openrdf.sail.rdbms.algebra.SqlCompare;
 import org.openrdf.sail.rdbms.algebra.SqlConcat;
 import org.openrdf.sail.rdbms.algebra.SqlEq;
 import org.openrdf.sail.rdbms.algebra.SqlIsNull;
 import org.openrdf.sail.rdbms.algebra.SqlLike;
 import org.openrdf.sail.rdbms.algebra.SqlLowerCase;
 import org.openrdf.sail.rdbms.algebra.SqlMathExpr;
+import org.openrdf.sail.rdbms.algebra.SqlMbrContains;
 import org.openrdf.sail.rdbms.algebra.SqlNot;
 import org.openrdf.sail.rdbms.algebra.SqlNull;
 import org.openrdf.sail.rdbms.algebra.SqlOr;
 import org.openrdf.sail.rdbms.algebra.SqlRegex;
 import org.openrdf.sail.rdbms.algebra.SqlShift;
 import org.openrdf.sail.rdbms.algebra.StringValue;
 import org.openrdf.sail.rdbms.algebra.TrueValue;
 import org.openrdf.sail.rdbms.algebra.URIColumn;
 import org.openrdf.sail.rdbms.algebra.UnionItem;
 
 /**
  * Base class for RDBMS visitor classes. This class is extended with additional
  * meet methods.
  * 
  * @author James Leigh
  * 
  */
-public class RdbmsQueryModelVisitorBase<X extends Exception> extends
-		QueryModelVisitorBase<X> {
-	public void meet(BNodeColumn node) throws X {
-		meetValueColumnBase(node);
-	}
-
-	public void meet(DatatypeColumn node) throws X {
-		meetValueColumnBase(node);
-	}
-
-	public void meet(DateTimeColumn node) throws X {
-		meetValueColumnBase(node);
-	}
-
-	public void meet(DoubleValue node) throws X {
-		meetSqlConstant(node);
-	}
-
-	public void meet(FalseValue node) throws X {
-		meetSqlConstant(node);
-	}
-
-	public void meet(HashColumn node) throws X {
-		meetValueColumnBase(node);
-	}
-
-	public void meet(IdColumn node) throws X {
+public class RdbmsQueryModelVisitorBase<X extends Exception> extends QueryModelVisitorBase<X> {
+
+	public void meet(BNodeColumn node)
+		throws X
+	{
+		meetValueColumnBase(node);
+	}
+
+	public void meet(DatatypeColumn node)
+		throws X
+	{
+		meetValueColumnBase(node);
+	}
+
+	public void meet(DateTimeColumn node)
+		throws X
+	{
+		meetValueColumnBase(node);
+	}
+
+	public void meet(DoubleValue node)
+		throws X
+	{
+		meetSqlConstant(node);
+	}
+
+	public void meet(FalseValue node)
+		throws X
+	{
+		meetSqlConstant(node);
+	}
+
+	public void meet(HashColumn node)
+		throws X
+	{
+		meetValueColumnBase(node);
+	}
+
+	public void meet(IdColumn node)
+		throws X
+	{
 		meetSqlExpr(node);
 	}
 
-	public void meet(JoinItem node) throws X {
+	public void meet(JoinItem node)
+		throws X
+	{
 		meetFromItem(node);
 	}
 
-	public void meet(LabelColumn node) throws X {
-		meetValueColumnBase(node);
-	}
-
-	public void meet(LanguageColumn node) throws X {
-		meetValueColumnBase(node);
-	}
-
-	public void meet(LongLabelColumn node) throws X {
-		meetValueColumnBase(node);
-	}
-
-	public void meet(LongURIColumn node) throws X {
-		meetValueColumnBase(node);
-	}
-
-	public void meet(NumberValue node) throws X {
-		meetSqlConstant(node);
-	}
-
-	public void meet(NumericColumn node) throws X {
-		meetValueColumnBase(node);
-	}
-
-	public void meet(RefIdColumn node) throws X {
-		meetValueColumnBase(node);
-	}
-
-	public void meet(SelectProjection node) throws X {
-		meetNode(node);
-	}
-
-	public void meet(SelectQuery node) throws X {
-		meetNode(node);
-	}
-
-	public void meet(SqlAbs node) throws X {
-		meetUnarySqlOperator(node);
-	}
-
-	public void meet(SqlAnd node) throws X {
-		meetBinarySqlOperator(node);
-	}
-
-	public void meet(SqlCase node) throws X {
-		meetNode(node);
-	}
-
-	public void meet(SqlCompare node) throws X {
-		meetBinarySqlOperator(node);
-	}
-
-	public void meet(SqlConcat node) throws X {
-		meetBinarySqlOperator(node);
-	}
-
-	public void meet(SqlEq node) throws X {
-		meetBinarySqlOperator(node);
-	}
-
-	public void meet(SqlIsNull node) throws X {
-		meetUnarySqlOperator(node);
-	}
-
-	public void meet(SqlLike node) throws X {
-		meetBinarySqlOperator(node);
-	}
-
-	public void meet(SqlLowerCase node) throws X {
-		meetUnarySqlOperator(node);
-	}
-
-	public void meet(SqlMathExpr node) throws X {
-		meetBinarySqlOperator(node);
-	}
-
-	public void meet(SqlNot node) throws X {
-		meetUnarySqlOperator(node);
-	}
-
-	public void meet(SqlNull node) throws X {
-		meetSqlConstant(node);
-	}
-
-	public void meet(SqlOr node) throws X {
-		meetBinarySqlOperator(node);
-	}
-
-	public void meet(SqlRegex node) throws X {
-		meetBinarySqlOperator(node);
-	}
-
-	public void meet(SqlShift node) throws X {
-		meetUnarySqlOperator(node);
-	}
-
-	public void meet(StringValue node) throws X {
-		meetSqlConstant(node);
-	}
-
-	public void meet(TrueValue node) throws X {
-		meetSqlConstant(node);
-	}
-
-	public void meet(UnionItem node) throws X {
+	public void meet(LabelColumn node)
+		throws X
+	{
+		meetValueColumnBase(node);
+	}
+
+	public void meet(LanguageColumn node)
+		throws X
+	{
+		meetValueColumnBase(node);
+	}
+
+	public void meet(LongLabelColumn node)
+		throws X
+	{
+		meetValueColumnBase(node);
+	}
+
+	public void meet(LongURIColumn node)
+		throws X
+	{
+		meetValueColumnBase(node);
+	}
+
+	public void meet(NumberValue node)
+		throws X
+	{
+		meetSqlConstant(node);
+	}
+
+	public void meet(NumericColumn node)
+		throws X
+	{
+		meetValueColumnBase(node);
+	}
+
+	public void meet(RefIdColumn node)
+		throws X
+	{
+		meetValueColumnBase(node);
+	}
+
+	public void meet(SelectProjection node)
+		throws X
+	{
+		meetNode(node);
+	}
+
+	public void meet(SelectQuery node)
+		throws X
+	{
+		meetNode(node);
+	}
+
+	public void meet(SqlAbs node)
+		throws X
+	{
+		meetUnarySqlOperator(node);
+	}
+
+	public void meet(SqlAnd node)
+		throws X
+	{
+		meetBinarySqlOperator(node);
+	}
+
+	public void meet(SqlCase node)
+		throws X
+	{
+		meetNode(node);
+	}
+
+	public void meet(SqlCast node)
+		throws X
+	{
+		meetUnarySqlOperator(node);
+	}
+
+	public void meet(SqlCompare node)
+		throws X
+	{
+		meetBinarySqlOperator(node);
+	}
+
+	public void meet(SqlConcat node)
+		throws X
+	{
+		meetBinarySqlOperator(node);
+	}
+
+	public void meet(SqlEq node)
+		throws X
+	{
+		meetBinarySqlOperator(node);
+	}
+
+	public void meet(SqlIsNull node)
+		throws X
+	{
+		meetUnarySqlOperator(node);
+	}
+
+	public void meet(SqlLike node)
+		throws X
+	{
+		meetBinarySqlOperator(node);
+	}
+
+	public void meet(SqlLowerCase node)
+		throws X
+	{
+		meetUnarySqlOperator(node);
+	}
+
+	public void meet(SqlMathExpr node)
+		throws X
+	{
+		meetBinarySqlOperator(node);
+	}
+
+	public void meet(SqlNot node)
+		throws X
+	{
+		meetUnarySqlOperator(node);
+	}
+
+	public void meet(SqlNull node)
+		throws X
+	{
+		meetSqlConstant(node);
+	}
+
+	public void meet(SqlOr node)
+		throws X
+	{
+		meetBinarySqlOperator(node);
+	}
+
+	public void meet(SqlRegex node)
+		throws X
+	{
+		meetBinarySqlOperator(node);
+	}
+
+	public void meet(SqlShift node)
+		throws X
+	{
+		meetUnarySqlOperator(node);
+	}
+
+	public void meet(StringValue node)
+		throws X
+	{
+		meetSqlConstant(node);
+	}
+
+	public void meet(TrueValue node)
+		throws X
+	{
+		meetSqlConstant(node);
+	}
+
+	public void meet(UnionItem node)
+		throws X
+	{
 		meetFromItem(node);
 	}
 
-	public void meet(URIColumn node) throws X {
-		meetValueColumnBase(node);
-	}
-
-	protected void meetBinarySqlOperator(BinarySqlOperator node) throws X {
-		meetNode(node);
-	}
-
-	protected void meetFromItem(FromItem node) throws X {
-		meetNode(node);
-	}
-
-	protected void meetSqlConstant(SqlConstant<?> node) throws X {
-		meetNode(node);
-	}
-
-	protected void meetSqlExpr(SqlExpr node) throws X {
-		meetNode(node);
-	}
-
-	protected void meetUnarySqlOperator(UnarySqlOperator node) throws X {
-		meetNode(node);
-	}
-
-	protected void meetValueColumnBase(ValueColumnBase node) throws X {
+	public void meet(URIColumn node)
+		throws X
+	{
+		meetValueColumnBase(node);
+	}
+
+	public void meet(SqlMbrContains node) throws X {
+		meetSqlMbrContains(node);
+	}
+
+	protected void meetBinarySqlOperator(BinarySqlOperator node)
+		throws X
+	{
+		meetNode(node);
+	}
+
+	protected void meetFromItem(FromItem node)
+		throws X
+	{
+		meetNode(node);
+	}
+
+	protected void meetSqlConstant(SqlConstant<?> node)
+		throws X
+	{
+		meetNode(node);
+	}
+
+	protected void meetSqlExpr(SqlExpr node)
+		throws X
+	{
+		meetNode(node);
+	}
+
+	protected void meetUnarySqlOperator(UnarySqlOperator node)
+		throws X
+	{
+		meetNode(node);
+	}
+
+	protected void meetValueColumnBase(ValueColumnBase node)
+		throws X
+	{
 		meetSqlExpr(node);
 	}
+	
+	protected void meetSqlMbrContains(SqlMbrContains node) throws X {
+		meetNode(node);
+	}
+
+	public void meet(PointColumn node) throws X {
+		meetNode(node);
+	}
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/base/SqlConstant.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/base/SqlConstant.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/base/SqlConstant.java (revision 85)
@@ -1,71 +1,72 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.algebra.base;
 
 /**
  * A constant SQL value, like a varchar or number.
  * 
  * @author James Leigh
  * 
  */
-public abstract class SqlConstant<T> extends RdbmsQueryModelNodeBase implements
-		SqlExpr {
+public abstract class SqlConstant<T> extends RdbmsQueryModelNodeBase implements SqlExpr {
+
 	private T value;
 
 	public SqlConstant() {
 		super();
 	}
 
 	public SqlConstant(T value) {
 		super();
 		this.value = value;
 	}
 
 	public T getValue() {
 		return value;
 	}
 
 	public void setValue(T value) {
 		this.value = value;
 	}
 
 	@Override
 	public String getSignature() {
 		return super.getSignature() + " " + value;
 	}
 
 	@Override
 	public SqlConstant<T> clone() {
-		SqlConstant<T> clone = (SqlConstant<T>) super.clone();
+		SqlConstant<T> clone = (SqlConstant<T>)super.clone();
 		clone.setValue(value);
 		return clone;
 	}
 
 	@Override
 	public int hashCode() {
 		final int prime = 31;
 		int result = 1;
 		result = prime * result + ((value == null) ? 0 : value.hashCode());
 		return result;
 	}
 
 	@Override
 	public boolean equals(Object obj) {
 		if (this == obj)
 			return true;
 		if (obj == null)
 			return false;
 		if (getClass() != obj.getClass())
 			return false;
-		final SqlConstant other = (SqlConstant) obj;
+		final SqlConstant other = (SqlConstant)obj;
 		if (value == null) {
 			if (other.value != null)
 				return false;
-		} else if (!value.equals(other.value))
+		}
+		else if (!value.equals(other.value))
 			return false;
 		return true;
 	}
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/base/UnarySqlOperator.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/base/UnarySqlOperator.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/base/UnarySqlOperator.java (revision 85)
@@ -1,104 +1,109 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.algebra.base;
 
 import org.openrdf.query.algebra.QueryModelNode;
 import org.openrdf.query.algebra.QueryModelVisitor;
 import org.openrdf.query.algebra.helpers.QueryModelTreePrinter;
 import org.openrdf.sail.rdbms.optimizers.SqlConstantOptimizer;
 
 /**
  * An SQL operator with one argument.
  * 
  * @author James Leigh
  * 
  */
-public abstract class UnarySqlOperator extends RdbmsQueryModelNodeBase
-		implements SqlExpr {
+public abstract class UnarySqlOperator extends RdbmsQueryModelNodeBase implements SqlExpr {
+
 	private SqlExpr arg;
 
 	public UnarySqlOperator() {
 		super();
 	}
 
 	public UnarySqlOperator(SqlExpr arg) {
 		super();
 		setArg(arg);
 	}
 
 	public SqlExpr getArg() {
 		return arg;
 	}
 
 	public void setArg(SqlExpr arg) {
 		this.arg = arg;
 		arg.setParentNode(this);
 	}
 
 	@Override
 	public <X extends Exception> void visitChildren(QueryModelVisitor<X> visitor)
-			throws X {
+		throws X
+	{
 		arg.visit(visitor);
 	}
 
 	@Override
-	public void replaceChildNode(QueryModelNode current,
-			QueryModelNode replacement) {
+	public void replaceChildNode(QueryModelNode current, QueryModelNode replacement) {
 		if (arg == current) {
-			setArg((SqlExpr) replacement);
-		} else {
+			setArg((SqlExpr)replacement);
+		}
+		else {
 			super.replaceChildNode(current, replacement);
 		}
 	}
 
 	@Override
 	public UnarySqlOperator clone() {
-		UnarySqlOperator clone = (UnarySqlOperator) super.clone();
+		UnarySqlOperator clone = (UnarySqlOperator)super.clone();
 		clone.setArg(arg.clone());
 		return clone;
 	}
 
 	@Override
 	public int hashCode() {
 		final int prime = 31;
 		int result = 1;
 		result = prime * result + ((arg == null) ? 0 : arg.hashCode());
 		return result;
 	}
 
 	@Override
 	public boolean equals(Object obj) {
 		if (this == obj)
 			return true;
 		if (obj == null)
 			return false;
 		if (getClass() != obj.getClass())
 			return false;
-		final UnarySqlOperator other = (UnarySqlOperator) obj;
+		final UnarySqlOperator other = (UnarySqlOperator)obj;
 		if (arg == null) {
 			if (other.arg != null)
 				return false;
-		} else if (!arg.equals(other.arg))
+		}
+		else if (!arg.equals(other.arg))
 			return false;
 		return true;
 	}
 
 	@Override
 	public String toString() {
 		QueryModelTreePrinter treePrinter = new QueryModelTreePrinter();
 		UnarySqlOperator clone = this.clone();
-		UnarySqlOperator parent = new UnarySqlOperator(clone){
+		UnarySqlOperator parent = new UnarySqlOperator(clone) {
+
 			@Override
-			public <X extends Exception> void visit(
-					RdbmsQueryModelVisitorBase<X> visitor) throws X {
+			public <X extends Exception> void visit(RdbmsQueryModelVisitorBase<X> visitor)
+				throws X
+			{
 				visitor.meetOther(this);
-			}};
+			}
+		};
 		new SqlConstantOptimizer().optimize(clone);
 		parent.getArg().visit(treePrinter);
 		return treePrinter.getTreeString();
 	}
 
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/base/SqlExprSupport.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/base/SqlExprSupport.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/base/SqlExprSupport.java (revision 85)
@@ -1,204 +1,212 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.algebra.base;
+
+import java.sql.Types;
 
 import org.openrdf.model.URI;
 import org.openrdf.model.vocabulary.XMLSchema;
 import org.openrdf.query.algebra.MathExpr;
 import org.openrdf.query.algebra.Compare.CompareOp;
 import org.openrdf.sail.rdbms.algebra.DoubleValue;
 import org.openrdf.sail.rdbms.algebra.FalseValue;
 import org.openrdf.sail.rdbms.algebra.SqlAbs;
 import org.openrdf.sail.rdbms.algebra.SqlAnd;
 import org.openrdf.sail.rdbms.algebra.SqlCase;
+import org.openrdf.sail.rdbms.algebra.SqlCast;
 import org.openrdf.sail.rdbms.algebra.SqlCompare;
 import org.openrdf.sail.rdbms.algebra.SqlConcat;
 import org.openrdf.sail.rdbms.algebra.SqlEq;
 import org.openrdf.sail.rdbms.algebra.SqlIsNull;
 import org.openrdf.sail.rdbms.algebra.SqlLike;
 import org.openrdf.sail.rdbms.algebra.SqlLowerCase;
 import org.openrdf.sail.rdbms.algebra.SqlMathExpr;
 import org.openrdf.sail.rdbms.algebra.SqlNot;
 import org.openrdf.sail.rdbms.algebra.SqlNull;
 import org.openrdf.sail.rdbms.algebra.SqlOr;
 import org.openrdf.sail.rdbms.algebra.SqlRegex;
 import org.openrdf.sail.rdbms.algebra.StringValue;
 import org.openrdf.sail.rdbms.exceptions.UnsupportedRdbmsOperatorException;
 
 /**
  * Support method to create SQL expressions.
  * 
  * @author James Leigh
  * 
  */
 public class SqlExprSupport {
 
 	public static SqlExpr abs(SqlExpr arg) {
 		return new SqlAbs(arg);
 	}
 
 	public static SqlExpr and(SqlExpr left, SqlExpr right) {
 		return new SqlAnd(left, right);
 	}
 
 	public static SqlExpr cmp(SqlExpr left, CompareOp op, SqlExpr right) {
 		return new SqlCompare(left, op, right);
 	}
 
 	public static SqlExpr coalesce(SqlExpr... exprs) {
 		SqlCase sqlCase = new SqlCase();
 		for (SqlExpr expr : exprs) {
 			sqlCase.when(isNotNull(expr.clone()), expr);
 		}
 		return sqlCase;
 	}
 
 	public static SqlExpr concat(SqlExpr left, SqlExpr right) {
 		return new SqlConcat(left, right);
 	}
 
 	public static SqlExpr eq(SqlExpr left, SqlExpr right) {
 		return new SqlEq(left, right);
 	}
 
 	public static SqlExpr eqComparingNull(SqlExpr left, SqlExpr right) {
 		SqlExpr leftIsNull = isNull(left.clone());
 		SqlExpr rightIsNull = isNull(right.clone());
 		SqlExpr bothNull = and(leftIsNull, rightIsNull);
 		SqlExpr bothNotNull = and(not(leftIsNull), not(rightIsNull));
 		return or(bothNull, and(bothNotNull, eq(left, right)));
 	}
 
 	public static SqlExpr eqIfNotNull(SqlExpr left, SqlExpr right) {
 		SqlExpr leftIsNotNull = isNotNull(left.clone());
 		SqlExpr rightIsNotNull = isNotNull(right.clone());
 		SqlExpr bothNotNull = and(leftIsNotNull, rightIsNotNull);
 		return and(bothNotNull, eq(left, right));
 	}
 
 	public static SqlExpr eqOrBothNull(SqlExpr left, SqlExpr right) {
 		SqlExpr leftIsNull = isNull(left.clone());
 		SqlExpr rightIsNull = isNull(right.clone());
 		SqlExpr bothNull = and(leftIsNull, rightIsNull);
 		return or(bothNull, eq(left, right));
 	}
 
 	public static SqlExpr eqOrSimpleType(SqlExpr left, SqlExpr right) {
 		SqlExpr bothSimple = and(simple(left), simple(right));
 		return or(eq(left.clone(), right.clone()), bothSimple);
 	}
 
 	public static SqlExpr ge(SqlExpr left, SqlExpr right) {
 		return new SqlCompare(left, CompareOp.GE, right);
 	}
 
 	public static SqlExpr gt(SqlExpr left, SqlExpr right) {
 		return new SqlCompare(left, CompareOp.GT, right);
 	}
 
 	public static SqlExpr in(SqlExpr compare, SqlExpr... values) {
 		SqlExpr expr = null;
 		for (SqlExpr value : values) {
 			if (expr == null) {
 				expr = new SqlEq(compare, value);
-			} else {
+			}
+			else {
 				expr = or(expr, new SqlEq(compare.clone(), value));
 			}
 		}
 		if (expr == null)
 			return new FalseValue();
 		return expr;
 	}
 
 	public static SqlExpr isNotNull(SqlExpr arg) {
 		return not(isNull(arg));
 	}
 
 	public static SqlExpr isNull(SqlExpr arg) {
 		return new SqlIsNull(arg);
 	}
 
 	public static SqlExpr le(SqlExpr left, SqlExpr right) {
 		return new SqlCompare(left, CompareOp.LE, right);
 	}
 
 	public static SqlExpr like(SqlExpr left, SqlExpr right) {
 		return new SqlLike(left, right);
 	}
 
 	public static SqlExpr lowercase(SqlExpr arg) {
 		return new SqlLowerCase(arg);
 	}
 
 	public static SqlExpr lt(SqlExpr left, SqlExpr right) {
 		return new SqlCompare(left, CompareOp.LT, right);
 	}
 
 	public static SqlExpr neq(SqlExpr left, SqlExpr right) {
 		return new SqlNot(new SqlEq(left, right));
 	}
 
 	public static SqlExpr neqComparingNull(SqlExpr left, SqlExpr right) {
 		SqlExpr leftIsNull = isNull(left.clone());
 		SqlExpr rightIsNull = isNull(right.clone());
 		SqlExpr onlyLeftIsNull = and(not(leftIsNull), rightIsNull.clone());
 		SqlExpr onlyRightIsNull = and(leftIsNull.clone(), not(rightIsNull));
 		SqlExpr compareNull = or(onlyRightIsNull, onlyLeftIsNull);
 		return or(not(eq(left, right)), compareNull);
 	}
 
 	public static SqlExpr not(SqlExpr arg) {
 		return new SqlNot(arg);
 	}
 
 	public static SqlExpr num(double value) {
 		return new DoubleValue(value);
 	}
 
 	public static SqlExpr or(SqlExpr left, SqlExpr right) {
 		return new SqlOr(left, right);
 	}
 
 	public static SqlExpr regex(SqlExpr value, SqlExpr pattern) {
 		return new SqlRegex(value, pattern);
 	}
 
 	public static SqlExpr regex(SqlExpr value, SqlExpr pattern, SqlExpr flags) {
 		return new SqlRegex(value, pattern, flags);
 	}
 
 	public static SqlExpr simple(SqlExpr arg) {
 		SqlExpr isString = eq(arg.clone(), str(XMLSchema.STRING));
 		return or(isNull(arg.clone()), isString);
 	}
 
 	public static SqlExpr sqlNull() {
 		return new SqlNull();
 	}
 
 	public static SqlExpr str(String str) {
 		if (str == null)
 			return sqlNull();
 		return new StringValue(str);
 	}
 
 	public static SqlExpr str(URI uri) {
 		return new StringValue(uri.stringValue());
 	}
 
 	public static SqlExpr sub(SqlExpr left, SqlExpr right) {
 		return new SqlMathExpr(left, MathExpr.MathOp.MINUS, right);
 	}
 
+	public static SqlExpr text(SqlExpr arg) {
+		return new SqlCast(arg, Types.VARCHAR);
+	}
+
 	public static UnsupportedRdbmsOperatorException unsupported(Object arg) {
 		return new UnsupportedRdbmsOperatorException(arg.toString());
 	}
 
 	private SqlExprSupport() {
 		// no constructor
 	}
 
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/base/SqlExpr.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/base/SqlExpr.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/base/SqlExpr.java (revision 85)
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/LongURIColumn.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/LongURIColumn.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/algebra/LongURIColumn.java (revision 85)
@@ -1,34 +1,35 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.algebra;
 
 import org.openrdf.query.algebra.Var;
 import org.openrdf.sail.rdbms.algebra.base.RdbmsQueryModelVisitorBase;
 import org.openrdf.sail.rdbms.algebra.base.ValueColumnBase;
 
 /**
  * Represents a variable's Long URI value in an SQL expression.
  * 
  * @author James Leigh
  * 
  */
 public class LongURIColumn extends ValueColumnBase {
 
 	public LongURIColumn(Var var) {
 		super(var);
 	}
 
 	public LongURIColumn(ColumnVar var) {
 		super(var);
 	}
 
 	@Override
-	public <X extends Exception> void visit(
-			RdbmsQueryModelVisitorBase<X> visitor) throws X {
+	public <X extends Exception> void visit(RdbmsQueryModelVisitorBase<X> visitor)
+		throws X
+	{
 		visitor.meet(this);
 	}
 
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/iteration/RdbmsBindingIteration.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/iteration/RdbmsBindingIteration.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/iteration/RdbmsBindingIteration.java (revision 85)
@@ -1,101 +1,111 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.iteration;
 
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
 import java.util.Collection;
 
 import org.openrdf.model.Value;
 import org.openrdf.query.BindingSet;
 import org.openrdf.query.QueryEvaluationException;
 import org.openrdf.query.algebra.evaluation.QueryBindingSet;
 import org.openrdf.sail.rdbms.RdbmsValueFactory;
 import org.openrdf.sail.rdbms.algebra.ColumnVar;
 import org.openrdf.sail.rdbms.exceptions.RdbmsQueryEvaluationException;
 import org.openrdf.sail.rdbms.iteration.base.RdbmIterationBase;
 import org.openrdf.sail.rdbms.model.RdbmsResource;
 import org.openrdf.sail.rdbms.model.RdbmsValue;
 import org.openrdf.sail.rdbms.schema.IdSequence;
 import org.openrdf.sail.rdbms.schema.ValueTable;
 
 /**
  * Converts a {@link ResultSet} into a {@link BindingSet} in an iteration.
  * 
  * @author James Leigh
  * 
  */
-public class RdbmsBindingIteration extends
-		RdbmIterationBase<BindingSet, QueryEvaluationException> {
+public class RdbmsBindingIteration extends RdbmIterationBase<BindingSet, QueryEvaluationException> {
+
 	private BindingSet bindings;
 	private Collection<ColumnVar> projections;
 	private RdbmsValueFactory vf;
 	private IdSequence ids;
 
-	public RdbmsBindingIteration(PreparedStatement stmt) throws SQLException {
+	public RdbmsBindingIteration(PreparedStatement stmt)
+		throws SQLException
+	{
 		super(stmt);
 	}
 
 	public void setBindings(BindingSet bindings) {
 		this.bindings = bindings;
 	}
 
 	public void setProjections(Collection<ColumnVar> proj) {
 		this.projections = proj;
 	}
 
 	public void setValueFactory(RdbmsValueFactory vf) {
 		this.vf = vf;
 	}
 
 	public void setIdSequence(IdSequence ids) {
 		this.ids = ids;
 	}
 
 	@Override
-	protected BindingSet convert(ResultSet rs) throws SQLException {
+	protected BindingSet convert(ResultSet rs)
+		throws SQLException
+	{
 		QueryBindingSet result = new QueryBindingSet(bindings);
 		for (ColumnVar var : projections) {
 			String name = var.getName();
 			if (var != null && !result.hasBinding(name)) {
 				Value value = var.getValue();
 				if (value == null) {
 					value = createValue(rs, var.getIndex() + 1);
 				}
 				if (value != null) {
 					result.addBinding(var.getName(), value);
 				}
 			}
 		}
 		return result;
 	}
 
 	@Override
 	protected QueryEvaluationException convertSQLException(SQLException e) {
 		return new RdbmsQueryEvaluationException(e);
 	}
 
 	private RdbmsResource createResource(ResultSet rs, int index)
-			throws SQLException {
+		throws SQLException
+	{
 		Number id = ids.idOf(rs.getLong(index));
 		if (id.longValue() == ValueTable.NIL_ID)
 			return null;
 		return vf.getRdbmsResource(id, rs.getString(index + 1));
 	}
 
-	private RdbmsValue createValue(ResultSet rs, int index) throws SQLException {
+	private RdbmsValue createValue(ResultSet rs, int index)
+		throws SQLException
+	{
 		Number id = ids.idOf(rs.getLong(index));
 		if (ids.isLiteral(id)) {
 			String label = rs.getString(index + 1);
 			String language = rs.getString(index + 2);
 			String datatype = rs.getString(index + 3);
 			return vf.getRdbmsLiteral(id, label, language, datatype);
 		}
 		return createResource(rs, index);
 	}
 
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/iteration/EmptyRdbmsStatementIteration.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/iteration/EmptyRdbmsStatementIteration.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/iteration/EmptyRdbmsStatementIteration.java (revision 85)
@@ -1,33 +1,39 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.iteration;
 
 import java.sql.SQLException;
 
 import org.openrdf.sail.SailException;
 
 /**
  * Empty iteration that extends {@link RdbmsStatementIteration}.
  * 
  * @author James Leigh
  * 
  */
 public class EmptyRdbmsStatementIteration extends RdbmsStatementIteration {
 
-	public EmptyRdbmsStatementIteration() throws SQLException {
+	public EmptyRdbmsStatementIteration()
+		throws SQLException
+	{
 		super(null, null, null);
 	}
 
 	@Override
-	public void close() throws SailException {
+	public void close()
+		throws SailException
+	{
 	}
 
 	@Override
-	public boolean hasNext() throws SailException {
+	public boolean hasNext()
+		throws SailException
+	{
 		return false;
 	}
 
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/iteration/base/RdbmIterationBase.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/iteration/base/RdbmIterationBase.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/iteration/base/RdbmIterationBase.java (revision 85)
@@ -1,79 +1,97 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.iteration.base;
 
-import info.aduna.iteration.CloseableIteration;
-
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
+
+import info.aduna.iteration.CloseableIteration;
 
 /**
  * Base class for Iteration of a {@link ResultSet}.
  * 
  * @author James Leigh
  * 
  */
-public abstract class RdbmIterationBase<T, X extends Exception> implements
-		CloseableIteration<T, X> {
+public abstract class RdbmIterationBase<T, X extends Exception> implements CloseableIteration<T, X> {
+
 	private PreparedStatement stmt;
 	private ResultSet rs;
 	private boolean advanced;
 	private boolean hasNext;
 
-	public RdbmIterationBase(PreparedStatement stmt) throws SQLException {
+	public RdbmIterationBase(PreparedStatement stmt)
+		throws SQLException
+	{
 		super();
 		this.stmt = stmt;
 		if (stmt != null) {
 			this.rs = stmt.executeQuery();
 		}
 	}
 
-	public void close() throws X {
+	public void close()
+		throws X
+	{
 		try {
 			rs.close();
 			stmt.close();
-		} catch (SQLException e) {
+		}
+		catch (SQLException e) {
 			throw convertSQLException(e);
 		}
 	}
 
-	public boolean hasNext() throws X {
+	public boolean hasNext()
+		throws X
+	{
 		if (advanced)
 			return hasNext;
 		advanced = true;
 		try {
 			return hasNext = rs.next();
-		} catch (SQLException e) {
+		}
+		catch (SQLException e) {
 			throw convertSQLException(e);
 		}
 	}
 
-	public T next() throws X {
+	public T next()
+		throws X
+	{
 		try {
 			if (!advanced) {
 				hasNext = rs.next();
 			}
 			advanced = false;
 			return convert(rs);
-		} catch (SQLException e) {
+		}
+		catch (SQLException e) {
 			throw convertSQLException(e);
 		}
 	}
 
-	public void remove() throws X {
+	public void remove()
+		throws X
+	{
 		try {
 			rs.rowDeleted();
-		} catch (SQLException e) {
+		}
+		catch (SQLException e) {
 			throw convertSQLException(e);
 		}
 	}
 
-	protected abstract T convert(ResultSet rs) throws SQLException;
+	protected abstract T convert(ResultSet rs)
+		throws SQLException;
 
 	protected abstract X convertSQLException(SQLException e);
 
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/iteration/NamespaceIteration.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/iteration/NamespaceIteration.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/iteration/NamespaceIteration.java (revision 85)
@@ -1,34 +1,37 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.iteration;
 
+import java.util.Iterator;
+
 import info.aduna.iteration.CloseableIteration;
+import info.aduna.iteration.Iteration;
 import info.aduna.iteration.IteratorIteration;
-
-import java.util.Iterator;
 
 import org.openrdf.model.Namespace;
 import org.openrdf.sail.SailException;
 
 /**
  * {@link Namespace} typed {@link Iteration}.
  * 
  * @author James Leigh
  * 
  */
-public class NamespaceIteration extends
-		IteratorIteration<Namespace, SailException> implements
-		CloseableIteration<Namespace, SailException> {
+public class NamespaceIteration extends IteratorIteration<Namespace, SailException> implements
+		CloseableIteration<Namespace, SailException>
+{
 
 	public NamespaceIteration(Iterator<? extends Namespace> iter) {
 		super(iter);
 	}
 
-	public void close() throws SailException {
+	public void close()
+		throws SailException
+	{
 		// do nothing
 	}
 
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/iteration/RdbmsStatementIteration.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/iteration/RdbmsStatementIteration.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/iteration/RdbmsStatementIteration.java (revision 91)
@@ -1,75 +1,83 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.iteration;
 
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
 
 import org.openrdf.sail.SailException;
 import org.openrdf.sail.rdbms.RdbmsValueFactory;
 import org.openrdf.sail.rdbms.exceptions.RdbmsException;
 import org.openrdf.sail.rdbms.iteration.base.RdbmIterationBase;
 import org.openrdf.sail.rdbms.model.RdbmsResource;
 import org.openrdf.sail.rdbms.model.RdbmsStatement;
 import org.openrdf.sail.rdbms.model.RdbmsURI;
 import org.openrdf.sail.rdbms.model.RdbmsValue;
 import org.openrdf.sail.rdbms.schema.IdSequence;
 import org.openrdf.sail.rdbms.schema.ValueTable;
 
 /**
  * Converts a {@link ResultSet} into a {@link RdbmsStatement} in an iteration.
  * 
  * @author James Leigh
  * 
  */
-public class RdbmsStatementIteration extends
-		RdbmIterationBase<RdbmsStatement, SailException> {
+public class RdbmsStatementIteration extends RdbmIterationBase<RdbmsStatement, SailException> {
+
 	private RdbmsValueFactory vf;
 	private IdSequence ids;
 
 	public RdbmsStatementIteration(RdbmsValueFactory vf, PreparedStatement stmt, IdSequence ids)
-			throws SQLException {
+		throws SQLException
+	{
 		super(stmt);
 		this.vf = vf;
 		this.ids = ids;
 	}
 
 	@Override
-	protected RdbmsStatement convert(ResultSet rs) throws SQLException {
+	protected RdbmsStatement convert(ResultSet rs)
+		throws SQLException
+	{
 		RdbmsResource ctx = createResource(rs, 1);
 		RdbmsResource subj = createResource(rs, 3);
-		RdbmsURI pred = (RdbmsURI) createResource(rs, 5);
+		RdbmsURI pred = (RdbmsURI)createResource(rs, 5);
 		RdbmsValue obj = createValue(rs, 7);
-		return new RdbmsStatement(subj, pred, obj, ctx);
+		boolean explicit = rs.getBoolean(10);
+		return new RdbmsStatement(subj, pred, obj, explicit, ctx);
 	}
 
 	@Override
 	protected RdbmsException convertSQLException(SQLException e) {
 		return new RdbmsException(e);
 	}
 
 	private RdbmsResource createResource(ResultSet rs, int index)
-			throws SQLException {
+		throws SQLException
+	{
 		Number id = ids.idOf(rs.getLong(index));
 		if (id.longValue() == ValueTable.NIL_ID)
 			return null;
 		String stringValue = rs.getString(index + 1);
-		return vf.getRdbmsResource(id, stringValue);
+		/* Fixed to allow for NULL contexts. TODO: Track down where they come from */
+		return (stringValue != null ? vf.getRdbmsResource(id, stringValue) : null);
 	}
 
-	private RdbmsValue createValue(ResultSet rs, int index) throws SQLException {
+	private RdbmsValue createValue(ResultSet rs, int index)
+		throws SQLException
+	{
 		Number id = ids.idOf(rs.getLong(index));
 		if (ids.isLiteral(id)) {
 			String label = rs.getString(index + 1);
 			String datatype = rs.getString(index + 2);
 			String language = rs.getString(index + 3);
 			return vf.getRdbmsLiteral(id, label, language, datatype);
 		}
 		return createResource(rs, index);
 	}
 
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/iteration/EmptyRdbmsResourceIteration.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/iteration/EmptyRdbmsResourceIteration.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/iteration/EmptyRdbmsResourceIteration.java (revision 85)
@@ -1,33 +1,39 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.iteration;
 
 import java.sql.SQLException;
 
 import org.openrdf.sail.SailException;
 
 /**
  * Empty iteration that extends {@link RdbmsResourceIteration}.
  * 
  * @author James Leigh
  * 
  */
 public class EmptyRdbmsResourceIteration extends RdbmsResourceIteration {
 
-	public EmptyRdbmsResourceIteration() throws SQLException {
+	public EmptyRdbmsResourceIteration()
+		throws SQLException
+	{
 		super(null, null);
 	}
 
 	@Override
-	public void close() throws SailException {
+	public void close()
+		throws SailException
+	{
 	}
 
 	@Override
-	public boolean hasNext() throws SailException {
+	public boolean hasNext()
+		throws SailException
+	{
 		return false;
 	}
 
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/iteration/RdbmsResourceIteration.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/iteration/RdbmsResourceIteration.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/iteration/RdbmsResourceIteration.java (revision 85)
@@ -1,45 +1,48 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.iteration;
 
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
 
 import org.openrdf.sail.SailException;
 import org.openrdf.sail.rdbms.RdbmsValueFactory;
 import org.openrdf.sail.rdbms.exceptions.RdbmsException;
 import org.openrdf.sail.rdbms.iteration.base.RdbmIterationBase;
 import org.openrdf.sail.rdbms.model.RdbmsResource;
 
 /**
  * Converts a {@link ResultSet} into a {@link RdbmsResource} in an iteration.
  * 
  * @author James Leigh
  * 
  */
-public class RdbmsResourceIteration extends
-		RdbmIterationBase<RdbmsResource, SailException> {
+public class RdbmsResourceIteration extends RdbmIterationBase<RdbmsResource, SailException> {
+
 	private RdbmsValueFactory vf;
 
 	public RdbmsResourceIteration(RdbmsValueFactory vf, PreparedStatement stmt)
-			throws SQLException {
+		throws SQLException
+	{
 		super(stmt);
 		this.vf = vf;
 	}
 
 	@Override
-	protected RdbmsResource convert(ResultSet rs) throws SQLException {
+	protected RdbmsResource convert(ResultSet rs)
+		throws SQLException
+	{
 		Number id = rs.getLong(0 + 1);
 		return vf.getRdbmsResource(id, rs.getString(0 + 2));
 	}
 
 	@Override
 	protected RdbmsException convertSQLException(SQLException e) {
 		return new RdbmsException(e);
 	}
 
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/RdbmsConnectionFactory.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/RdbmsConnectionFactory.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/RdbmsConnectionFactory.java (revision 85)
@@ -1,363 +1,406 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms;
 
 import static java.sql.Connection.TRANSACTION_READ_COMMITTED;
 
 import java.sql.Connection;
 import java.sql.SQLException;
+import java.util.concurrent.locks.Lock;
+import java.util.concurrent.locks.ReentrantLock;
 
 import javax.sql.DataSource;
 
 import org.openrdf.model.impl.ValueFactoryImpl;
 import org.openrdf.sail.SailConnection;
 import org.openrdf.sail.SailException;
 import org.openrdf.sail.helpers.DefaultSailChangedEvent;
 import org.openrdf.sail.rdbms.evaluation.QueryBuilderFactory;
 import org.openrdf.sail.rdbms.evaluation.RdbmsEvaluationFactory;
 import org.openrdf.sail.rdbms.exceptions.RdbmsException;
 import org.openrdf.sail.rdbms.managers.BNodeManager;
 import org.openrdf.sail.rdbms.managers.HashManager;
 import org.openrdf.sail.rdbms.managers.LiteralManager;
 import org.openrdf.sail.rdbms.managers.NamespaceManager;
 import org.openrdf.sail.rdbms.managers.PredicateManager;
 import org.openrdf.sail.rdbms.managers.TransTableManager;
 import org.openrdf.sail.rdbms.managers.TripleManager;
 import org.openrdf.sail.rdbms.managers.TripleTableManager;
 import org.openrdf.sail.rdbms.managers.UriManager;
 import org.openrdf.sail.rdbms.optimizers.RdbmsQueryOptimizer;
 import org.openrdf.sail.rdbms.optimizers.SelectQueryOptimizerFactory;
 import org.openrdf.sail.rdbms.schema.BNodeTable;
 import org.openrdf.sail.rdbms.schema.HashTable;
 import org.openrdf.sail.rdbms.schema.IdSequence;
 import org.openrdf.sail.rdbms.schema.IntegerIdSequence;
 import org.openrdf.sail.rdbms.schema.LiteralTable;
 import org.openrdf.sail.rdbms.schema.LongIdSequence;
 import org.openrdf.sail.rdbms.schema.NamespacesTable;
 import org.openrdf.sail.rdbms.schema.TableFactory;
 import org.openrdf.sail.rdbms.schema.URITable;
 import org.openrdf.sail.rdbms.schema.ValueTableFactory;
 
 /**
  * Responsible to initialise and wire all components together that will be
  * needed to satisfy any sail connection request.
  * 
  * @author James Leigh
  * 
  */
 public class RdbmsConnectionFactory {
 	private RdbmsStore sail;
 	private DataSource ds;
 	private String user;
 	private String password;
 	private Connection resourceInserts;
 	private Connection literalInserts;
 	private Connection hashLookups;
 	private Connection nsAndTableIndexes;
 	private NamespaceManager namespaces;
 	private TripleTableManager tripleTableManager;
 	private HashManager hashManager;
 	private RdbmsValueFactory vf;
 	private UriManager uriManager;
 	private BNodeManager bnodeManager;
 	private LiteralManager literalManager;
 	private PredicateManager predicateManager;
 	private int maxTripleTables;
 	private boolean triplesIndexed = true;
 	private boolean sequenced;
 	private HashTable hashTable;
 	private URITable uriTable;
 	private BNodeTable bnodeTable;
 	private LiteralTable literalTable;
 	private IdSequence ids;
+	private final Lock lock = new ReentrantLock(); 
 
 	public void setSail(RdbmsStore sail) {
 		this.sail = sail;
 	}
 
 	public DataSource getDataSource() {
 		return ds;
 	}
 
 	public void setDataSource(DataSource ds) {
 		this.ds = ds;
 	}
 
 	public void setDataSource(DataSource ds, String user, String password) {
 		this.ds = ds;
 		this.user = user;
 		this.password = password;
 	}
 
 	public int getMaxNumberOfTripleTables() {
 		return maxTripleTables;
 	}
 
 	public void setMaxNumberOfTripleTables(int max) {
 		maxTripleTables = max;
 	}
 
 	public boolean isSequenced() {
 		return sequenced || hashManager != null;
 	}
 
 	public void setSequenced(boolean useSequence) {
 		this.sequenced = useSequence;
 	}
 
 	public boolean isTriplesIndexed() {
 		return triplesIndexed;
 	}
 
 	public void setTriplesIndexed(boolean triplesIndexed)
 		throws SailException
 	{
 		this.triplesIndexed = triplesIndexed;
 		if (tripleTableManager != null) {
 			try {
 				if (triplesIndexed) {
 					tripleTableManager.createTripleIndexes();
 				}
 				else {
 					tripleTableManager.dropTripleIndexes();
 				}
 			}
 			catch (SQLException e) {
 				throw new RdbmsException(e);
 			}
 		}
 	}
 
 	public RdbmsValueFactory getValueFactory() {
 		return vf;
 	}
 
-	public void init() throws SailException {
+	public void init()
+		throws SailException
+	{
 		try {
 			nsAndTableIndexes = getConnection();
 			resourceInserts = getConnection();
 			literalInserts = getConnection();
 			nsAndTableIndexes.setAutoCommit(true);
 			resourceInserts.setAutoCommit(true);
 			literalInserts.setAutoCommit(true);
 			bnodeManager = new BNodeManager();
 			uriManager = new UriManager();
 			literalManager = new LiteralManager();
 			ValueTableFactory tables = createValueTableFactory();
 			tables.setSequenced(sequenced);
 			if (sequenced) {
 				ids = new IntegerIdSequence();
 				tables.setIdSequence(ids);
 				hashLookups = getConnection();
 				hashLookups.setAutoCommit(true);
 				hashManager = new HashManager();
 				hashTable = tables.createHashTable(hashLookups, hashManager.getQueue());
 				ids.setHashTable(hashTable);
 				ids.init();
 				hashManager.setHashTable(hashTable);
 				hashManager.setBNodeManager(bnodeManager);
 				hashManager.setLiteralManager(literalManager);
 				hashManager.setUriManager(uriManager);
 				hashManager.setIdSequence(ids);
 				hashManager.init();
-			} else {
+			}
+			else {
 				ids = new LongIdSequence();
 				ids.init();
 				tables.setIdSequence(ids);
 			}
 			namespaces = new NamespaceManager();
 			namespaces.setConnection(resourceInserts);
 			NamespacesTable nsTable = tables.createNamespacesTable(nsAndTableIndexes);
 			nsTable.initialize();
 			namespaces.setNamespacesTable(nsTable);
 			namespaces.initialize();
 			bnodeManager.setHashManager(hashManager);
 			bnodeManager.setIdSequence(ids);
 			uriManager.setHashManager(hashManager);
 			uriManager.setIdSequence(ids);
 			bnodeTable = tables.createBNodeTable(resourceInserts, bnodeManager.getQueue());
 			uriTable = tables.createURITable(resourceInserts, uriManager.getQueue());
 			literalManager.setHashManager(hashManager);
 			literalManager.setIdSequence(ids);
 			literalTable = tables.createLiteralTable(literalInserts, literalManager.getQueue());
 			literalTable.setIdSequence(ids);
 			vf = new RdbmsValueFactory();
 			vf.setDelegate(ValueFactoryImpl.getInstance());
 			vf.setIdSequence(ids);
 			uriManager.setUriTable(uriTable);
 			uriManager.init();
 			predicateManager = new PredicateManager();
 			predicateManager.setUriManager(uriManager);
 			tripleTableManager = new TripleTableManager(tables);
 			tripleTableManager.setConnection(nsAndTableIndexes);
 			tripleTableManager.setIdSequence(ids);
 			tripleTableManager.setBNodeManager(bnodeManager);
 			tripleTableManager.setUriManager(uriManager);
 			tripleTableManager.setLiteralManager(literalManager);
 			tripleTableManager.setHashManager(hashManager);
 			tripleTableManager.setPredicateManager(predicateManager);
 			tripleTableManager.setMaxNumberOfTripleTables(maxTripleTables);
 			tripleTableManager.setIndexingTriples(triplesIndexed);
 			tripleTableManager.initialize();
 			if (triplesIndexed) {
 				tripleTableManager.createTripleIndexes();
 			}
 			else {
 				tripleTableManager.dropTripleIndexes();
 			}
 			bnodeManager.setTable(bnodeTable);
 			bnodeManager.init();
 			vf.setBNodeManager(bnodeManager);
 			vf.setURIManager(uriManager);
 			literalManager.setTable(literalTable);
 			literalManager.init();
 			vf.setLiteralManager(literalManager);
 			vf.setPredicateManager(predicateManager);
-		} catch (SQLException e) {
+		}
+		catch (SQLException e) {
 			throw new RdbmsException(e);
 		}
 	}
 
-	public boolean isWritable() throws SailException {
+	public boolean isWritable()
+		throws SailException
+	{
 		try {
 			return !nsAndTableIndexes.isReadOnly();
-		} catch (SQLException e) {
+		}
+		catch (SQLException e) {
 			throw new RdbmsException(e);
 		}
 	}
 
-	public SailConnection createConnection() throws SailException {
+	public SailConnection createConnection()
+		throws SailException
+	{
 		try {
 			Connection db = getConnection();
 			db.setAutoCommit(true);
 			if (db.getTransactionIsolation() != TRANSACTION_READ_COMMITTED) {
 				db.setTransactionIsolation(TRANSACTION_READ_COMMITTED);
 			}
 			TripleManager tripleManager = new TripleManager();
 			RdbmsTripleRepository s = new RdbmsTripleRepository();
 			s.setTripleManager(tripleManager);
 			s.setValueFactory(vf);
 			s.setConnection(db);
 			s.setBNodeTable(bnodeTable);
 			s.setURITable(uriTable);
 			s.setLiteralTable(literalTable);
 			s.setIdSequence(ids);
 			DefaultSailChangedEvent sailChangedEvent = new DefaultSailChangedEvent(sail);
 			s.setSailChangedEvent(sailChangedEvent);
 			TableFactory tables = createTableFactory();
 			TransTableManager trans = createTransTableManager();
 			trans.setIdSequence(ids);
 			tripleManager.setTransTableManager(trans);
 			trans.setBatchQueue(tripleManager.getQueue());
 			trans.setSailChangedEvent(sailChangedEvent);
 			trans.setConnection(db);
 			trans.setTemporaryTableFactory(tables);
 			trans.setStatementsTable(tripleTableManager);
 			trans.setFromDummyTable(getFromDummyTable());
 			trans.initialize();
 			s.setTransaction(trans);
 			QueryBuilderFactory bfactory = createQueryBuilderFactory();
 			bfactory.setValueFactory(vf);
 			bfactory.setUsingHashTable(hashManager != null);
 			s.setQueryBuilderFactory(bfactory);
 			RdbmsConnection conn = new RdbmsConnection(sail, s);
 			conn.setNamespaces(namespaces);
 			RdbmsEvaluationFactory efactory = new RdbmsEvaluationFactory();
 			efactory.setQueryBuilderFactory(bfactory);
 			efactory.setRdbmsTripleRepository(s);
 			efactory.setIdSequence(ids);
 			conn.setRdbmsEvaluationFactory(efactory);
 			RdbmsQueryOptimizer optimizer = createOptimizer();
 			SelectQueryOptimizerFactory selectOptimizerFactory = createSelectQueryOptimizerFactory();
 			selectOptimizerFactory.setTransTableManager(trans);
 			selectOptimizerFactory.setValueFactory(vf);
 			selectOptimizerFactory.setIdSequence(ids);
 			optimizer.setSelectQueryOptimizerFactory(selectOptimizerFactory);
 			optimizer.setValueFactory(vf);
 			optimizer.setBnodeTable(bnodeTable);
 			optimizer.setUriTable(uriTable);
 			optimizer.setLiteralTable(literalTable);
 			optimizer.setHashTable(hashTable);
 			conn.setRdbmsQueryOptimizer(optimizer);
+			conn.setLock(lock);
 			return conn;
-		} catch (SQLException e) {
+		}
+		catch (SQLException e) {
 			throw new RdbmsException(e);
 		}
 	}
 
-	public void shutDown() throws SailException {
+	public void shutDown()
+		throws SailException
+	{
 		try {
 			if (tripleTableManager != null) {
 				tripleTableManager.close();
 			}
 			if (uriManager != null) {
 				uriManager.close();
 			}
 			if (bnodeManager != null) {
 				bnodeManager.close();
 			}
 			if (literalManager != null) {
 				literalManager.close();
 			}
 			if (hashManager != null) {
 				hashManager.close();
 			}
 			if (resourceInserts != null) {
 				resourceInserts.close();
 				resourceInserts = null;
 			}
 			if (literalInserts != null) {
 				literalInserts.close();
 				literalInserts = null;
 			}
 			if (hashLookups != null) {
 				hashLookups.close();
 				hashLookups = null;
 			}
 			if (nsAndTableIndexes != null) {
 				nsAndTableIndexes.close();
 				nsAndTableIndexes = null;
 			}
-		} catch (SQLException e) {
+		}
+		catch (SQLException e) {
 			throw new RdbmsException(e);
 		}
 	}
 
 	protected QueryBuilderFactory createQueryBuilderFactory() {
 		return new QueryBuilderFactory();
 	}
 
 	protected ValueTableFactory createValueTableFactory() {
 		return new ValueTableFactory(createTableFactory());
 	}
 
 	protected TableFactory createTableFactory() {
 		return new TableFactory();
 	}
 
 	protected TransTableManager createTransTableManager() {
 		return new TransTableManager();
 	}
 
 	protected RdbmsQueryOptimizer createOptimizer() {
 		return new RdbmsQueryOptimizer();
 	}
 
 	protected SelectQueryOptimizerFactory createSelectQueryOptimizerFactory() {
 		return new SelectQueryOptimizerFactory();
 	}
 
 	protected String getFromDummyTable() {
 		return "FROM DUAL";
 	}
 
-	protected Connection getConnection() throws SQLException {
+	protected Connection getConnection()
+		throws SQLException
+	{
 		if (user == null)
 			return ds.getConnection();
 		return ds.getConnection(user, password);
 	}
 
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/model/RdbmsBNode.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/model/RdbmsBNode.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/model/RdbmsBNode.java (revision 85)
@@ -1,54 +1,57 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.model;
 
 import org.openrdf.model.BNode;
+import org.openrdf.model.impl.BNodeImpl;
 
 /**
  * Wraps a {@link BNodeImpl} providing an internal id and version.
  * 
  * @author James Leigh
  * 
  */
 public class RdbmsBNode extends RdbmsResource implements BNode {
 	private static final long serialVersionUID = 861142250999359435L;
 	private BNode bnode;
 
 	public RdbmsBNode(BNode bnode) {
 		this.bnode = bnode;
 	}
 
 	public RdbmsBNode(Number id, Integer version, BNode bnode) {
 		super(id, version);
 		this.bnode = bnode;
 	}
 
 	public String getID() {
 		return bnode.getID();
 	}
 
 	public String stringValue() {
 		return bnode.stringValue();
 	}
 
 	@Override
 	public String toString() {
 		return bnode.toString();
 	}
 
 	@Override
 	public boolean equals(Object o) {
 		if (this == o)
 			return true;
 		return bnode.equals(o);
 	}
 
 	@Override
 	public int hashCode() {
 		return bnode.hashCode();
 	}
 
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/model/RdbmsResource.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/model/RdbmsResource.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/model/RdbmsResource.java (revision 85)
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/model/RdbmsLiteral.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/model/RdbmsLiteral.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/model/RdbmsLiteral.java (revision 85)
@@ -1,105 +1,119 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.model;
 
 import java.math.BigDecimal;
 import java.math.BigInteger;
 
 import javax.xml.datatype.XMLGregorianCalendar;
 
 import org.openrdf.model.Literal;
 import org.openrdf.model.URI;
+import org.openrdf.model.impl.LiteralImpl;
 
 /**
  * Wraps a {@link LiteralImpl} providing an internal id and version.
  * 
  * @author James Leigh
  *
  */
 public class RdbmsLiteral extends RdbmsValue implements Literal {
 	private static final long serialVersionUID = -8213249522968522279L;
 	private Literal lit;
+	private URI predicate = null;
 
-	public RdbmsLiteral(Literal lit) {
+	public RdbmsLiteral(Literal lit, URI predicate) {
 		this.lit = lit;
+		this.predicate = predicate;
 	}
 
-	public RdbmsLiteral(Number id, Integer version, Literal lit) {
+	public RdbmsLiteral(Number id, Integer version, Literal lit, URI predicate) {
 		super(id, version);
 		this.lit = lit;
+		this.predicate = predicate;
 	}
 
 	public boolean booleanValue() {
 		return lit.booleanValue();
 	}
 
 	public byte byteValue() {
 		return lit.byteValue();
 	}
 
 	public XMLGregorianCalendar calendarValue() {
 		return lit.calendarValue();
 	}
 
 	public BigDecimal decimalValue() {
 		return lit.decimalValue();
 	}
 
 	public double doubleValue() {
 		return lit.doubleValue();
 	}
 
 	public float floatValue() {
 		return lit.floatValue();
 	}
 
 	public URI getDatatype() {
 		return lit.getDatatype();
+	}
+
+	public URI getPredicate() {
+		return predicate;
+	}
+
+	public void setPredicate(URI predicate) {
+		this.predicate = predicate;
 	}
 
 	public String getLabel() {
 		return lit.getLabel();
 	}
 
 	public String getLanguage() {
 		return lit.getLanguage();
 	}
 
 	public BigInteger integerValue() {
 		return lit.integerValue();
 	}
 
 	public int intValue() {
 		return lit.intValue();
 	}
 
 	public long longValue() {
 		return lit.longValue();
 	}
 
 	public short shortValue() {
 		return lit.shortValue();
 	}
 
 	public String stringValue() {
 		return lit.stringValue();
 	}
 
 	@Override
 	public String toString() {
 		return lit.toString();
 	}
 
 	@Override
 	public boolean equals(Object other) {
 		return lit.equals(other);
 	}
 
 	@Override
 	public int hashCode() {
 		return lit.hashCode();
 	}
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/model/RdbmsValue.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/model/RdbmsValue.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/model/RdbmsValue.java (revision 85)
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/model/RdbmsURI.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/model/RdbmsURI.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/model/RdbmsURI.java (revision 85)
@@ -1,58 +1,61 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.model;
 
 import org.openrdf.model.URI;
+import org.openrdf.model.impl.URIImpl;
 
 /**
  * Wraps a {@link URIImpl} providing an internal id and version.
  * 
  * @author James Leigh
  *
  */
- public class RdbmsURI extends RdbmsResource implements URI {
+public class RdbmsURI extends RdbmsResource implements URI {
+
 	private static final long serialVersionUID = 3317398596013196032L;
 	private URI uri;
 
 	public RdbmsURI(URI uri) {
 		this.uri = uri;
 	}
 
 	public RdbmsURI(Number id, Integer version, URI uri) {
 		super(id, version);
 		this.uri = uri;
 	}
 
 	public String getLocalName() {
 		return uri.getLocalName();
 	}
 
 	public String getNamespace() {
 		return uri.getNamespace();
 	}
 
 	public String stringValue() {
 		return uri.stringValue();
 	}
 
 	@Override
 	public String toString() {
 		return uri.toString();
 	}
 
 	@Override
 	public boolean equals(Object o) {
 		if (this == o)
 			return true;
 		return uri.equals(o);
 	}
 
 	@Override
 	public int hashCode() {
 		return uri.hashCode();
 	}
 
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/model/RdbmsStatement.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/model/RdbmsStatement.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/model/RdbmsStatement.java (revision 85)
@@ -1,48 +1,59 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.model;
 
 import org.openrdf.model.impl.ContextStatementImpl;
 
 /**
  * Rdbms typed statement.
  * 
  * @author James Leigh
  * 
  */
 public class RdbmsStatement extends ContextStatementImpl {
 	private static final long serialVersionUID = -5970166748706214658L;
 
-	public RdbmsStatement(RdbmsResource subject, RdbmsURI predicate, RdbmsValue object) {
-		this(subject, predicate, object, null);
+	private boolean explicit;
+	
+	public RdbmsStatement(RdbmsResource subject, RdbmsURI predicate, RdbmsValue object, boolean explicit) {
+		this(subject, predicate, object, explicit, null);
 	}
 
 	public RdbmsStatement(RdbmsResource subject, RdbmsURI predicate, RdbmsValue object,
-			RdbmsResource context) {
+			boolean explicit, RdbmsResource context) {
 		super(subject, predicate, object, context);
+		setExplicit(explicit);
 	}
 
 	@Override
 	public RdbmsResource getSubject() {
-		return (RdbmsResource) super.getSubject();
+		return (RdbmsResource)super.getSubject();
 	}
 
 	@Override
 	public RdbmsURI getPredicate() {
-		return (RdbmsURI) super.getPredicate();
+		return (RdbmsURI)super.getPredicate();
 	}
 
 	@Override
 	public RdbmsValue getObject() {
-		return (RdbmsValue) super.getObject();
+		return (RdbmsValue)super.getObject();
 	}
 
 	@Override
 	public RdbmsResource getContext() {
-		return (RdbmsResource) super.getContext();
+		return (RdbmsResource)super.getContext();
+	}
+	
+	public boolean isExplicit() {
+		return explicit;
 	}
 
+	public void setExplicit(boolean explicit) {
+		this.explicit = explicit;
+	}	
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/schema/BNodeTable.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/schema/BNodeTable.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/schema/BNodeTable.java (revision 85)
@@ -1,53 +1,61 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.schema;
 
 import java.sql.SQLException;
 
 /**
  * Manages the rows in the BNode table.
  * 
  * @author James Leigh
  * 
  */
 public class BNodeTable {
 	private ValueTable table;
 
 	public BNodeTable(ValueTable table) {
 		super();
 		this.table = table;
 	}
 
-	public void close() throws SQLException {
+	public void close()
+		throws SQLException
+	{
 		table.close();
 	}
 
 	public String getName() {
 		return table.getName();
 	}
 
 	public int getBatchSize() {
 		return table.getBatchSize();
 	}
 
-	public void insert(Number id, String value) throws SQLException, InterruptedException {
+	public void insert(Number id, String value)
+		throws SQLException, InterruptedException
+	{
 		table.insert(id, value);
 	}
 
-	public boolean expungeRemovedStatements(int count, String condition)
-			throws SQLException {
-		return table.expungeRemovedStatements(count, condition);
+	public boolean expunge(String condition)
+		throws SQLException
+	{
+		return table.expunge(condition);
 	}
 
 	@Override
 	public String toString() {
 		return getName();
 	}
 
-	public void optimize() throws SQLException {
+	public void optimize()
+		throws SQLException
+	{
 		table.optimize();
 	}
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/schema/ValueTypes.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/schema/ValueTypes.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/schema/ValueTypes.java (revision 85)
@@ -1,122 +1,133 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.schema;
 
 
 /**
  * A bit array of the possible value types that have been stored in an object
  * column.
  * 
  * @author James Leigh
  * 
  */
 public class ValueTypes implements Cloneable {
 	public static ValueTypes UNKNOWN = new ValueTypes();
 	static {
 		UNKNOWN.bnodes = true;
 		UNKNOWN.uris = true;
 		UNKNOWN.literals = true;
 		UNKNOWN.typed = true;
 		UNKNOWN.numeric = true;
 		UNKNOWN.calendar = true;
 		UNKNOWN.languages = true;
 		UNKNOWN.longValues = true;
 	}
 	public static ValueTypes RESOURCE = new ValueTypes();
 	static {
 		RESOURCE.bnodes = true;
 		RESOURCE.uris = true;
 		RESOURCE.longValues = true;
 	}
 	public static ValueTypes URI = new ValueTypes();
 	static {
 		URI.uris = true;
 		URI.longValues = true;
 	}
 	private boolean bnodes;
 	private boolean uris;
 	private boolean literals;
 	private boolean typed;
 	private boolean numeric;
 	private boolean calendar;
 	private boolean languages;
 	private boolean longValues;
 
 	public boolean isBNodes() {
 		return bnodes;
 	}
 
 	public boolean isURIs() {
 		return uris;
 	}
 
 	public boolean isLiterals() {
 		return literals;
 	}
 
 	public boolean isTyped() {
 		return typed;
 	}
 
 	public boolean isNumeric() {
 		return numeric;
 	}
 
 	public boolean isCalendar() {
 		return calendar;
 	}
 
 	public boolean isLanguages() {
 		return languages;
 	}
 
 	public boolean isLong() {
 		return longValues;
 	}
 
 	public void reset() {
 		bnodes = false;
 		uris = false;
 		literals = false;
 		typed = false;
 		numeric = false;
 		calendar = false;
 		languages = false;
 		longValues = false;
 	}
 
 	public void add(ValueType code) {
 		bnodes |= code.isBNode();
 		uris |= code.isURI();
 		literals |= code.isLiteral();
 		typed |= code.isTypedLiteral();
 		numeric |= code.isNumericLiteral();
 		calendar |= code.isCalendarLiteral();
 		languages |= code.isLanguageLiteral();
 		longValues |= code.isLong();
 	}
 
 	public ValueTypes merge(ValueTypes valueTypes) {
 		bnodes |= valueTypes.bnodes;
 		uris |= valueTypes.uris;
 		literals |= valueTypes.literals;
 		typed |= valueTypes.typed;
 		numeric |= valueTypes.numeric;
 		calendar |= valueTypes.calendar;
 		languages |= valueTypes.languages;
 		longValues |= valueTypes.longValues;
 		return this;
 	}
 
 	@Override
 	public ValueTypes clone() {
 		try {
-			return (ValueTypes) super.clone();
-		} catch (CloneNotSupportedException e) {
+			return (ValueTypes)super.clone();
+		}
+		catch (CloneNotSupportedException e) {
 			throw new AssertionError();
 		}
 	}
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/schema/IntegerIdSequence.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/schema/IntegerIdSequence.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/schema/IntegerIdSequence.java (revision 85)
@@ -1,84 +1,84 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.schema;
 
 import java.sql.SQLException;
 import java.sql.Types;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
 import java.util.concurrent.atomic.AtomicInteger;
 
 import org.openrdf.model.Value;
 
 
 /**
  *
  * @author James Leigh
  */
 public class IntegerIdSequence extends IdSequence {
 
 	private int SPAN = 268435455;
 
 	private int SHIFT = Long.toBinaryString(SPAN).length();
 
 	private Number[] minIds;
 
 	private ConcurrentMap<ValueType, AtomicInteger> seq = new ConcurrentHashMap<ValueType, AtomicInteger>();
 
 	public int getShift() {
 		return SHIFT;
 	}
 
 	public int getJdbcIdType() {
 		return Types.INTEGER;
 	}
 
 	public String getSqlType() {
 		return "INTEGER";
 	}
 
 	public void init()
 		throws SQLException
 	{
 		minIds = new Number[ValueType.values().length];
 		for (int i = 0; i < minIds.length; i++) {
 			minIds[i] = i * (SPAN + 1);
 		}
 		if (getHashTable() != null) {
 			for (Number max : getHashTable().maxIds(getShift(), getMod())) {
 				ValueType code = valueOf(max);
 				if (max.intValue() > minId(code).intValue()) {
 					seq.put(code, new AtomicInteger(max.intValue()));
 				}
 			}
 		}
 	}
 
 	public Number idOf(Number number) {
 		return number.intValue();
 	}
 
 	public Number maxId(ValueType type) {
 		return minId(type).intValue() + SPAN;
 	}
 
 	public Number minId(ValueType type) {
 		return minIds[type.index()];
 	}
 
 	public Number nextId(Value value) {
 		ValueType code = valueOf(value);
 		if (!seq.containsKey(code)) {
 			seq.putIfAbsent(code, new AtomicInteger(minId(code).intValue()));
 		}
-		return seq.get(code).incrementAndGet();
+		int id = seq.get(code).incrementAndGet();
+		return id;
 	}
 
 	@Override
 	protected int shift(Number id) {
 		return id.intValue() >>> SHIFT;
 	}
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/schema/LiteralTable.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/schema/LiteralTable.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/schema/LiteralTable.java (revision 85)
@@ -1,152 +1,190 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.schema;
 
 import java.sql.SQLException;
 
 /**
  * A Facade to the five literal value tables. Which are labels, languages,
  * datatypes, numeric values, and dateTime values.
  * 
  * @author James Leigh
  * 
  */
 public class LiteralTable {
 	public static final boolean ONLY_INSERT_LABEL = false;
 
 	private ValueTable labels;
 	private ValueTable longLabels;
 	private ValueTable languages;
 	private ValueTable datatypes;
 	private ValueTable numeric;
 	private ValueTable dateTime;
+
+	private ValueTable point;
+
 	private int version;
 	private IdSequence ids;
 
 	public void setIdSequence(IdSequence ids) {
 		this.ids = ids;
 	}
 
 	public ValueTable getLabelTable() {
 		return labels;
 	}
 
 	public void setLabelTable(ValueTable labels) {
 		this.labels = labels;
 	}
 
 	public ValueTable getLongLabelTable() {
 		return longLabels;
 	}
 
 	public void setLongLabelTable(ValueTable longLabels) {
 		this.longLabels = longLabels;
 	}
 
 	public ValueTable getLanguageTable() {
 		return languages;
 	}
 
 	public void setLanguageTable(ValueTable languages) {
 		this.languages = languages;
 	}
 
 	public ValueTable getDatatypeTable() {
 		return datatypes;
 	}
 
 	public void setDatatypeTable(ValueTable datatypes) {
 		this.datatypes = datatypes;
 	}
 
 	public ValueTable getNumericTable() {
 		return numeric;
 	}
 
 	public void setNumericTable(ValueTable numeric) {
 		this.numeric = numeric;
 	}
 
 	public ValueTable getDateTimeTable() {
 		return dateTime;
 	}
 
 	public void setDateTimeTable(ValueTable dateTime) {
 		this.dateTime = dateTime;
 	}
 
-	public void close() throws SQLException {
+	public ValueTable getPointTable() {
+		return point;
+	}
+
+	public void setPointTable(ValueTable point) {
+		this.point = point;
+	}
+
+	public void close()
+		throws SQLException
+	{
 		labels.close();
 		longLabels.close();
 		languages.close();
 		datatypes.close();
 		numeric.close();
 		dateTime.close();
+		point.close();
 	}
 
 	public int getBatchSize() {
 		return labels.getBatchSize();
 	}
 
 	public int getIdVersion() {
 		return version;
 	}
 
-	public void insertSimple(Number id, String label) throws SQLException, InterruptedException {
+	public void insertSimple(Number id, String label)
+		throws SQLException, InterruptedException
+	{
 		if (ids.isLong(id)) {
 			longLabels.insert(id, label);
-		} else {
+		}
+		else {
 			labels.insert(id, label);
 		}
 	}
 
 	public void insertLanguage(Number id, String label, String language)
-			throws SQLException, InterruptedException {
+		throws SQLException, InterruptedException
+	{
 		insertSimple(id, label);
 		languages.insert(id, language);
 	}
 
 	public void insertDatatype(Number id, String label, String datatype)
-			throws SQLException, InterruptedException {
+		throws SQLException, InterruptedException
+	{
 		insertSimple(id, label);
 		datatypes.insert(id, datatype);
 	}
 
-	public void insertNumeric(Number id, String label, String datatype,
-			double value) throws SQLException, InterruptedException {
+	public void insertNumeric(Number id, String label, String datatype, double value)
+		throws SQLException, InterruptedException
+	{
 		labels.insert(id, label);
 		datatypes.insert(id, datatype);
 		numeric.insert(id, value);
 	}
 
-	public void insertDateTime(Number id, String label, String datatype,
-			long value) throws SQLException, InterruptedException {
+	public void insertDateTime(Number id, String label, String datatype, long value)
+		throws SQLException, InterruptedException
+	{
 		labels.insert(id, label);
 		datatypes.insert(id, datatype);
 		dateTime.insert(id, value);
 	}
 
-	public void optimize() throws SQLException {
+	public void insertPoint(Number id, String label, String value) throws SQLException, InterruptedException {
+		labels.insert(id, label);
+		point.insert(id, value);
+	}
+	
+	public void optimize()
+		throws SQLException
+	{
 		labels.optimize();
 		longLabels.optimize();
 		languages.optimize();
 		datatypes.optimize();
 		numeric.optimize();
 		dateTime.optimize();
+		point.optimize();
 	}
 
-	public boolean expungeRemovedStatements(int count, String condition)
-			throws SQLException {
+	public boolean expunge(String condition)
+		throws SQLException
+	{
 		boolean bool = false;
-		bool |= labels.expungeRemovedStatements(count, condition);
-		bool |= longLabels.expungeRemovedStatements(count, condition);
-		bool |= languages.expungeRemovedStatements(count, condition);
-		bool |= datatypes.expungeRemovedStatements(count, condition);
-		bool |= numeric.expungeRemovedStatements(count, condition);
-		bool |= dateTime.expungeRemovedStatements(count, condition);
+		bool |= labels.expunge(condition);
+		bool |= longLabels.expunge(condition);
+		bool |= languages.expunge(condition);
+		bool |= datatypes.expunge(condition);
+		bool |= numeric.expunge(condition);
+		bool |= dateTime.expunge(condition);
+		bool |= point.expunge(condition);
 		return bool;
 	}
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/schema/LongIdSequence.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/schema/LongIdSequence.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/schema/LongIdSequence.java (revision 85)
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/schema/URITable.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/schema/URITable.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/schema/URITable.java (revision 85)
@@ -1,73 +1,85 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.schema;
 
 import java.sql.SQLException;
 
 /**
  * Manages the rows in the URI table.
  * 
  * @author James Leigh
  * 
  */
 public class URITable {
 	private ValueTable shorter;
 	private ValueTable longer;
 	private int version;
 
 	public URITable(ValueTable shorter, ValueTable longer) {
 		super();
 		this.shorter = shorter;
 		this.longer = longer;
 	}
 
-	public void close() throws SQLException {
+	public void close()
+		throws SQLException
+	{
 		shorter.close();
 		longer.close();
 	}
 
 	public int getBatchSize() {
 		return shorter.getBatchSize();
 	}
 
 	public int getVersion() {
 		return version;
 	}
 
 	public String getShortTableName() {
 		return shorter.getName();
 	}
 
 	public String getLongTableName() {
 		return longer.getName();
 	}
 
-	public void insertShort(Number id, String value) throws SQLException, InterruptedException {
+	public void insertShort(Number id, String value)
+		throws SQLException, InterruptedException
+	{
 		shorter.insert(id, value);
 	}
 
-	public void insertLong(Number id, String value) throws SQLException, InterruptedException {
+	public void insertLong(Number id, String value)
+		throws SQLException, InterruptedException
+	{
 		longer.insert(id, value);
 	}
 
-	public boolean expungeRemovedStatements(int count, String condition)
-			throws SQLException {
+	public boolean expunge(String condition)
+		throws SQLException
+	{
 		boolean bool = false;
-		bool |= shorter.expungeRemovedStatements(count, condition);
-		bool |= longer.expungeRemovedStatements(count, condition);
+		bool |= shorter.expunge(condition);
+		bool |= longer.expunge(condition);
 		return bool;
 	}
 
 	@Override
 	public String toString() {
 		return shorter.getName() + " UNION ALL " + longer.getName();
 	}
 
-	public void optimize() throws SQLException {
+	public void optimize()
+		throws SQLException
+	{
 		shorter.optimize();
 		longer.optimize();
 	}
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/schema/TripleTable.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/schema/TripleTable.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/schema/TripleTable.java (revision 85)
@@ -1,218 +1,259 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.schema;
 
 import java.sql.SQLException;
 import java.util.List;
 import java.util.Map;
 
 /**
  * Manages the life-cycle of the rows in a single predicate table.
  * 
  * @author James Leigh
  * 
  */
 public class TripleTable {
 	public static int tables_created;
 	public static int total_st;
 	public static final boolean UNIQUE_INDEX_TRIPLES = true;
-	private static final String[] PKEY = { "obj", "subj", "ctx" };
+
+	private static final String[] PKEY = { "obj", "subj", "ctx", "expl" };
+
 	private static final String[] SUBJ_INDEX = { "subj" };
 	private static final String[] CTX_INDEX = { "ctx" };
-	private static final String[] PRED_PKEY = { "obj", "subj", "pred", "ctx" };
+
+	private static final String[] PRED_PKEY = { "obj", "subj", "pred", "ctx", "expl" };
+
 	private static final String[] PRED_INDEX = { "pred" };
+
+	private static final String[] EXPL_INDEX = { "expl" };
+
 	private RdbmsTable table;
 	private ValueTypes objTypes = new ValueTypes();
 	private ValueTypes subjTypes = new ValueTypes();
 	private boolean initialize;
 	private boolean predColumnPresent;
 	private boolean indexed;
 	private IdSequence ids;
 
 	public TripleTable(RdbmsTable table) {
 		this.table = table;
 	}
 
 	public void setIdSequence(IdSequence ids) {
 		this.ids = ids;
 	}
 
 	public boolean isPredColumnPresent() {
 		return predColumnPresent;
 	}
 
 	public void setPredColumnPresent(boolean present) {
 		predColumnPresent = present;
 	}
 
 	public void setIndexed(boolean indexingTriples) {
 		indexed = true;
 	}
 
-	public synchronized void initTable() throws SQLException {
+	public synchronized void initTable()
+		throws SQLException
+	{
 		if (initialize)
 			return;
 		table.createTransactionalTable(buildTableColumns());
 		tables_created++;
 		total_st++;
 		if (UNIQUE_INDEX_TRIPLES) {
 			if (isPredColumnPresent()) {
-				table.index(PRED_PKEY);
+				table.primaryIndex(PRED_PKEY);
 				total_st++;
-			} else {
-				table.index(PKEY);
+			}
+			else {
+				table.primaryIndex(PKEY);
 				total_st++;
 			}
 		}
 		if (indexed) {
 			createIndex();
 		}
 		initialize = true;
 	}
 
-	public void reload() throws SQLException {
+	public void reload()
+		throws SQLException
+	{
 		table.count();
 		if (table.size() > 0) {
 			ValueType[] values = ValueType.values();
 			String[] OBJ_CONTAINS = new String[values.length];
 			String[] SUBJ_CONTAINS = new String[values.length];
 			StringBuilder sb = new StringBuilder();
 			for (int i = 0, n = values.length; i < n; i++) {
 				sb.delete(0, sb.length());
 				ValueType code = values[i];
 				sb.append("MAX(CASE WHEN obj BETWEEN ").append(ids.minId(code));
 				sb.append(" AND ").append(ids.maxId(code));
 				sb.append(" THEN 1 ELSE 0 END)");
 				OBJ_CONTAINS[i] = sb.toString();
 				sb.delete(0, sb.length());
 				sb.append("MAX(CASE WHEN subj BETWEEN ").append(ids.minId(code));
 				sb.append(" AND ").append(ids.maxId(code));
 				sb.append(" THEN 1 ELSE 0 END)");
 				SUBJ_CONTAINS[i] = sb.toString();
 			}
-			int[] aggregate = table.aggregate(OBJ_CONTAINS);
-			for (int i = 0; i < aggregate.length; i++) {
-				if (aggregate[i] == 1) {
-					objTypes.add(values[i]);
-				}
-			}
-			aggregate = table.aggregate(SUBJ_CONTAINS);
-			for (int i = 0; i < aggregate.length; i++) {
-				if (aggregate[i] == 1) {
-					subjTypes.add(values[i]);
-				}
-			}
-		
-		}
+//			int[] aggregate = table.aggregate(OBJ_CONTAINS);
+//			for (int i = 0; i < aggregate.length; i++) {
+//				if (aggregate[i] == 1) {
+//					objTypes.add(values[i]);
+//				}
+//			}
+//			aggregate = table.aggregate(SUBJ_CONTAINS);
+//			for (int i = 0; i < aggregate.length; i++) {
+//				if (aggregate[i] == 1) {
+//					subjTypes.add(values[i]);
+//				}
+//			}
+			for (int i = 0; i < values.length; i++) {
+				objTypes.add(values[i]);
+				subjTypes.add(values[i]);
+			}
+		}
+
 		initialize = true;
 	}
 
 	public void close()
 		throws SQLException
 	{
 		table.close();
 	}
 
 	public boolean isIndexed()
 		throws SQLException
 	{
 		return table.getIndexes().size() > 1;
 	}
 
 	public void createIndex()
 		throws SQLException
 	{
 		if (isPredColumnPresent()) {
 			table.index(PRED_INDEX);
 			total_st++;
 		}
 		table.index(SUBJ_INDEX);
 		total_st++;
 		table.index(CTX_INDEX);
 		total_st++;
+		table.index(EXPL_INDEX);
+		total_st++;
 	}
 
 	public void dropIndex()
 		throws SQLException
 	{
 		for (Map.Entry<String, List<String>> e : table.getIndexes().entrySet()) {
 			if (!e.getValue().contains("OBJ") && !e.getValue().contains("obj")) {
 				table.dropIndex(e.getKey());
 			}
 		}
 	}
 
 	public boolean isReady() {
 		return initialize;
 	}
 
-	public void blockUntilReady() throws SQLException {
+	public void blockUntilReady()
+		throws SQLException
+	{
 		if (initialize)
 			return;
 		initTable();
 	}
 
-	public String getName() throws SQLException {
+	public String getName()
+		throws SQLException
+	{
 		return table.getName();
 	}
 
-	public String getNameWhenReady() throws SQLException {
+	public String getNameWhenReady()
+		throws SQLException
+	{
 		blockUntilReady();
 		return table.getName();
 	}
 
 	public ValueTypes getObjTypes() {
 		return objTypes;
 	}
 
 	public void setObjTypes(ValueTypes valueTypes) {
 		this.objTypes.merge(valueTypes);
 	}
 
 	public ValueTypes getSubjTypes() {
 		return subjTypes;
 	}
 
 	public void setSubjTypes(ValueTypes valueTypes) {
 		this.subjTypes.merge(valueTypes);
 	}
 
-	public void modified(int addedCount, int removedCount) throws SQLException {
+	public void modified(int addedCount, int removedCount)
+		throws SQLException
+	{
 		blockUntilReady();
 		table.modified(addedCount, removedCount);
 		table.optimize();
 		if (isEmpty()) {
 			objTypes.reset();
 			subjTypes.reset();
 		}
 	}
 
-	public boolean isEmpty() throws SQLException {
+	public boolean isEmpty()
+		throws SQLException
+	{
 		blockUntilReady();
 		return table.size() == 0;
 	}
 
 	@Override
 	public String toString() {
 		return table.getName();
 	}
 
-	public void drop() throws SQLException {
+	public void drop()
+		throws SQLException
+	{
 		blockUntilReady();
 		table.drop();
 	}
 
 	protected CharSequence buildTableColumns() {
 		StringBuilder sb = new StringBuilder();
 		sb.append("  ctx ").append(ids.getSqlType()).append(" NOT NULL,\n");
 		sb.append("  subj ").append(ids.getSqlType()).append(" NOT NULL,\n");
 		if (isPredColumnPresent()) {
 			sb.append("  pred ").append(ids.getSqlType()).append(" NOT NULL,\n");
 		}
-		sb.append("  obj ").append(ids.getSqlType()).append(" NOT NULL\n");
+		sb.append("  obj ").append(ids.getSqlType()).append(" NOT NULL,\n");
+		sb.append("  expl ").append("BOOL").append(" NOT NULL\n");
 		return sb;
 	}
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/schema/ValueTableFactory.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/schema/ValueTableFactory.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/schema/ValueTableFactory.java (revision 85)
@@ -1,141 +1,182 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.schema;
 
 import static java.sql.Types.BIGINT;
 import static java.sql.Types.DOUBLE;
 import static java.sql.Types.LONGVARCHAR;
 import static java.sql.Types.VARCHAR;
 
 import java.sql.Connection;
 import java.sql.SQLException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
 import java.util.concurrent.BlockingQueue;
 
 /**
  * Factory class used to create or load the database tables.
  * 
  * @author James Leigh
  * 
  */
 public class ValueTableFactory {
 	private static final int VCS = 127;
 	private static final int VCL = 255;
-	public static final boolean INDEX_VALUES = false;
+
+	public static final int POINT_TYPE = 511;
+	public static final List<Integer> INDEX_VALUES = Arrays.asList(POINT_TYPE);
+
 	protected static final String LANGUAGES = "LANGUAGES";
 	protected static final String NAMESPACES = "NAMESPACE_PREFIXES";
 	protected static final String RESOURCES = "RESOURCES";
 	protected static final String BNODE_VALUES = "BNODE_VALUES";
 	protected static final String URI_VALUES = "URI_VALUES";
 	protected static final String LURI_VALUES = "LONG_URI_VALUES";
 	protected static final String LBS = "LABEL_VALUES";
 	protected static final String LLBS = "LONG_LABEL_VALUES";
 	protected static final String LANGS = "LANGUAGE_VALUES";
 	protected static final String DTS = "DATATYPE_VALUES";
 	protected static final String NUM_VALUES = "NUMERIC_VALUES";
 	protected static final String TIMES = "DATETIME_VALUES";
 	protected static final String HASH_TABLE = "HASH_VALUES";
+
+	protected static final String POINTS = "POINT_VALUES";
+
 	private TableFactory factory;
 	private IdSequence ids;
 	private boolean sequenced;
 
 	public ValueTableFactory(TableFactory factory) {
 		super();
 		this.factory = factory;
 	}
 
 	public void setIdSequence(IdSequence ids) {
 		this.ids = ids;
 	}
 
 	public void setSequenced(boolean sequenced) {
 		this.sequenced = sequenced;
 	}
 
-	public HashTable createHashTable(Connection conn, BlockingQueue<Batch> queue) throws SQLException {
+	public HashTable createHashTable(Connection conn, BlockingQueue<Batch> queue)
+		throws SQLException
+	{
 		ValueTable table = newValueTable();
 		table.setRdbmsTable(createTable(conn, HASH_TABLE));
-		//table.setTemporaryTable(factory.createTemporaryTable(conn, "INSERT_" + HASH_TABLE));
+		// table.setTemporaryTable(factory.createTemporaryTable(conn, "INSERT_" +
+		// HASH_TABLE));
 		initValueTable(table, queue, BIGINT, -1, true);
 		HashTable hashTable = newHashtable(table);
 		hashTable.init();
 		return hashTable;
 	}
 
 	public NamespacesTable createNamespacesTable(Connection conn) {
 		return new NamespacesTable(createTable(conn, NAMESPACES));
 	}
 
-	public BNodeTable createBNodeTable(Connection conn, BlockingQueue<Batch> queue) throws SQLException {
+	public BNodeTable createBNodeTable(Connection conn, BlockingQueue<Batch> queue)
+		throws SQLException
+	{
 		ValueTable table = createValueTable(conn, queue, BNODE_VALUES, VARCHAR, VCS);
 		return new BNodeTable(table);
 	}
 
-	public URITable createURITable(Connection conn, BlockingQueue<Batch> queue) throws SQLException {
+	public URITable createURITable(Connection conn, BlockingQueue<Batch> queue)
+		throws SQLException
+	{
 		ValueTable shorter = createValueTable(conn, queue, URI_VALUES, VARCHAR, VCL);
 		ValueTable longer = createValueTable(conn, queue, LURI_VALUES, LONGVARCHAR);
 		return new URITable(shorter, longer);
 	}
 
-	public LiteralTable createLiteralTable(Connection conn, BlockingQueue<Batch> queue) throws SQLException {
+	public LiteralTable createLiteralTable(Connection conn, BlockingQueue<Batch> queue)
+		throws SQLException
+	{
 		ValueTable lbs = createValueTable(conn, queue, LBS, VARCHAR, VCL);
 		ValueTable llbs = createValueTable(conn, queue, LLBS, LONGVARCHAR);
 		ValueTable lgs = createValueTable(conn, queue, LANGS, VARCHAR, VCS);
 		ValueTable dt = createValueTable(conn, queue, DTS, VARCHAR, VCL);
 		ValueTable num = createValueTable(conn, queue, NUM_VALUES, DOUBLE);
 		ValueTable dateTime = createValueTable(conn, queue, TIMES, BIGINT);
+		ValueTable point = createValueTable(conn, queue, POINTS, POINT_TYPE);
 		LiteralTable literals = new LiteralTable();
 		literals.setLabelTable(lbs);
 		literals.setLongLabelTable(llbs);
 		literals.setLanguageTable(lgs);
 		literals.setDatatypeTable(dt);
 		literals.setNumericTable(num);
 		literals.setDateTimeTable(dateTime);
+		literals.setPointTable(point);
 		return literals;
 	}
 
 	public TripleTable createTripleTable(Connection conn, String tableName) {
 		RdbmsTable table = createTable(conn, tableName);
 		return new TripleTable(table);
 	}
 
 	protected RdbmsTable createTable(Connection conn, String name) {
 		return factory.createTable(conn, name);
 	}
 
-	protected ValueTable createValueTable(Connection conn, BlockingQueue<Batch> queue, String name, int sqlType) throws SQLException {
+	protected ValueTable createValueTable(Connection conn, BlockingQueue<Batch> queue, String name, int sqlType)
+		throws SQLException
+	{
 		return createValueTable(conn, queue, name, sqlType, -1);
 	}
 
-	protected ValueTable createValueTable(Connection conn, BlockingQueue<Batch> queue, String name, int sqlType,
-			int length) throws SQLException {
+	protected ValueTable createValueTable(Connection conn, BlockingQueue<Batch> queue, String name,
+			int sqlType, int length)
+		throws SQLException
+	{
 		ValueTable table = newValueTable();
 		table.setRdbmsTable(createTable(conn, name));
 		if (!sequenced) {
 			table.setTemporaryTable(factory.createTemporaryTable(conn, "INSERT_" + name));
 		}
-		initValueTable(table, queue, sqlType, length, INDEX_VALUES);
+		initValueTable(table, queue, sqlType, length, INDEX_VALUES.contains(sqlType));
 		return table;
 	}
 
 	protected HashTable newHashtable(ValueTable table) {
 		return new HashTable(table);
 	}
 
 	protected ValueTable newValueTable() {
 		return new ValueTable();
 	}
 
-	private void initValueTable(ValueTable table, BlockingQueue<Batch> queue, int sqlType, int length, boolean indexValues)
+	private void initValueTable(ValueTable table, BlockingQueue<Batch> queue, int sqlType, int length,
+			boolean indexValues)
 		throws SQLException
 	{
 		table.setQueue(queue);
 		table.setSqlType(sqlType);
 		table.setIdType(ids.getJdbcIdType());
 		table.setLength(length);
 		table.setIndexingValues(indexValues);
 		table.initialize();
 	}
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/schema/ValueType.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/schema/ValueType.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/schema/ValueType.java (revision 85)
@@ -1,70 +1,83 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.schema;
 
 import java.util.Arrays;
 
 /**
  * Indicates the different type of internal id used within the store and some
  * basic properties.
  * 
  * @author James Leigh
  * 
  */
 public enum ValueType {
 	// 0000 0010 0011 0100 0101 0110 0111 1000 1001 1010 1011 1100 1101
-	URI, URI_LONG, BNODE, SIMPLE, SIMPLE_LONG, TYPED, TYPED_LONG, NUMERIC, DATETIME, DATETIME_ZONED, LANG, LANG_LONG, XML, B14, B15, B16;
+	URI,
+	URI_LONG,
+	BNODE,
+	SIMPLE,
+	SIMPLE_LONG,
+	TYPED,
+	TYPED_LONG,
+	NUMERIC,
+	DATETIME,
+	DATETIME_ZONED,
+	LANG,
+	LANG_LONG,
+	XML,
+	B14,
+	B15,
+	B16;
 
 	private int index;
 	static {
 		for (ValueType type : values()) {
 			type.index = Arrays.asList(values()).indexOf(type);
 		}
 	}
 
 	public int index() {
 		return index;
 	}
 
 	public boolean isBNode() {
 		return BNODE.equals(this);
 	}
 
 	public boolean isURI() {
 		return URI.equals(this) || URI_LONG.equals(this);
 	}
 
 	public boolean isLiteral() {
-		return !BNODE.equals(this) && !URI.equals(this)
-				&& !URI_LONG.equals(this);
+		return !BNODE.equals(this) && !URI.equals(this) && !URI_LONG.equals(this);
 	}
 
 	public boolean isSimpleLiteral() {
 		return SIMPLE.equals(this) || SIMPLE_LONG.equals(this);
 	}
 
 	public boolean isLanguageLiteral() {
 		return LANG.equals(this) || LANG_LONG.equals(this);
 	}
 
 	public boolean isTypedLiteral() {
 		return isLiteral() && !isSimpleLiteral() && !isLanguageLiteral();
 	}
 
 	public boolean isNumericLiteral() {
 		return NUMERIC.equals(this);
 	}
 
 	public boolean isCalendarLiteral() {
 		return DATETIME.equals(this) || DATETIME_ZONED.equals(this);
 	}
 
 	public boolean isLong() {
-		return URI_LONG.equals(this) || SIMPLE_LONG.equals(this)
-				|| LANG_LONG.equals(this) || TYPED_LONG.equals(this)
-				|| XML.equals(this);
+		return URI_LONG.equals(this) || SIMPLE_LONG.equals(this) || LANG_LONG.equals(this)
+				|| TYPED_LONG.equals(this) || XML.equals(this);
 	}
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/schema/TableFactory.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/schema/TableFactory.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/schema/TableFactory.java (revision 85)
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/schema/RdbmsTable.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/schema/RdbmsTable.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/schema/RdbmsTable.java (revision 90)
@@ -1,400 +1,493 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.schema;
 
 import java.sql.Connection;
 import java.sql.DatabaseMetaData;
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
 import java.sql.Statement;
 import java.sql.Types;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 /**
  * Represents and controls the underlying database table.
  * 
  * @author James Leigh
  * 
  */
 public class RdbmsTable {
 	public static int total_opt;
 	public static int MAX_DELTA_TO_FORCE_OPTIMIZE = 10000;
 	private static final String[] TYPE_TABLE = new String[] { "TABLE" };
 	private Logger logger = LoggerFactory.getLogger(RdbmsTable.class);
 	private int addedCount;
 	private Connection conn;
 	private String name;
 	private int removedCount;
 	private long rowCount;
 	private PreparedStatement clear;
 
 	public RdbmsTable(String name) {
 		super();
 		this.name = name;
 	}
 
 	public void setConnection(Connection conn) {
 		this.conn = conn;
 	}
 
-	public void close() throws SQLException {
+	public void close()
+		throws SQLException
+	{
 		if (clear != null) {
 			clear.close();
 		}
 	}
 
 	public long size() {
 		assert rowCount >= 0 : rowCount;
 		return rowCount;
 	}
 
-	public void clear() throws SQLException {
+	public void clear()
+		throws SQLException
+	{
 		if (clear == null) {
 			clear = conn.prepareStatement(buildClear());
 		}
 		clear.execute();
 		rowCount = 0;
 	}
 
-	public void createTable(CharSequence columns) throws SQLException {
+	public void createTable(CharSequence columns)
+		throws SQLException
+	{
 		execute(buildCreateTable(columns));
 		rowCount = 0;
 	}
 
-	public void createTransactionalTable(CharSequence columns) throws SQLException {
+	public void createTransactionalTable(CharSequence columns)
+		throws SQLException
+	{
 		execute(buildCreateTransactionalTable(columns));
 		rowCount = 0;
 	}
 
-	public void createTemporaryTable(CharSequence columns) throws SQLException {
+	public void createTemporaryTable(CharSequence columns)
+		throws SQLException
+	{
 		try {
 			execute(buildCreateTemporaryTable(columns));
-		} catch (SQLException e) {
+		}
+		catch (SQLException e) {
 			// must already exist
 		}
 	}
 
-	public void execute(String command) throws SQLException {
+	public void execute(String command)
+		throws SQLException
+	{
 		if (command != null) {
 			Statement st = conn.createStatement();
 			try {
 				st.execute(command);
-			} catch (SQLException e) {
+			}
+			catch (SQLException e) {
 				logger.warn(e.getMessage() + '\n' + command);
 				throw e;
-			} finally {
+			}
+			finally {
 				st.close();
 			}
 		}
 	}
 
 	public int executeUpdate(String command, Object... parameters)
-			throws SQLException {
+		throws SQLException
+	{
 		PreparedStatement st = conn.prepareStatement(command);
 		try {
 			for (int i = 0; i < parameters.length; i++) {
 				if (parameters[i] == null) {
 					st.setNull(i + 1, Types.VARCHAR);
-				} else {
+				}
+				else {
 					st.setObject(i + 1, parameters[i]);
 				}
 			}
 			return st.executeUpdate();
-		} catch (SQLException e) {
+		}
+		catch (SQLException e) {
 			logger.warn(e.getMessage() + '\n' + command);
 			throw e;
-		} finally {
+		}
+		finally {
 			st.close();
 		}
 	}
 
 	public String getCatalog() {
 		return null;
 	}
 
 	public String getName() {
 		return name;
 	}
 
 	public String getSchema() {
 		return null;
 	}
 
-	public void index(String... columns) throws SQLException {
+	public void primaryIndex(String... columns)
+		throws SQLException
+	{
+		execute(buildPrimaryIndex(columns));
+	}
+
+	public void index(String... columns)
+		throws SQLException
+	{
+		index(0, columns);
+	}
+	
+	public void index(int sqlType, String... columns) throws SQLException {
 		if (columns.length == 1 && columns[0].equalsIgnoreCase("value")
-				&& getName().toUpperCase().contains("LONG_")) {
-			execute(buildLongIndex(columns));
-		} else {
-			execute(buildIndex(columns));
-		}
-	}
-
-	public void dropIndex(String name) throws SQLException {
+				&& getName().toUpperCase().contains("LONG_"))
+		{
+			execute(buildLongIndex(sqlType, columns));
+		}
+		else {
+			execute(buildIndex(sqlType, columns));
+		}
+	}
+
+	public void dropIndex(String name)
+		throws SQLException
+	{
 		execute(buildDropIndex(name));
 	}
 
-	public boolean isCreated() throws SQLException {
+	public boolean isCreated()
+		throws SQLException
+	{
 		DatabaseMetaData metaData = conn.getMetaData();
 		String c = getCatalog();
 		String s = getSchema();
 		String n = getName();
 		ResultSet tables = metaData.getTables(c, s, n, TYPE_TABLE);
 		try {
 			return tables.next();
-		} finally {
+		}
+		finally {
 			tables.close();
 		}
 	}
 
-	public Map<String, List<String>> getIndexes() throws SQLException {
+	public Map<String, List<String>> getIndexes()
+		throws SQLException
+	{
 		DatabaseMetaData metaData = conn.getMetaData();
 		String c = getCatalog();
 		String s = getSchema();
 		String n = getName();
 		ResultSet indexes = metaData.getIndexInfo(c, s, n, false, false);
 		try {
-			Map<String, List<String>> names = new HashMap<String,List<String>>();
-			while(indexes.next()) {
+			Map<String, List<String>> names = new HashMap<String, List<String>>();
+			while (indexes.next()) {
 				String index = indexes.getString(6);
 				String column = indexes.getString(9);
 				List<String> columns = names.get(index);
 				if (columns == null) {
 					names.put(index, columns = new ArrayList<String>());
 				}
 				columns.add(column);
 			}
 			return names;
-		} finally {
+		}
+		finally {
 			indexes.close();
 		}
 	}
 
-	public long count() throws SQLException {
+	public long count()
+		throws SQLException
+	{
 		StringBuilder sb = new StringBuilder();
 		sb.append("SELECT COUNT(*)\n");
 		sb.append("FROM ").append(name);
 		String query = sb.toString();
 		Statement st = conn.createStatement();
 		try {
 			ResultSet rs = st.executeQuery(query);
 			try {
 				if (rs.next()) {
 					rowCount = rs.getLong(1);
 					assert rowCount >= 0 : rowCount;
 					return rowCount;
 				}
 				return 0;
-			} finally {
+			}
+			finally {
 				rs.close();
 			}
-		} finally {
+		}
+		finally {
 			st.close();
 		}
 	}
 
-	public void modified(int inserted, int deleted) throws SQLException {
+	public void modified(int inserted, int deleted)
+		throws SQLException
+	{
 		if (inserted < 1 && deleted < 1)
 			return;
 		addedCount += inserted;
 		removedCount += deleted;
 		rowCount += inserted - deleted;
 		assert rowCount >= 0 : rowCount;
 	}
 
-	public void optimize() throws SQLException {
-		if (optimize(addedCount + removedCount, rowCount)) {
+	public void optimize()
+		throws SQLException
+	{
+		if (optimize(addedCount + removedCount, rowCount)
+				&& null == System.getProperty("org.openrdf.sail.rdbms.schema.RdbmsTable.nooptimize")) {
 			execute(buildOptimize());
 			addedCount = removedCount = 0;
 			total_opt += 1;
 		}
 	}
 
-	public PreparedStatement prepareStatement(String sql) throws SQLException {
+	public PreparedStatement prepareStatement(String sql)
+		throws SQLException
+	{
 		return conn.prepareStatement(sql);
 	}
 
-	public void rollback() throws SQLException {
+	public void rollback()
+		throws SQLException
+	{
 		conn.rollback();
 	}
 
-	public List<Object[]> select(String... columns) throws SQLException {
+	public List<Object[]> select(String... columns)
+		throws SQLException
+	{
 		StringBuilder sb = new StringBuilder();
 		for (String column : columns) {
 			if (sb.length() == 0) {
 				sb.append("SELECT ");
-			} else {
+			}
+			else {
 				sb.append(", ");
 			}
 			sb.append(column);
 		}
 		sb.append("\nFROM ").append(name);
 		String query = sb.toString();
 		List<Object[]> result = new ArrayList<Object[]>();
 		Statement st = conn.createStatement();
 		try {
 			ResultSet rs = st.executeQuery(query);
 			try {
 				int columnCount = rs.getMetaData().getColumnCount();
 				while (rs.next()) {
 					Object[] row = new Object[columnCount];
 					for (int i = 0; i < row.length; i++) {
 						row[i] = rs.getObject(i + 1);
 					}
 					result.add(row);
 				}
 				rowCount = result.size();
 				assert rowCount >= 0 : rowCount;
 				return result;
-			} finally {
+			}
+			finally {
 				rs.close();
 			}
-		} finally {
+		}
+		finally {
 			st.close();
 		}
 	}
 
-	public int[] aggregate(String... expressions) throws SQLException {
+	public int[] aggregate(String... expressions)
+		throws SQLException
+	{
 		StringBuilder sb = new StringBuilder();
 		sb.append("SELECT COUNT(*)");
 		for (String expression : expressions) {
 			sb.append(", ").append(expression);
 		}
 		sb.append("\nFROM ").append(name);
 		String query = sb.toString();
 		Statement st = conn.createStatement();
 		try {
 			ResultSet rs = st.executeQuery(query);
 			try {
 				if (!rs.next())
 					throw new AssertionError();
 				int columnCount = rs.getMetaData().getColumnCount();
 				int[] result = new int[columnCount - 1];
 				for (int i = 0; i < result.length; i++) {
 					result[i] = rs.getInt(i + 2);
 				}
 				rowCount = rs.getLong(1);
 				assert rowCount >= 0 : rowCount;
 				return result;
-			} finally {
+			}
+			finally {
 				rs.close();
 			}
-		} finally {
+		}
+		finally {
 			st.close();
 		}
 	}
 
 	protected boolean optimize(int delta, long rowCount) {
 		if (delta > MAX_DELTA_TO_FORCE_OPTIMIZE)
 			return true;
 		return delta != 0 && rowCount / delta <= 2;
 	}
 
 	protected String buildClear() {
 		return "DELETE FROM " + name;
 	}
 
 	protected String buildCreateTable(CharSequence columns) {
 		StringBuilder sb = new StringBuilder();
 		sb.append("CREATE TABLE ").append(name);
 		sb.append(" (\n").append(columns).append(")");
 		return sb.toString();
 	}
 
 	protected String buildCreateTransactionalTable(CharSequence columns) {
 		return buildCreateTable(columns);
 	}
 
 	protected String buildCreateTemporaryTable(CharSequence columns) {
 		StringBuilder sb = new StringBuilder();
 		sb.append("CREATE TEMPORARY TABLE ").append(name);
 		sb.append(" (\n").append(columns).append(")");
 		return sb.toString();
 	}
 
-	protected String buildIndex(String... columns) {
+	protected String buildPrimaryIndex(String... columns) {
+		StringBuilder sb = new StringBuilder();
+		sb.append("ALTER TABLE ");
+		sb.append(getName());
+		sb.append(" ADD PRIMARY KEY (");
+		for (int i = 0; i < columns.length; i++) {
+			if (i > 0) {
+				sb.append(", ");
+			}
+			sb.append(columns[i]);
+		}
+		sb.append(")");
+		return sb.toString();
+	}
+
+	protected String buildIndex(int sqlType, String... columns) {
 		StringBuilder sb = new StringBuilder();
 		sb.append("CREATE INDEX ").append(buildIndexName(columns));
 		sb.append(" ON ").append(name).append(" (");
 		for (int i = 0; i < columns.length; i++) {
 			if (i > 0) {
 				sb.append(", ");
 			}
 			sb.append(columns[i]);
 		}
 		sb.append(")");
 		return sb.toString();
 	}
 
-	protected String buildLongIndex(String... columns) {
-		return buildIndex(columns);
+	protected String buildLongIndex(int sqlType, String... columns) {
+		return buildIndex(sqlType, columns);
 	}
 
 	protected String buildDropIndex(String name) {
 		StringBuilder sb = new StringBuilder();
 		sb.append("DROP INDEX ").append(name);
 		return sb.toString();
 	}
 
 	/**
-	 * Creates an index name based on the name of the columns and table that
-	 * it's supposed to index.
+	 * Creates an index name based on the name of the columns and table that it's
+	 * supposed to index.
 	 */
 	protected String buildIndexName(String... columns) {
 		StringBuffer sb = new StringBuffer(32);
 		sb.append(getName()).append("_").append(columns[0]);
 		for (int i = 1; i < columns.length; i++) {
 			sb.append("_").append(columns[i]);
 		}
 		sb.append("_idx");
 		return sb.toString();
 	}
 
-	protected String buildOptimize() throws SQLException {
+	protected String buildOptimize()
+		throws SQLException
+	{
 		// There is no default for this in SQL92.
 		return null;
 	}
 
 	@Override
 	public int hashCode() {
 		final int prime = 31;
 		int result = 1;
 		result = prime * result + ((name == null) ? 0 : name.hashCode());
 		return result;
 	}
 
 	@Override
 	public boolean equals(Object obj) {
 		if (this == obj)
 			return true;
 		if (obj == null)
 			return false;
 		if (!(obj instanceof RdbmsTable))
 			return false;
-		final RdbmsTable other = (RdbmsTable) obj;
+		final RdbmsTable other = (RdbmsTable)obj;
 		if (name == null) {
 			if (other.name != null)
 				return false;
-		} else if (!name.equals(other.name))
+		}
+		else if (!name.equals(other.name))
 			return false;
 		return true;
 	}
 
-	public void drop() throws SQLException {
+	public void drop()
+		throws SQLException
+	{
 		execute("DROP TABLE " + name);
 	}
 
 	@Override
 	public String toString() {
 		return getName();
 	}
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/schema/Batch.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/schema/Batch.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/schema/Batch.java (revision 85)
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/schema/ValueTable.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/schema/ValueTable.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/schema/ValueTable.java (revision 85)
@@ -1,324 +1,355 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.schema;
 
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
 import java.sql.Types;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.concurrent.BlockingQueue;
 
 /**
  * Manages the rows in a value table. These tables have two columns: an internal
  * id column and a value column.
  * 
  * @author James Leigh
  * 
  */
 public class ValueTable {
 	public static int BATCH_SIZE = 8 * 1024;
 	public static final long NIL_ID = 0; // TODO
 	private static final String[] PKEY = { "id" };
 	private static final String[] VALUE_INDEX = { "value" };
 	private int length = -1;
 	private int sqlType;
 	private int idType;
 	private String INSERT;
 	private String INSERT_SELECT;
 	private String EXPUNGE;
 	private RdbmsTable table;
 	private RdbmsTable temporary;
-	private int removedStatementsSinceExpunge;
+
 	private ValueBatch batch;
 	private BlockingQueue<Batch> queue;
 	private boolean indexingValues;
 	private PreparedStatement insertSelect;
 
 	public void setQueue(BlockingQueue<Batch> queue) {
 		this.queue = queue;
 	}
 
 	public boolean isIndexingValues() {
 		return indexingValues;
 	}
 
 	public void setIndexingValues(boolean indexingValues) {
 		this.indexingValues = indexingValues;
 	}
 
 	public int getLength() {
 		return length;
 	}
 
 	public void setLength(int length) {
 		this.length = length;
 	}
 
 	public int getSqlType() {
 		return sqlType;
 	}
 
 	public void setSqlType(int sqlType) {
 		this.sqlType = sqlType;
 	}
 
 	public int getIdType() {
 		return idType;
 	}
 
 	public void setIdType(int sqlType) {
 		this.idType = sqlType;
 	}
 
 	public RdbmsTable getRdbmsTable() {
 		return table;
 	}
 
 	public void setRdbmsTable(RdbmsTable table) {
 		this.table = table;
 	}
 
 	public RdbmsTable getTemporaryTable() {
 		return temporary;
 	}
 
 	public void setTemporaryTable(RdbmsTable temporary) {
 		this.temporary = temporary;
 	}
 
 	public String getName() {
 		return table.getName();
 	}
 
 	public long size() {
 		return table.size();
 	}
 
 	public int getBatchSize() {
 		return BATCH_SIZE;
 	}
 
-	public void initialize() throws SQLException {
+	public void initialize()
+		throws SQLException
+	{
 		StringBuilder sb = new StringBuilder();
 		sb.append("INSERT INTO ").append(getInsertTable().getName());
 		sb.append(" (id, value) VALUES (?, ?)");
-		INSERT = sb.toString();
+		setINSERT(sb.toString());
 		sb.delete(0, sb.length());
 		sb.append("DELETE FROM ").append(table.getName()).append("\n");
 		sb.append("WHERE 1=1 ");
 		EXPUNGE = sb.toString();
 		if (temporary != null) {
 			sb.delete(0, sb.length());
 			sb.append("INSERT INTO ").append(table.getName());
 			sb.append(" (id, value) SELECT DISTINCT id, value FROM ");
 			sb.append(temporary.getName()).append(" tmp\n");
 			sb.append("WHERE NOT EXISTS (SELECT id FROM ").append(table.getName());
 			sb.append(" val WHERE val.id = tmp.id)");
 			INSERT_SELECT = sb.toString();
 		}
 		if (!table.isCreated()) {
 			createTable(table);
-			table.index(PKEY);
+			table.primaryIndex(PKEY);
 			if (isIndexingValues()) {
-				table.index(VALUE_INDEX);
+				table.index(sqlType, VALUE_INDEX);
 			}
-		} else {
+		}
+		else {
 			table.count();
 		}
 		if (temporary != null && !temporary.isCreated()) {
 			createTemporaryTable(temporary);
 		}
 	}
 
-	public void close() throws SQLException {
+	public void close()
+		throws SQLException
+	{
 		if (insertSelect != null) {
 			insertSelect.close();
 		}
 		if (temporary != null) {
 			temporary.close();
 		}
 		table.close();
 	}
 
-	public synchronized void insert(Number id, Object value) throws SQLException, InterruptedException {
+	public synchronized void insert(Number id, Object value)
+		throws SQLException, InterruptedException
+	{
 		ValueBatch batch = getValueBatch();
 		if (isExpired(batch)) {
 			batch = newValueBatch();
 			initBatch(batch);
 		}
 		batch.setObject(1, id);
 		batch.setObject(2, value);
 		batch.addBatch();
 		queue(batch);
 	}
 
 	public ValueBatch getValueBatch() {
 		return this.batch;
 	}
 
 	public boolean isExpired(ValueBatch batch) {
 		if (batch == null || batch.isFull())
 			return true;
 		return queue == null || !queue.remove(batch);
 	}
 
 	public ValueBatch newValueBatch() {
 		return new ValueBatch();
 	}
 
 	public void initBatch(ValueBatch batch)
 		throws SQLException
 	{
 		batch.setTable(table);
 		batch.setBatchStatement(prepareInsert(INSERT));
 		batch.setMaxBatchSize(getBatchSize());
 		if (temporary != null) {
 			batch.setTemporary(temporary);
 			if (insertSelect == null) {
 				insertSelect = prepareInsertSelect(INSERT_SELECT);
 			}
 			batch.setInsertStatement(insertSelect);
 		}
 	}
 
 	public void queue(ValueBatch batch)
 		throws SQLException, InterruptedException
 	{
 		this.batch = batch;
 		if (queue == null) {
 			batch.flush();
-		} else {
+		}
+		else {
 			queue.put(batch);
 		}
 	}
 
-	public void optimize() throws SQLException {
+	public void optimize()
+		throws SQLException
+	{
 		table.optimize();
 	}
 
-	public boolean expungeRemovedStatements(int count, String condition)
-			throws SQLException {
-		removedStatementsSinceExpunge += count;
-		if (condition != null && timeToExpunge()) {
-			expunge(condition);
-			removedStatementsSinceExpunge = 0;
+	public boolean expunge(String condition)
+		throws SQLException
+	{
+		synchronized (table) {
+			int count = table.executeUpdate(EXPUNGE + condition);
+			if (count < 1)
+				return false;
+			table.modified(0, count);
 			return true;
 		}
-		return false;
-	}
-
-	public List<Long> maxIds(int shift, int mod) throws SQLException {
+	}
+
+	public List<Long> maxIds(int shift, int mod)
+		throws SQLException
+	{
 		String column = "id";
 		StringBuilder expr = new StringBuilder();
 		expr.append("MOD((").append(column);
 		expr.append(" >> ").append(shift);
 		expr.append(") + ").append(mod).append(", ");
 		expr.append(mod);
 		expr.append(")");
 		StringBuilder sb = new StringBuilder();
 		sb.append("SELECT ").append(expr);
 		sb.append(", MAX(").append(column);
 		sb.append(")\nFROM ").append(getName());
 		sb.append("\nGROUP BY ").append(expr);
 		String query = sb.toString();
 		PreparedStatement st = table.prepareStatement(query);
 		try {
 			ResultSet rs = st.executeQuery();
 			try {
 				List<Long> result = new ArrayList<Long>();
 				while (rs.next()) {
 					result.add(rs.getLong(2));
 				}
 				return result;
-			} finally {
+			}
+			finally {
 				rs.close();
 			}
-		} finally {
+		}
+		finally {
 			st.close();
 		}
 	}
 
 	public String sql(int type, int length) {
 		switch (type) {
 		case Types.VARCHAR:
 			if (length > 0)
 				return "VARCHAR(" + length + ")";
 			return "TEXT";
 		case Types.LONGVARCHAR:
 			if (length > 0)
 				return "LONGVARCHAR(" + length + ")";
 			return "TEXT";
 		case Types.BIGINT:
 			return "BIGINT";
 		case Types.INTEGER:
 			return "INTEGER";
 		case Types.SMALLINT:
 			return "SMALLINT";
 		case Types.FLOAT:
 			return "FLOAT";
 		case Types.DOUBLE:
 			return "DOUBLE";
 		case Types.DECIMAL:
 			return "DECIMAL";
 		case Types.BOOLEAN:
 			return "BOOLEAN";
 		case Types.TIMESTAMP:
 			return "TIMESTAMP";
 		default:
 			throw new AssertionError("Unsupported SQL Type: " + type);
 		}
 	}
 
 	@Override
 	public String toString() {
 		return getName();
 	}
-
-	protected void expunge(String condition) throws SQLException {
-		synchronized (table) {
-			int count = table.executeUpdate(EXPUNGE + condition);
-			table.modified(0, count);
-		}
-	}
-
-	protected boolean timeToExpunge() {
-		return removedStatementsSinceExpunge > table.size() / 4;
-	}
-
+	
 	protected RdbmsTable getInsertTable() {
 		RdbmsTable tmp = getTemporaryTable();
 		if (tmp == null) {
 			tmp = getRdbmsTable();
 		}
 		return tmp;
 	}
 
-	protected PreparedStatement prepareInsert(String sql) throws SQLException {
+	protected PreparedStatement prepareInsert(String sql)
+		throws SQLException
+	{
 		return table.prepareStatement(sql);
 	}
 
-	protected PreparedStatement prepareInsertSelect(String sql) throws SQLException {
+	protected PreparedStatement prepareInsertSelect(String sql)
+		throws SQLException
+	{
 		return table.prepareStatement(sql);
 	}
 
-	protected void createTable(RdbmsTable table) throws SQLException {
+	protected void createTable(RdbmsTable table)
+		throws SQLException
+	{
 		StringBuilder sb = new StringBuilder();
 		sb.append("  id ").append(sql(idType, -1)).append(" NOT NULL,\n");
 		sb.append("  value ").append(sql(sqlType, length));
 		sb.append(" NOT NULL\n");
 		table.createTable(sb);
 	}
 
-	protected void createTemporaryTable(RdbmsTable table) throws SQLException {
+	protected void createTemporaryTable(RdbmsTable table)
+		throws SQLException
+	{
 		StringBuilder sb = new StringBuilder();
 		sb.append("  id ").append(sql(idType, -1)).append(" NOT NULL,\n");
 		sb.append("  value ").append(sql(sqlType, length));
 		sb.append(" NOT NULL\n");
 		table.createTemporaryTable(sb);
 	}
+
+	public void setINSERT(String insert) {
+		this.INSERT = insert;
+	}
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/schema/HashBatch.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/schema/HashBatch.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/schema/HashBatch.java (revision 85)
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/schema/NamespacesTable.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/schema/NamespacesTable.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/schema/NamespacesTable.java (revision 85)
@@ -1,96 +1,112 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.schema;
 
 import java.sql.SQLException;
 import java.sql.Statement;
 import java.util.List;
 
 import org.openrdf.sail.rdbms.exceptions.RdbmsRuntimeException;
 
 /**
  * Manages the namespace prefix in the database.
  * 
  * @author James Leigh
  * 
  */
 public class NamespacesTable {
 	private RdbmsTable table;
 	private String INSERT;
 	private String UPDATE;
 	private String UPDATE_ALL_NULL;
 
 	public NamespacesTable(RdbmsTable table) {
 		this.table = table;
 		StringBuilder sb = new StringBuilder();
 		sb.append("INSERT INTO ").append(table.getName());
 		sb.append(" (prefix, namespace) VALUES (?, ?)");
 		INSERT = sb.toString();
 		sb.delete(0, sb.length());
 		sb.append("UPDATE ").append(table.getName()).append("\n");
 		sb.append("SET prefix = ?\n");
 		sb.append("WHERE namespace = ?");
 		UPDATE = sb.toString();
 		sb.delete(0, sb.length());
 		sb.append("UPDATE ").append(table.getName()).append("\n");
 		sb.append("SET prefix = NULL\n");
 		sb.append("WHERE prefix IS NOT NULL");
 		UPDATE_ALL_NULL = sb.toString();
 	}
 
-	public void initialize() throws SQLException {
+	public void initialize()
+		throws SQLException
+	{
 		if (!table.isCreated()) {
 			createTable();
 		}
 	}
 
 	public void close()
 		throws SQLException
 	{
 		table.close();
 	}
 
-	protected void createTable() throws SQLException {
+	protected void createTable()
+		throws SQLException
+	{
 		StringBuilder sb = new StringBuilder();
 		sb.append("  prefix VARCHAR(127),\n");
 		sb.append("  namespace TEXT NOT NULL\n");
 		createTable(sb);
 	}
 
-	protected void createTable(CharSequence sb) throws SQLException {
+	protected void createTable(CharSequence sb)
+		throws SQLException
+	{
 		table.createTable(sb);
 	}
 
-	public void insert(String prefix, String namespace) throws SQLException {
+	public void insert(String prefix, String namespace)
+		throws SQLException
+	{
 		int result = table.executeUpdate(INSERT, prefix, namespace);
 		if (result != 1 && result != Statement.SUCCESS_NO_INFO)
 			throw new RdbmsRuntimeException("Namespace could not be created");
 		table.modified(1, 0);
 		table.optimize();
 	}
 
 	public void updatePrefix(String prefix, String namespace)
-			throws SQLException {
+		throws SQLException
+	{
 		int result = table.executeUpdate(UPDATE, prefix, namespace);
 		if (result != 1 && result != Statement.SUCCESS_NO_INFO)
-			throw new RdbmsRuntimeException(
-					"Namespace prefix could not be changed");
+			throw new RdbmsRuntimeException("Namespace prefix could not be changed");
 	}
 
-	public void clearPrefixes() throws SQLException {
+	public void clearPrefixes()
+		throws SQLException
+	{
 		table.execute(UPDATE_ALL_NULL);
 	}
 
-	public List<Object[]> selectAll() throws SQLException {
+	public List<Object[]> selectAll()
+		throws SQLException
+	{
 		return table.select("prefix", "namespace");
 	}
 
 	@Override
 	public String toString() {
 		return table.getName();
 	}
 
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/schema/HashTable.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/schema/HashTable.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/schema/HashTable.java (revision 85)
@@ -1,133 +1,152 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.schema;
 
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
 import java.sql.Types;
 import java.util.List;
 import java.util.Map;
 
 
 /**
  *
  * @author James Leigh
  */
 public class HashTable {
 	private static final int CHUNK_SIZE = 15;
 	private ValueTable table;
 	private PreparedStatement select;
+
+	private int removedStatementsSinceExpunge;
 
 	public HashTable(ValueTable table) {
 		super();
 		this.table = table;
 	}
 
 	public String getName() {
 		return table.getName();
 	}
 
 	public int getBatchSize() {
 		return table.getBatchSize();
 	}
 
 	public int getSelectChunkSize() {
 		return CHUNK_SIZE;
 	}
 
-	public void init() throws SQLException {
+	public void init()
+		throws SQLException
+	{
 	}
 
 	public void close()
 		throws SQLException
 	{
 		if (select != null) {
 			select.close();
 		}
 		table.close();
 	}
 
 	public List<Long> maxIds(int shift, int mod)
 		throws SQLException
 	{
 		return table.maxIds(shift, mod);
 	}
 
 	public void insert(Number id, long hash)
 		throws SQLException, InterruptedException
 	{
 		synchronized (table) {
 			HashBatch batch = (HashBatch)table.getValueBatch();
 			if (table.isExpired(batch)) {
 				batch = newHashBatch();
 				table.initBatch(batch);
 			}
 			batch.addBatch(id, hash);
 			table.queue(batch);
 		}
 	}
 
 	public boolean expungeRemovedStatements(int count, String condition)
-			throws SQLException {
-		return table.expungeRemovedStatements(count, condition);
+		throws SQLException
+	{
+		removedStatementsSinceExpunge += count;
+		if (condition != null && timeToExpunge()) {
+			boolean removed = table.expunge(condition);
+			removedStatementsSinceExpunge = 0;
+			return removed;
+		}
+		return false;
+	}
+
+	protected boolean timeToExpunge() {
+		return removedStatementsSinceExpunge > table.size() / 4;
 	}
 
 	public void optimize()
 		throws SQLException
 	{
 		table.optimize();
 	}
 
 	public String toString() {
 		return table.toString();
 	}
 
 	public Map<Long, Number> load(Map<Long, Number> hashes)
 		throws SQLException
 	{
 		assert !hashes.isEmpty();
 		assert hashes.size() <= getSelectChunkSize();
 		if (select == null) {
 			StringBuilder sb = new StringBuilder();
 			sb.append("SELECT id, value\nFROM ").append(getName());
 			sb.append("\nWHERE value IN (");
 			for (int i = 0, n = getSelectChunkSize(); i < n; i++) {
 				sb.append("?,");
 			}
 			sb.setCharAt(sb.length() - 1, ')');
 			select = prepareSelect(sb.toString());
 		}
 		int p = 0;
 		for (Long hash : hashes.keySet()) {
 			select.setLong(++p, hash);
 		}
 		while (p < getSelectChunkSize()) {
 			select.setNull(++p, Types.BIGINT);
 		}
 		ResultSet rs = select.executeQuery();
 		try {
 			while (rs.next()) {
 				long id = rs.getLong(1);
 				long hash = rs.getLong(2);
 				hashes.put(hash, id);
 			}
 		}
 		finally {
 			rs.close();
 		}
 		return hashes;
 	}
 
 	protected HashBatch newHashBatch() {
 		return new HashBatch();
 	}
 
-	protected PreparedStatement prepareSelect(String sql) throws SQLException {
+	protected PreparedStatement prepareSelect(String sql)
+		throws SQLException
+	{
 		return table.getRdbmsTable().prepareStatement(sql);
 	}
 
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/schema/TransactionTable.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/schema/TransactionTable.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/schema/TransactionTable.java (revision 85)
@@ -1,199 +1,228 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.schema;
 
 import java.sql.Connection;
 import java.sql.PreparedStatement;
 import java.sql.SQLException;
 import java.util.concurrent.BlockingQueue;
 
 import org.openrdf.sail.helpers.DefaultSailChangedEvent;
 
 /**
  * Manages a temporary table used when uploading new statements with the same
  * predicate into the database.
  * 
  * @author James Leigh
  * 
  */
 public class TransactionTable {
 	private int batchSize;
 	private TripleTable triples;
 	private int addedCount;
 	private int removedCount;
 	private RdbmsTable temporary;
 	private Connection conn;
 	private TripleBatch batch;
 	private BlockingQueue<Batch> queue;
 	private DefaultSailChangedEvent sailChangedEvent;
 	private IdSequence ids;
 	private PreparedStatement insertSelect;
 
 	public void setIdSequence(IdSequence ids) {
 		this.ids = ids;
 	}
 
 	public void setQueue(BlockingQueue<Batch> queue) {
 		this.queue = queue;
 	}
 
 	public void setTemporaryTable(RdbmsTable table) {
 		this.temporary = table;
 	}
 
 	public void setConnection(Connection conn) {
 		this.conn = conn;
 	}
 
 	public TripleTable getTripleTable() {
 		return triples;
 	}
 
 	public void setTripleTable(TripleTable statements) {
 		this.triples = statements;
 	}
 
 	public void setSailChangedEvent(DefaultSailChangedEvent sailChangedEvent) {
 		this.sailChangedEvent = sailChangedEvent;
 	}
 
 	public int getBatchSize() {
 		return batchSize;
 	}
 
 	public void setBatchSize(int size) {
 		this.batchSize = size;
 	}
 
 	public void close()
 		throws SQLException
 	{
 		if (insertSelect != null) {
 			insertSelect.close();
 		}
 		temporary.close();
 	}
 
-	public synchronized void insert(Number ctx, Number subj, Number pred, Number obj)
-			throws SQLException, InterruptedException {
+	public synchronized void insert(Number ctx, Number subj, Number pred, Number obj, boolean explicit)
+		throws SQLException, InterruptedException
+	{
 		if (batch == null || batch.isFull() || !queue.remove(batch)) {
 			batch = newTripleBatch();
 			batch.setTable(triples);
 			batch.setSailChangedEvent(sailChangedEvent);
 			batch.setTemporary(temporary);
 			batch.setMaxBatchSize(getBatchSize());
 			batch.setBatchStatement(prepareInsert());
 			if (insertSelect == null) {
 				insertSelect = prepareInsertSelect(buildInsertSelect());
 			}
 			batch.setInsertStatement(insertSelect);
 		}
 		batch.setObject(1, ctx);
 		batch.setObject(2, subj);
 		if (temporary == null && !triples.isPredColumnPresent()) {
 			batch.setObject(3, obj);
+			batch.setObject(4, new Boolean(explicit));
 		} else {
 			batch.setObject(3, pred);
 			batch.setObject(4, obj);
+			batch.setObject(5, new Boolean(explicit));
 		}
 		batch.addBatch();
 		queue.put(batch);
 		addedCount++;
 		triples.getSubjTypes().add(ids.valueOf(subj));
 		triples.getObjTypes().add(ids.valueOf(obj));
 	}
 
-	public void committed() throws SQLException {
+	public void committed()
+		throws SQLException
+	{
 		triples.modified(addedCount, removedCount);
 		addedCount = 0;
 		removedCount = 0;
 	}
 
-	public void removed(int count) throws SQLException {
+	public void removed(int count)
+		throws SQLException
+	{
 		removedCount += count;
 	}
 
-	public boolean isEmpty() throws SQLException {
+	public boolean isEmpty()
+		throws SQLException
+	{
 		return triples.isEmpty() && addedCount == 0;
 	}
 
 	@Override
 	public String toString() {
 		return triples.toString();
 	}
 
 	protected TripleBatch newTripleBatch() {
 		return new TripleBatch();
 	}
 
-	protected PreparedStatement prepareInsertSelect(String sql) throws SQLException {
+	protected PreparedStatement prepareInsertSelect(String sql)
+		throws SQLException
+	{
 		return conn.prepareStatement(sql);
 	}
 
-	protected String buildInsertSelect() throws SQLException {
+	protected String buildInsertSelect()
+		throws SQLException
+	{
 		String tableName = triples.getName();
 		StringBuilder sb = new StringBuilder();
 		sb.append("INSERT INTO ").append(tableName).append("\n");
 		sb.append("SELECT DISTINCT ctx, subj, ");
 		if (triples.isPredColumnPresent()) {
 			sb.append("pred, ");
 		}
-		sb.append("obj FROM ");
+		sb.append("obj, expl FROM ");
 		sb.append(temporary.getName()).append(" tr\n");
 		sb.append("WHERE NOT EXISTS (");
 		sb.append("SELECT ctx, subj, ");
 		if (triples.isPredColumnPresent()) {
 			sb.append("pred, ");
 		}
-		sb.append("obj FROM ");
+		sb.append("obj, expl FROM ");
 		sb.append(tableName).append(" st\n");
 		sb.append("WHERE st.ctx = tr.ctx");
 		sb.append(" AND st.subj = tr.subj");
 		if (triples.isPredColumnPresent()) {
 			sb.append(" AND st.pred = tr.pred");
 		}
 		sb.append(" AND st.obj = tr.obj");
+		sb.append(" AND st.expl = tr.expl");
 		sb.append(")");
 		return sb.toString();
 	}
 
-	protected PreparedStatement prepareInsert(String sql) throws SQLException {
+	protected PreparedStatement prepareInsert(String sql)
+		throws SQLException
+	{
 		return conn.prepareStatement(sql);
 	}
 
 	protected String buildInsert(String tableName, boolean predColumnPresent)
 		throws SQLException
 	{
 		StringBuilder sb = new StringBuilder();
 		sb.append("INSERT INTO ").append(tableName);
 		sb.append(" (ctx, subj, ");
 		if (predColumnPresent) {
 			sb.append("pred, ");
 		}
-		sb.append("obj)\n");
+		sb.append("obj, expl)\n");
 		sb.append("VALUES (?, ?, ");
 		if (predColumnPresent) {
 			sb.append("?, ");
 		}
-		sb.append("?)");
+		sb.append("?, ?)");
 		return sb.toString();
 	}
 
 	protected boolean isPredColumnPresent() {
 		return triples.isPredColumnPresent();
 	}
 
-	private PreparedStatement prepareInsert() throws SQLException {
+	private PreparedStatement prepareInsert()
+		throws SQLException
+	{
 		if (temporary == null) {
 			boolean present = triples.isPredColumnPresent();
 			String sql = buildInsert(triples.getName(), present);
 			return prepareInsert(sql);
 		}
 		String sql = buildInsert(temporary.getName(), true);
 		return prepareInsert(sql);
 	}
 
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/RdbmsProvider.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/RdbmsProvider.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/RdbmsProvider.java (revision 85)
@@ -1,20 +1,20 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms;
 
 /**
  * Each supported relation store should implement this service provider
  * interface to initiate a connection factory tailored to the given product name
  * and version. If a provider does not support the given database name and
  * version it should not return a connection factory, but rather a null value.
  * 
  * @author James Leigh
  * 
  */
 public interface RdbmsProvider {
-	RdbmsConnectionFactory createRdbmsConnectionFactory(String dbName,
-			String dbVersion);
+
+	RdbmsConnectionFactory createRdbmsConnectionFactory(String dbName, String dbVersion);
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/postgresql/PgSqlRegexFlagsInliner.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/postgresql/PgSqlRegexFlagsInliner.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/postgresql/PgSqlRegexFlagsInliner.java (revision 85)
@@ -1,61 +1,64 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.postgresql;
 
 import org.openrdf.query.BindingSet;
 import org.openrdf.query.Dataset;
 import org.openrdf.query.algebra.TupleExpr;
 import org.openrdf.query.algebra.evaluation.QueryOptimizer;
 import org.openrdf.sail.rdbms.algebra.SqlConcat;
+import org.openrdf.sail.rdbms.algebra.SqlNull;
 import org.openrdf.sail.rdbms.algebra.SqlRegex;
-import org.openrdf.sail.rdbms.algebra.SqlNull;
 import org.openrdf.sail.rdbms.algebra.StringValue;
 import org.openrdf.sail.rdbms.algebra.base.RdbmsQueryModelVisitorBase;
 import org.openrdf.sail.rdbms.algebra.base.SqlExpr;
 
 /**
  * Moves the regular expression flags into the pattern string as per the
  * PostgreSQL syntax.
  * 
  * @author James Leigh
  * 
  */
-public class PgSqlRegexFlagsInliner extends
-		RdbmsQueryModelVisitorBase<RuntimeException> implements QueryOptimizer {
+public class PgSqlRegexFlagsInliner extends RdbmsQueryModelVisitorBase<RuntimeException> implements
+		QueryOptimizer
+{
 
-	public void optimize(TupleExpr tupleExpr, Dataset dataset,
-			BindingSet bindings) {
+	public void optimize(TupleExpr tupleExpr, Dataset dataset, BindingSet bindings) {
 		tupleExpr.visit(this);
 	}
 
 	@Override
-	public void meet(SqlRegex node) throws RuntimeException {
+	public void meet(SqlRegex node)
+		throws RuntimeException
+	{
 		super.meet(node);
 		SqlExpr flags = node.getFlagsArg();
 		if (!(flags instanceof SqlNull)) {
 			SqlExpr pattern = node.getPatternArg();
 			SqlExpr prefix = concat(str("(?"), flags, str(")"));
 			pattern.replaceWith(concat(prefix, pattern.clone()));
 			node.setFlagsArg(null);
 		}
 	}
 
 	private SqlExpr str(String string) {
 		return new StringValue(string);
 	}
 
 	private SqlExpr concat(SqlExpr... exprs) {
 		SqlExpr concat = null;
 		for (SqlExpr expr : exprs) {
 			if (concat == null) {
 				concat = expr;
-			} else {
+			}
+			else {
 				concat = new SqlConcat(concat, expr);
 			}
 		}
 		return concat;
 	}
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/postgresql/PgSqlProvider.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/postgresql/PgSqlProvider.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/postgresql/PgSqlProvider.java (revision 85)
@@ -1,27 +1,26 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.postgresql;
 
 import org.openrdf.sail.rdbms.RdbmsConnectionFactory;
 import org.openrdf.sail.rdbms.RdbmsProvider;
 
 /**
  * Checks the database product name and version to be compatible with this
  * Sesame store.
  * 
  * @author James Leigh
  * 
  */
 public class PgSqlProvider implements RdbmsProvider {
 
-	public RdbmsConnectionFactory createRdbmsConnectionFactory(String dbName,
-			String dbVersion) {
+	public RdbmsConnectionFactory createRdbmsConnectionFactory(String dbName, String dbVersion) {
 		if ("PostgreSQL".equalsIgnoreCase(dbName))
 			return new PgSqlConnectionFactory();
 		return null;
 	}
 
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/postgresql/PgSqlStore.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/postgresql/PgSqlStore.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/postgresql/PgSqlStore.java (revision 85)
@@ -1,107 +1,117 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.postgresql;
 
 import org.apache.commons.dbcp.BasicDataSource;
 import org.openrdf.sail.SailException;
 import org.openrdf.sail.rdbms.RdbmsStore;
 import org.openrdf.sail.rdbms.exceptions.RdbmsException;
 
 /**
  * A convenient way to initialise a PostgreSQL RDF store.
  * 
  * @author James Leigh
  * 
  */
 public class PgSqlStore extends RdbmsStore {
 	private String serverName;
 	private String databaseName;
 	private int portNumber;
 	private String user;
 	private String password;
 
 	public PgSqlStore() {
 		super();
 	}
 
 	public PgSqlStore(String databaseName) {
 		setDatabaseName(databaseName);
 	}
 
 	public String getServerName() {
 		return serverName;
 	}
 
 	public void setServerName(String serverName) {
 		this.serverName = serverName;
 	}
 
 	public String getDatabaseName() {
 		return databaseName;
 	}
 
 	public void setDatabaseName(String databaseName) {
 		this.databaseName = databaseName;
 	}
 
 	public int getPortNumber() {
 		return portNumber;
 	}
 
 	public void setPortNumber(int portNumber) {
 		this.portNumber = portNumber;
 	}
 
 	public String getUser() {
 		return user;
 	}
 
 	public void setUser(String user) {
 		this.user = user;
 	}
 
 	public String getPassword() {
 		return password;
 	}
 
 	public void setPassword(String password) {
 		this.password = password;
 	}
 
 	@Override
-	public void initialize() throws SailException {
+	public void initialize()
+		throws SailException
+	{
 		try {
 			Class.forName("org.postgresql.Driver");
-		} catch (ClassNotFoundException e) {
+		}
+		catch (ClassNotFoundException e) {
 			throw new RdbmsException(e.toString(), e);
 		}
 		StringBuilder url = new StringBuilder();
 		url.append("jdbc:postgresql:");
 		if (serverName != null) {
 			url.append("//").append(serverName);
 			if (portNumber > 0) {
 				url.append(":").append(portNumber);
 			}
 			url.append("/");
 		}
 		url.append(databaseName);
 		BasicDataSource ds = new BasicDataSource();
 		ds.setUrl(url.toString());
 		if (user != null) {
 			ds.setUsername(user);
-		} else {
+		}
+		else {
 			ds.setUsername(System.getProperty("user.name"));
 		}
 		if (password != null) {
 			ds.setPassword(password);
 		}
 		PgSqlConnectionFactory factory = new PgSqlConnectionFactory();
 		factory.setSail(this);
 		factory.setDataSource(ds);
 		setConnectionFactory(factory);
 		super.initialize();
 	}
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/postgresql/PgSqlValueTableFactory.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/postgresql/PgSqlValueTableFactory.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/postgresql/PgSqlValueTableFactory.java (revision 85)
@@ -1,41 +1,34 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.postgresql;
 
 import java.sql.Connection;
 
-import org.openrdf.sail.rdbms.schema.HashTable;
 import org.openrdf.sail.rdbms.schema.TripleTable;
-import org.openrdf.sail.rdbms.schema.ValueTable;
 import org.openrdf.sail.rdbms.schema.ValueTableFactory;
 
 /**
  * Overrides PostgreSQL specific table commands.
  * 
  * @author James Leigh
  * 
  */
 public class PgSqlValueTableFactory extends ValueTableFactory {
 
 	public PgSqlValueTableFactory() {
 		super(new PgSqlTableFactory());
 	}
 
 	@Override
 	public PgSqlValueTable newValueTable() {
 		return new PgSqlValueTable();
 	}
 
 	@Override
 	public TripleTable createTripleTable(Connection conn, String tableName) {
 		return super.createTripleTable(conn, tableName.toLowerCase());
 	}
-
-	@Override
-	protected HashTable newHashtable(ValueTable table) {
-		return new PgSqlHashtable(table);
-	}
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/postgresql/PgQueryBuilderFactory.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/postgresql/PgQueryBuilderFactory.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/postgresql/PgQueryBuilderFactory.java (revision 85)
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/postgresql/PgSqlValueTable.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/postgresql/PgSqlValueTable.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/postgresql/PgSqlValueTable.java (revision 85)
@@ -1,90 +1,31 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.postgresql;
 
-import java.sql.PreparedStatement;
-import java.sql.SQLException;
 import java.sql.Types;
 
-import org.openrdf.sail.rdbms.schema.RdbmsTable;
 import org.openrdf.sail.rdbms.schema.ValueTable;
 
 /**
  * Optimises prepared insert statements for PostgreSQL and overrides the DOUBLE
  * column type.
  * 
  * @author James Leigh
  * 
  */
 public class PgSqlValueTable extends ValueTable {
 
 	@Override
-	public void initialize() throws SQLException {
-		super.initialize();
-
-		RdbmsTable tmp = getInsertTable();
-		StringBuilder sb = new StringBuilder();
-		sb.append("PREPARE ").append(tmp.getName());
-		sb.append("_insert (").append(sql(getIdType(), -1)).append(", ");
-		sb.append(sql(getSqlType(), getLength())
-				.replaceAll("\\(.*\\)", ""));
-		sb.append(") AS\n");
-		sb.append("INSERT INTO ").append(tmp.getName());
-		sb.append(" VALUES ($1, $2)");
-		tmp.execute(sb.toString());
-
-		sb.delete(0, sb.length());
-		sb.append("PREPARE ").append(tmp.getName());
-		sb.append("_insert_select AS\n");
-		sb.append("INSERT INTO ").append(getRdbmsTable().getName());
-		sb.append(" (id, value) SELECT DISTINCT id, value FROM ");
-		sb.append(tmp.getName()).append(" tmp\n");
-		sb.append("WHERE NOT EXISTS (SELECT id FROM ").append(getRdbmsTable().getName());
-		sb.append(" val WHERE val.id = tmp.id)");
-		tmp.execute(sb.toString());
-	}
-
-	@Override
-	public void close()
-		throws SQLException
-	{
-		RdbmsTable tmp = getInsertTable();
-		tmp.execute("DEALLOCATE " + tmp.getName() + "_insert");
-		tmp.execute("DEALLOCATE " + tmp.getName() + "_insert_select");
-		super.close();
-	}
-
-	@Override
 	public String sql(int type, int length) {
 		switch (type) {
 		case Types.DOUBLE:
 			return "double precision";
 		default:
 			return super.sql(type, length);
 		}
 	}
 
-	@Override
-	protected PreparedStatement prepareInsert(String sql)
-		throws SQLException
-	{
-		StringBuilder sb = new StringBuilder();
-		sb.append("EXECUTE ").append(getInsertTable().getName());
-		sb.append("_insert(?, ?)");
-		return super.prepareInsert(sb.toString());
-	}
-
-	@Override
-	protected PreparedStatement prepareInsertSelect(String sql)
-		throws SQLException
-	{
-		StringBuilder sb = new StringBuilder();
-		sb.append("EXECUTE ").append(getInsertTable().getName());
-		sb.append("_insert_select");
-		return super.prepareInsertSelect(sb.toString());
-	}
-
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/postgresql/PgSqlConnectionFactory.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/postgresql/PgSqlConnectionFactory.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/postgresql/PgSqlConnectionFactory.java (revision 85)
@@ -1,54 +1,48 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.postgresql;
 
 import org.openrdf.sail.rdbms.RdbmsConnectionFactory;
 import org.openrdf.sail.rdbms.evaluation.QueryBuilderFactory;
-import org.openrdf.sail.rdbms.managers.TransTableManager;
 import org.openrdf.sail.rdbms.optimizers.RdbmsQueryOptimizer;
 import org.openrdf.sail.rdbms.schema.TableFactory;
 import org.openrdf.sail.rdbms.schema.ValueTableFactory;
 
 /**
  * Overrides {@link ValueTableFactory}, {@link QueryBuilderFactory}, and
  * {@link RdbmsQueryOptimizer}. This class also indicates that PostgreSQL does
  * not require a FROM clause.
  * 
  * @author James Leigh
  * 
  */
 public class PgSqlConnectionFactory extends RdbmsConnectionFactory {
 
 	@Override
 	protected ValueTableFactory createValueTableFactory() {
 		return new PgSqlValueTableFactory();
 	}
 
 	@Override
 	protected TableFactory createTableFactory() {
 		return new PgSqlTableFactory();
 	}
 
 	@Override
 	protected QueryBuilderFactory createQueryBuilderFactory() {
 		return new PgQueryBuilderFactory();
 	}
 
 	@Override
 	protected String getFromDummyTable() {
 		return "";
 	}
 
 	@Override
 	protected RdbmsQueryOptimizer createOptimizer() {
 		return new PgSqlQueryOptimizer();
 	}
-
-	@Override
-	protected TransTableManager createTransTableManager() {
-		return new PgSqlTransTableManager();
-	}
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/postgresql/PgSqlTable.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/postgresql/PgSqlTable.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/postgresql/PgSqlTable.java (revision 85)
@@ -1,40 +1,42 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.postgresql;
 
 import java.sql.SQLException;
 
 import org.openrdf.sail.rdbms.schema.RdbmsTable;
 
 /**
  * Converts table names to lower-case and include the analyse optimisation.
  * 
  * @author James Leigh
  * 
  */
 public class PgSqlTable extends RdbmsTable {
 
 	public PgSqlTable(String name) {
 		super(name.toLowerCase());
 	}
 
-	@Override
+	//@Override
 	protected String buildLongIndex(String... columns) {
 		// TODO How can we index text columns?
 		return null;
 	}
 
 	@Override
-	protected String buildOptimize() throws SQLException {
+	protected String buildOptimize()
+		throws SQLException
+	{
 		return "VACUUM ANALYZE " + getName();
 	}
 
 	@Override
 	protected String buildClear() {
 		return "TRUNCATE " + getName();
 	}
 
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/postgresql/PgSqlTransTableManager.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/postgresql/PgSqlTransTableManager.java (revision 45)
+++  (revision )
@@ -1,73 +1,0 @@
-/*
- * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
- *
- * Licensed under the Aduna BSD-style license.
- */
-package org.openrdf.sail.rdbms.postgresql;
-
-import java.sql.SQLException;
-
-import org.openrdf.sail.rdbms.managers.TransTableManager;
-import org.openrdf.sail.rdbms.schema.IdSequence;
-import org.openrdf.sail.rdbms.schema.RdbmsTable;
-import org.openrdf.sail.rdbms.schema.TransactionTable;
-
-public class PgSqlTransTableManager extends TransTableManager {
-	private RdbmsTable table;
-	private IdSequence ids;
-
-	@Override
-	public void setIdSequence(IdSequence ids) {
-		super.setIdSequence(ids);
-		this.ids = ids;
-	}
-
-	@Override
-	public void close() throws SQLException {
-		if (table != null) {
-			try {
-				table.execute("DEALLOCATE " + table.getName() + "_insert");
-			} catch (SQLException e) {
-				try {
-					table.rollback();
-					table.execute("DEALLOCATE " + table.getName() + "_insert");
-				} catch (SQLException e1) {
-					// ignore
-				}
-			}
-		}
-		super.close();
-	}
-
-	@Override
-	protected void createTemporaryTable(RdbmsTable table) throws SQLException {
-		super.createTemporaryTable(table);
-		StringBuilder sb = new StringBuilder();
-		sb.append("PREPARE ").append(table.getName());
-		sb.append("_insert (");
-		sb.append(ids.getSqlType()).append(", ");
-		sb.append(ids.getSqlType()).append(", ");
-		sb.append(ids.getSqlType()).append(", ");
-		sb.append(ids.getSqlType()).append(") AS\n");
-		sb.append("INSERT INTO ").append(table.getName());
-		sb.append(" VALUES ($1, $2, $3, $4)");
-		table.execute(sb.toString());
-		this.table = table;
-	}
-
-	@Override
-	public TransactionTable createTransactionTable() {
-		return new TransactionTable(){
-			@Override
-			protected String buildInsert(String tableName, boolean predColumnPresent) throws SQLException {
-				if (table == null || !tableName.equals(table.getName()))
-					return super.buildInsert(tableName, predColumnPresent);
-				StringBuilder sb = new StringBuilder();
-				sb.append("EXECUTE ").append(tableName);
-				sb.append("_insert(?, ?, ?, ?)");
-				return sb.toString();
-			}
-		};
-	}
-
-}
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/postgresql/PgSqlHashtable.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/postgresql/PgSqlHashtable.java (revision 45)
+++  (revision )
@@ -1,68 +1,0 @@
-/*
- * Copyright Aduna (http://www.aduna-software.com/) (c) 2007.
- *
- * Licensed under the Aduna BSD-style license.
- */
-package org.openrdf.sail.rdbms.postgresql;
-
-import java.sql.PreparedStatement;
-import java.sql.SQLException;
-
-import org.openrdf.sail.rdbms.schema.HashTable;
-import org.openrdf.sail.rdbms.schema.ValueTable;
-
-
-/**
- *
- * @author james
- */
-public class PgSqlHashtable extends HashTable {
-	private ValueTable table;
-	private String execute;
-
-	public PgSqlHashtable(ValueTable table) {
-		super(table);
-		this.table = table;
-	}
-
-	@Override
-	public void close()
-		throws SQLException
-	{
-		if (execute != null) {
-			table.getRdbmsTable().execute("DEALLOCATE " + getName() + "_select");
-		}
-		super.close();
-	}
-
-	@Override
-	protected PreparedStatement prepareSelect(String sql)
-		throws SQLException
-	{
-		if (execute == null) {
-			StringBuilder sb = new StringBuilder();
-			sb.append("PREPARE ").append(getName()).append("_select (");
-			for (int i = 0, n = getSelectChunkSize(); i < n; i++) {
-				sb.append("bigint,");
-			}
-			sb.setCharAt(sb.length() - 1, ')');
-			sb.append(" AS\n");
-			sb.append("SELECT id, value\nFROM ").append(getName());
-			sb.append("\nWHERE value IN (");
-			for (int i = 0, n = getSelectChunkSize(); i < n; i++) {
-				sb.append("$").append(i + 1).append(",");
-			}
-			sb.setCharAt(sb.length() - 1, ')');
-			table.getRdbmsTable().execute(sb.toString());
-			sb.delete(0, sb.length());
-			sb.append("EXECUTE ").append(getName()).append("_select (");
-			for (int i = 0, n = getSelectChunkSize(); i < n; i++) {
-				sb.append("?,");
-			}
-			sb.setCharAt(sb.length() - 1, ')');
-			execute = sb.toString();
-		}
-		return super.prepareSelect(execute);
-	}
-
-}
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/RdbmsStore.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/RdbmsStore.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/RdbmsStore.java (revision 85)
@@ -1,200 +1,224 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms;
 
 import java.sql.Connection;
 import java.sql.DatabaseMetaData;
 import java.sql.SQLException;
 import java.util.Iterator;
 
 import javax.imageio.spi.ServiceRegistry;
 import javax.naming.InitialContext;
 import javax.naming.NamingException;
 import javax.sql.DataSource;
 
 import org.apache.commons.dbcp.BasicDataSource;
 
 import org.openrdf.sail.SailConnection;
 import org.openrdf.sail.SailException;
 import org.openrdf.sail.helpers.SailBase;
 import org.openrdf.sail.rdbms.exceptions.RdbmsException;
 
 /**
  * The RDBMS SAIL for relational database storage in Sesame. This class acts
  * both as a base class for database specific stores as well as a generic store
  * that can infer the type of database through the JDBC connection.
  * 
  * @author James Leigh
  * 
  */
 public class RdbmsStore extends SailBase {
 	private RdbmsConnectionFactory factory;
 	private String jdbcDriver;
 	private String url;
 	private String user;
 	private String password;
 	private int maxTripleTables;
 	private boolean triplesIndexed = true;
-	private boolean sequenced = false;
+
+	private boolean sequenced = true;
 
 	public RdbmsStore() {
 		super();
 	}
 
 	public RdbmsStore(String url) {
 		this.url = url;
 	}
 
 	public RdbmsStore(String url, String user, String password) {
 		this.url = url;
 		this.user = user;
 		this.password = password;
 	}
 
 	public RdbmsStore(String jdbcDriver, String jdbcUrl) {
 		this.jdbcDriver = jdbcDriver;
 		this.url = jdbcUrl;
 	}
 
-	public RdbmsStore(String jdbcDriver, String jdbcUrl, String user,
-			String password) {
+	public RdbmsStore(String jdbcDriver, String jdbcUrl, String user, String password) {
 		this.jdbcDriver = jdbcDriver;
 		this.url = jdbcUrl;
 		this.user = user;
 		this.password = password;
 	}
 
 	public int getMaxNumberOfTripleTables() {
 		return maxTripleTables;
 	}
 
 	public void setMaxNumberOfTripleTables(int max) {
 		maxTripleTables = max;
 	}
 
 	public boolean isIndexed() {
 		return triplesIndexed;
 	}
 
 	public void setIndexed(boolean indexed)
 		throws SailException
 	{
 		triplesIndexed = indexed;
 		if (factory != null) {
 			factory.setTriplesIndexed(triplesIndexed);
 		}
 	}
 
 	public boolean isSequenced() {
 		return sequenced;
 	}
 
 	public void setSequenced(boolean useSequence) {
 		this.sequenced = useSequence;
 	}
 
-	public void initialize() throws SailException {
+	public void initialize()
+		throws SailException
+	{
 		if (factory == null) {
 			try {
 				factory = createFactory(jdbcDriver, url, user, password);
-			} catch (SailException e) {
+			}
+			catch (SailException e) {
 				throw e;
-			} catch (Exception e) {
+			}
+			catch (Exception e) {
 				throw new RdbmsException(e);
 			}
 		}
 		factory.setMaxNumberOfTripleTables(maxTripleTables);
 		factory.setTriplesIndexed(triplesIndexed);
 		factory.setSequenced(sequenced);
 		factory.init();
 	}
 
-	public boolean isWritable() throws SailException {
+	public boolean isWritable()
+		throws SailException
+	{
 		return factory.isWritable();
 	}
 
 	public RdbmsValueFactory getValueFactory() {
 		return factory.getValueFactory();
 	}
 
 	@Override
-	protected SailConnection getConnectionInternal() throws SailException {
+	protected SailConnection getConnectionInternal()
+		throws SailException
+	{
 		return factory.createConnection();
 	}
 
 	@Override
-	protected void shutDownInternal() throws SailException {
+	protected void shutDownInternal()
+		throws SailException
+	{
 		DataSource ds = factory.getDataSource();
 		factory.shutDown();
 		if (ds instanceof BasicDataSource) {
 			try {
-				((BasicDataSource) ds).close();
-			} catch (SQLException e) {
+				((BasicDataSource)ds).close();
+			}
+			catch (SQLException e) {
 				throw new RdbmsException(e);
 			}
 		}
 	}
 
 	protected void setConnectionFactory(RdbmsConnectionFactory factory) {
 		this.factory = factory;
 	}
 
-	private RdbmsConnectionFactory createFactory(String jdbcDriver, String url,
-			String user, String password) throws Exception {
+	private RdbmsConnectionFactory createFactory(String jdbcDriver, String url, String user, String password)
+		throws Exception
+	{
 		if (jdbcDriver != null) {
 			Class.forName(jdbcDriver);
 		}
 		DataSource ds = lookupDataSource(url, user, password);
 		Connection con;
 		if (user == null || url.startsWith("jdbc:")) {
 			con = ds.getConnection();
-		} else {
+		}
+		else {
 			con = ds.getConnection(user, password);
 		}
 		try {
 			DatabaseMetaData metaData = con.getMetaData();
 			RdbmsConnectionFactory factory = newFactory(metaData);
 			factory.setSail(this);
 			if (user == null || url.startsWith("jdbc:")) {
 				factory.setDataSource(ds);
-			} else {
+			}
+			else {
 				factory.setDataSource(ds, user, password);
 			}
 			return factory;
-		} finally {
+		}
+		finally {
 			con.close();
 		}
 	}
 
 	private DataSource lookupDataSource(String url, String user, String password)
-			throws NamingException {
+		throws NamingException
+	{
 		if (url.startsWith("jdbc:")) {
 			BasicDataSource ds = new BasicDataSource();
 			ds.setUrl(url);
 			ds.setUsername(user);
 			ds.setPassword(password);
 			return ds;
 		}
-		return (DataSource) new InitialContext().lookup(url);
+		return (DataSource)new InitialContext().lookup(url);
 	}
 
 	private RdbmsConnectionFactory newFactory(DatabaseMetaData metaData)
-			throws SQLException {
+		throws SQLException
+	{
 		String dbn = metaData.getDatabaseProductName();
 		String dbv = metaData.getDatabaseProductVersion();
 		RdbmsConnectionFactory factory;
 		Iterator<RdbmsProvider> providers;
 		providers = ServiceRegistry.lookupProviders(RdbmsProvider.class);
 		while (providers.hasNext()) {
 			RdbmsProvider provider = providers.next();
 			factory = provider.createRdbmsConnectionFactory(dbn, dbv);
 			if (factory != null)
 				return factory;
 		}
 		return new RdbmsConnectionFactory();
 	}
 
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/optimizers/ValueJoinOptimizer.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/optimizers/ValueJoinOptimizer.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/optimizers/ValueJoinOptimizer.java (revision 85)
@@ -1,206 +1,248 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.optimizers;
 
 import org.openrdf.query.BindingSet;
 import org.openrdf.query.Dataset;
 import org.openrdf.query.algebra.TupleExpr;
 import org.openrdf.query.algebra.evaluation.QueryOptimizer;
 import org.openrdf.sail.rdbms.algebra.BNodeColumn;
 import org.openrdf.sail.rdbms.algebra.ColumnVar;
 import org.openrdf.sail.rdbms.algebra.DatatypeColumn;
 import org.openrdf.sail.rdbms.algebra.DateTimeColumn;
 import org.openrdf.sail.rdbms.algebra.HashColumn;
 import org.openrdf.sail.rdbms.algebra.IdColumn;
 import org.openrdf.sail.rdbms.algebra.JoinItem;
 import org.openrdf.sail.rdbms.algebra.LabelColumn;
 import org.openrdf.sail.rdbms.algebra.LanguageColumn;
 import org.openrdf.sail.rdbms.algebra.LongLabelColumn;
 import org.openrdf.sail.rdbms.algebra.LongURIColumn;
 import org.openrdf.sail.rdbms.algebra.NumericColumn;
+import org.openrdf.sail.rdbms.algebra.PointColumn;
 import org.openrdf.sail.rdbms.algebra.RefIdColumn;
 import org.openrdf.sail.rdbms.algebra.SelectQuery;
 import org.openrdf.sail.rdbms.algebra.SqlEq;
 import org.openrdf.sail.rdbms.algebra.URIColumn;
 import org.openrdf.sail.rdbms.algebra.base.FromItem;
 import org.openrdf.sail.rdbms.algebra.base.RdbmsQueryModelVisitorBase;
 import org.openrdf.sail.rdbms.schema.BNodeTable;
 import org.openrdf.sail.rdbms.schema.HashTable;
 import org.openrdf.sail.rdbms.schema.LiteralTable;
 import org.openrdf.sail.rdbms.schema.URITable;
 
 /**
  * Adds LEFT JOINs to the query for value tables.
  * 
  * @author James Leigh
  * 
  */
-public class ValueJoinOptimizer extends
-		RdbmsQueryModelVisitorBase<RuntimeException> implements QueryOptimizer {
+public class ValueJoinOptimizer extends RdbmsQueryModelVisitorBase<RuntimeException> implements
+		QueryOptimizer
+{
+
 	private URITable uris;
 	private BNodeTable bnodes;
 	private LiteralTable literals;
 	private HashTable hashes;
 	private FromItem join;
 	private FromItem parent;
 	private SelectQuery query;
 
 	public void setUriTable(URITable uris) {
 		this.uris = uris;
 	}
 
 	public void setBnodeTable(BNodeTable bnodes) {
 		this.bnodes = bnodes;
 	}
 
 	public void setLiteralTable(LiteralTable literals) {
 		this.literals = literals;
 	}
 
 	public void setHashTable(HashTable hashes) {
 		this.hashes = hashes;
 	}
 
-	public void optimize(TupleExpr tupleExpr, Dataset dataset,
-			BindingSet bindings) {
+	public void optimize(TupleExpr tupleExpr, Dataset dataset, BindingSet bindings) {
 		join = null;
 		tupleExpr.visit(this);
 	}
 
 	@Override
-	public void meetFromItem(FromItem node) throws RuntimeException {
+	public void meetFromItem(FromItem node)
+		throws RuntimeException
+	{
 		FromItem top = parent;
 		parent = join;
 		join = node;
 		super.meetFromItem(node);
 		join = parent;
 		parent = top;
 	}
 
 	@Override
-	public void meet(SelectQuery node) throws RuntimeException {
+	public void meet(SelectQuery node)
+		throws RuntimeException
+	{
 		query = node;
 		parent = node.getFrom();
 		join = node.getFrom();
 		super.meet(node);
 		join = null;
 		parent = null;
 		query = null;
 	}
 
 	@Override
-	public void meet(HashColumn node) throws RuntimeException {
+	public void meet(HashColumn node)
+		throws RuntimeException
+	{
 		if (hashes == null || hashes.getName() == null) {
 			super.meet(node);
-		} else {
+		}
+		else {
 			ColumnVar var = node.getRdbmsVar();
 			String alias = "h" + getDBName(var);
 			String tableName = hashes.getName();
 			join(var, alias, tableName, false);
 		}
 	}
 
 	@Override
-	public void meet(BNodeColumn node) throws RuntimeException {
+	public void meet(BNodeColumn node)
+		throws RuntimeException
+	{
 		ColumnVar var = node.getRdbmsVar();
 		String alias = "b" + getDBName(var);
 		String tableName = bnodes.getName();
 		join(var, alias, tableName);
 	}
 
 	@Override
-	public void meet(DatatypeColumn node) throws RuntimeException {
+	public void meet(DatatypeColumn node)
+		throws RuntimeException
+	{
 		ColumnVar var = node.getRdbmsVar();
 		String alias = "d" + getDBName(var);
 		String tableName = literals.getDatatypeTable().getName();
 		join(var, alias, tableName);
 	}
 
 	@Override
-	public void meet(DateTimeColumn node) throws RuntimeException {
+	public void meet(DateTimeColumn node)
+		throws RuntimeException
+	{
 		ColumnVar var = node.getRdbmsVar();
 		String alias = "t" + getDBName(var);
 		String tableName = literals.getDateTimeTable().getName();
 		join(var, alias, tableName);
 	}
-
-	@Override
-	public void meet(LabelColumn node) throws RuntimeException {
+	
+	@Override
+	public void meet(LabelColumn node)
+		throws RuntimeException
+	{
 		ColumnVar var = node.getRdbmsVar();
 		String alias = "l" + getDBName(var);
 		String tableName = literals.getLabelTable().getName();
 		join(var, alias, tableName);
 	}
 
 	@Override
-	public void meet(LongLabelColumn node) throws RuntimeException {
+	public void meet(LongLabelColumn node)
+		throws RuntimeException
+	{
 		ColumnVar var = node.getRdbmsVar();
 		String alias = "ll" + getDBName(var);
 		String tableName = literals.getLongLabelTable().getName();
 		join(var, alias, tableName);
 	}
 
 	@Override
-	public void meet(LanguageColumn node) throws RuntimeException {
+	public void meet(LanguageColumn node)
+		throws RuntimeException
+	{
 		ColumnVar var = node.getRdbmsVar();
 		String alias = "g" + getDBName(var);
 		String tableName = literals.getLanguageTable().getName();
 		join(var, alias, tableName);
 	}
 
 	@Override
-	public void meet(NumericColumn node) throws RuntimeException {
+	public void meet(NumericColumn node)
+		throws RuntimeException
+	{
 		ColumnVar var = node.getRdbmsVar();
 		String alias = "n" + getDBName(var);
 		String tableName = literals.getNumericTable().getName();
 		join(var, alias, tableName);
 	}
 
 	@Override
-	public void meet(LongURIColumn node) throws RuntimeException {
+	public void meet(LongURIColumn node)
+		throws RuntimeException
+	{
 		ColumnVar var = node.getRdbmsVar();
 		String alias = "lu" + getDBName(var);
 		String tableName = uris.getLongTableName();
 		join(var, alias, tableName);
 	}
 
 	@Override
-	public void meet(URIColumn node) throws RuntimeException {
+	public void meet(URIColumn node)
+		throws RuntimeException
+	{
 		ColumnVar var = node.getRdbmsVar();
 		String alias = "u" + getDBName(var);
 		String tableName = uris.getShortTableName();
+		join(var, alias, tableName);
+	}
+
+	@Override
+	public void meet(PointColumn node) throws RuntimeException {
+		ColumnVar var = node.getRdbmsVar();
+		String alias = "p" + getDBName(var);
+		String tableName = literals.getPointTable().getName();
 		join(var, alias, tableName);
 	}
 
 	private CharSequence getDBName(ColumnVar var) {
 		String name = var.getName();
 		if (name.indexOf('-') >= 0)
 			return name.replace('-', '_');
 		return "_" + name; // might be a keyword otherwise
 	}
 
 	private void join(ColumnVar var, String alias, String tableName) {
 		join(var, alias, tableName, true);
 	}
 
 	private void join(ColumnVar var, String alias, String tableName, boolean left) {
 		if (query.getFromItem(alias) == null) {
 			FromItem valueJoin = valueJoin(alias, tableName, var, left);
 			if (join == parent || join.getFromItem(var.getAlias()) != null) {
 				join.addJoin(valueJoin);
-			} else {
+			}
+			else {
 				parent.addJoinBefore(valueJoin, join);
 			}
 		}
 	}
 
 	private FromItem valueJoin(String alias, String tableName, ColumnVar using, boolean left) {
 		JoinItem j = new JoinItem(alias, tableName);
 		j.setLeft(left);
 		j.addFilter(new SqlEq(new IdColumn(alias), new RefIdColumn(using)));
 		return j;
 	}
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/optimizers/RdbmsQueryOptimizer.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/optimizers/RdbmsQueryOptimizer.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/optimizers/RdbmsQueryOptimizer.java (revision 85)
@@ -1,107 +1,111 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.optimizers;
 
 import org.openrdf.query.BindingSet;
 import org.openrdf.query.Dataset;
 import org.openrdf.query.algebra.QueryRoot;
 import org.openrdf.query.algebra.TupleExpr;
 import org.openrdf.query.algebra.evaluation.EvaluationStrategy;
 import org.openrdf.query.algebra.evaluation.impl.BindingAssigner;
 import org.openrdf.query.algebra.evaluation.impl.CompareOptimizer;
 import org.openrdf.query.algebra.evaluation.impl.ConjunctiveConstraintSplitter;
 import org.openrdf.query.algebra.evaluation.impl.ConstantOptimizer;
 import org.openrdf.query.algebra.evaluation.impl.QueryJoinOptimizer;
 import org.openrdf.query.algebra.evaluation.impl.SameTermFilterOptimizer;
 import org.openrdf.query.algebra.evaluation.util.QueryOptimizerList;
 import org.openrdf.sail.rdbms.RdbmsValueFactory;
 import org.openrdf.sail.rdbms.schema.BNodeTable;
 import org.openrdf.sail.rdbms.schema.HashTable;
 import org.openrdf.sail.rdbms.schema.LiteralTable;
 import org.openrdf.sail.rdbms.schema.URITable;
 
 /**
  * Facade to the underlying RDBMS optimizations.
  * 
  * @author James Leigh
  * 
  */
 public class RdbmsQueryOptimizer {
 	private RdbmsValueFactory vf;
 	private URITable uris;
 	private BNodeTable bnodes;
 	private LiteralTable literals;
 	private SelectQueryOptimizerFactory factory;
 	private HashTable hashTable;
 
-	public void setSelectQueryOptimizerFactory(
-			SelectQueryOptimizerFactory factory) {
+	public void setSelectQueryOptimizerFactory(SelectQueryOptimizerFactory factory) {
 		this.factory = factory;
 	}
 
 	public void setValueFactory(RdbmsValueFactory vf) {
 		this.vf = vf;
 	}
 
 	public void setUriTable(URITable uris) {
 		this.uris = uris;
 	}
 
 	public void setBnodeTable(BNodeTable bnodes) {
 		this.bnodes = bnodes;
 	}
 
 	public void setLiteralTable(LiteralTable literals) {
 		this.literals = literals;
 	}
 
 	public void setHashTable(HashTable hashTable) {
 		this.hashTable = hashTable;
 	}
 
-	public TupleExpr optimize(TupleExpr expr, Dataset dataset,
-			BindingSet bindings, EvaluationStrategy strategy) {
+	public TupleExpr optimize(TupleExpr expr, Dataset dataset, BindingSet bindings, EvaluationStrategy strategy)
+	{
 		// Clone the tuple expression to allow for more aggressive optimisations
 		TupleExpr tupleExpr = expr.clone();
 
 		if (!(tupleExpr instanceof QueryRoot)) {
 			// Add a dummy root node to the tuple expressions to allow the
 			// optimisers to modify the actual root node
 			tupleExpr = new QueryRoot(tupleExpr);
 		}
 
 		QueryOptimizerList optimizerList = new QueryOptimizerList();
 		addCoreOptimizations(strategy, optimizerList);
 		addRdbmsOptimizations(optimizerList);
 		optimizerList.add(new SqlConstantOptimizer());
 
 		optimizerList.optimize(tupleExpr, dataset, bindings);
 		return tupleExpr;
 	}
 
-	protected void addCoreOptimizations(EvaluationStrategy strategy,
-			QueryOptimizerList optimizerList) {
+	protected void addCoreOptimizations(EvaluationStrategy strategy, QueryOptimizerList optimizerList) {
 		optimizerList.add(new BindingAssigner());
 		optimizerList.add(new ConstantOptimizer(strategy));
 		optimizerList.add(new CompareOptimizer());
 		optimizerList.add(new ConjunctiveConstraintSplitter());
 		optimizerList.add(new SameTermFilterOptimizer());
 		optimizerList.add(new QueryJoinOptimizer());
 	}
 
 	protected void addRdbmsOptimizations(QueryOptimizerList optimizerList) {
 		optimizerList.add(new ValueIdLookupOptimizer(vf));
 		optimizerList.add(factory.createRdbmsFilterOptimizer());
 		optimizerList.add(new VarColumnLookupOptimizer());
 		ValueJoinOptimizer valueJoins = new ValueJoinOptimizer();
 		valueJoins.setBnodeTable(bnodes);
 		valueJoins.setUriTable(uris);
 		valueJoins.setLiteralTable(literals);
 		valueJoins.setHashTable(hashTable);
 		optimizerList.add(valueJoins);
 	}
 
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/optimizers/SelectQueryOptimizerFactory.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/optimizers/SelectQueryOptimizerFactory.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/optimizers/SelectQueryOptimizerFactory.java (revision 85)
@@ -1,78 +1,83 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.optimizers;
 
 import org.openrdf.sail.rdbms.RdbmsValueFactory;
 import org.openrdf.sail.rdbms.algebra.factories.BNodeExprFactory;
 import org.openrdf.sail.rdbms.algebra.factories.BooleanExprFactory;
 import org.openrdf.sail.rdbms.algebra.factories.DatatypeExprFactory;
 import org.openrdf.sail.rdbms.algebra.factories.HashExprFactory;
 import org.openrdf.sail.rdbms.algebra.factories.LabelExprFactory;
 import org.openrdf.sail.rdbms.algebra.factories.LanguageExprFactory;
 import org.openrdf.sail.rdbms.algebra.factories.NumericExprFactory;
+import org.openrdf.sail.rdbms.algebra.factories.PointExprFactory;
 import org.openrdf.sail.rdbms.algebra.factories.SqlExprFactory;
 import org.openrdf.sail.rdbms.algebra.factories.TimeExprFactory;
 import org.openrdf.sail.rdbms.algebra.factories.URIExprFactory;
 import org.openrdf.sail.rdbms.algebra.factories.ZonedExprFactory;
 import org.openrdf.sail.rdbms.managers.TransTableManager;
 import org.openrdf.sail.rdbms.schema.IdSequence;
 
 /**
  * Initialises the {@link SelectQueryOptimizer} with the SQL expression
  * factories.
  * 
  * @author James Leigh
  * 
  */
 public class SelectQueryOptimizerFactory {
 	private RdbmsValueFactory vf;
 	private TransTableManager tables;
 	private IdSequence ids;
 
 	public void setValueFactory(RdbmsValueFactory vf) {
 		this.vf = vf;
 	}
 
 	public void setTransTableManager(TransTableManager tables) {
 		this.tables = tables;
 	}
 
 	public void setIdSequence(IdSequence ids) {
 		this.ids = ids;
 	}
 
 	public SelectQueryOptimizer createRdbmsFilterOptimizer() {
 		LabelExprFactory label = new LabelExprFactory();
 		BooleanExprFactory bool = createBooleanExprFactory();
 		URIExprFactory uri = new URIExprFactory();
 		SqlExprFactory sql = new SqlExprFactory();
 		DatatypeExprFactory datatype = new DatatypeExprFactory();
 		LanguageExprFactory language = new LanguageExprFactory();
 		sql.setBNodeExprFactory(new BNodeExprFactory());
 		sql.setBooleanExprFactory(bool);
 		sql.setDatatypeExprFactory(datatype);
 		sql.setLabelExprFactory(label);
 		sql.setLanguageExprFactory(language);
 		sql.setNumericExprFactory(new NumericExprFactory());
 		sql.setTimeExprFactory(new TimeExprFactory());
 		sql.setZonedExprFactory(new ZonedExprFactory(ids));
 		sql.setHashExprFactory(new HashExprFactory(vf));
+		sql.setPointExprFactory(new PointExprFactory());
 		sql.setURIExprFactory(uri);
 		label.setSqlExprFactory(sql);
 		uri.setSqlExprFactory(sql);
 		bool.setSqlExprFactory(sql);
 		SelectQueryOptimizer optimizer = new SelectQueryOptimizer();
 		optimizer.setSqlExprFactory(sql);
 		optimizer.setValueFactory(vf);
 		optimizer.setTransTableManager(tables);
 		optimizer.setIdSequence(ids);
 		return optimizer;
 	}
 
 	protected BooleanExprFactory createBooleanExprFactory() {
 		return new BooleanExprFactory();
 	}
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/optimizers/VarColumnLookupOptimizer.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/optimizers/VarColumnLookupOptimizer.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/optimizers/VarColumnLookupOptimizer.java (revision 85)
@@ -1,188 +1,230 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.optimizers;
 
 import org.openrdf.query.BindingSet;
 import org.openrdf.query.Dataset;
 import org.openrdf.query.algebra.TupleExpr;
 import org.openrdf.query.algebra.evaluation.QueryOptimizer;
 import org.openrdf.sail.rdbms.algebra.BNodeColumn;
 import org.openrdf.sail.rdbms.algebra.ColumnVar;
 import org.openrdf.sail.rdbms.algebra.DatatypeColumn;
 import org.openrdf.sail.rdbms.algebra.DateTimeColumn;
 import org.openrdf.sail.rdbms.algebra.HashColumn;
 import org.openrdf.sail.rdbms.algebra.IdColumn;
 import org.openrdf.sail.rdbms.algebra.LabelColumn;
 import org.openrdf.sail.rdbms.algebra.LanguageColumn;
 import org.openrdf.sail.rdbms.algebra.LongLabelColumn;
 import org.openrdf.sail.rdbms.algebra.LongURIColumn;
 import org.openrdf.sail.rdbms.algebra.NumericColumn;
+import org.openrdf.sail.rdbms.algebra.PointColumn;
 import org.openrdf.sail.rdbms.algebra.RefIdColumn;
 import org.openrdf.sail.rdbms.algebra.SelectQuery;
 import org.openrdf.sail.rdbms.algebra.SqlIsNull;
 import org.openrdf.sail.rdbms.algebra.SqlNull;
 import org.openrdf.sail.rdbms.algebra.URIColumn;
+import org.openrdf.sail.rdbms.algebra.UnionItem;
 import org.openrdf.sail.rdbms.algebra.base.FromItem;
 import org.openrdf.sail.rdbms.algebra.base.RdbmsQueryModelVisitorBase;
 import org.openrdf.sail.rdbms.algebra.base.ValueColumnBase;
 
 /**
  * Localises variables to use an available column in the current variable scope.
  * 
  * @author James Leigh
  * 
  */
-public class VarColumnLookupOptimizer extends
-		RdbmsQueryModelVisitorBase<RuntimeException> implements QueryOptimizer {
+public class VarColumnLookupOptimizer extends RdbmsQueryModelVisitorBase<RuntimeException> implements
+		QueryOptimizer
+{
+
 	private FromItem parent;
 	private FromItem gparent;
 
 	public VarColumnLookupOptimizer() {
 		super();
 	}
 
-	public void optimize(TupleExpr tupleExpr, Dataset dataset,
-			BindingSet bindings) {
+	public void optimize(TupleExpr tupleExpr, Dataset dataset, BindingSet bindings) {
 		parent = null;
 		tupleExpr.visit(this);
 	}
 
 	@Override
-	public void meetFromItem(FromItem node) throws RuntimeException {
+	public void meetFromItem(FromItem node)
+		throws RuntimeException
+	{
 		FromItem top = gparent;
 		gparent = parent;
 		parent = node;
 		super.meetFromItem(node);
 		parent = gparent;
 		gparent = top;
 	}
 
 	@Override
-	public void meet(SelectQuery node) throws RuntimeException {
+	public void meet(SelectQuery node)
+		throws RuntimeException
+	{
 		gparent = node.getFrom();
 		parent = node.getFrom();
 		super.meet(node);
 		parent = null;
 		gparent = null;
 	}
 
 	@Override
-	public void meet(BNodeColumn node) throws RuntimeException {
+	public void meet(BNodeColumn node)
+		throws RuntimeException
+	{
 		ColumnVar var = replaceVar(node);
 		if (var == null)
 			return;
 		if (!var.getTypes().isBNodes()) {
 			node.replaceWith(new SqlNull());
 		}
 	}
 
 	@Override
-	public void meet(DatatypeColumn node) throws RuntimeException {
+	public void meet(DatatypeColumn node)
+		throws RuntimeException
+	{
 		ColumnVar var = replaceVar(node);
 		if (var == null)
 			return;
 		if (!var.getTypes().isTyped()) {
 			node.replaceWith(new SqlNull());
 		}
 	}
 
 	@Override
-	public void meet(DateTimeColumn node) throws RuntimeException {
+	public void meet(DateTimeColumn node)
+		throws RuntimeException
+	{
 		ColumnVar var = replaceVar(node);
 		if (var == null)
 			return;
 		if (!var.getTypes().isCalendar()) {
 			node.replaceWith(new SqlNull());
 		}
 	}
 
 	@Override
-	public void meet(LabelColumn node) throws RuntimeException {
+	public void meet(LabelColumn node)
+		throws RuntimeException
+	{
 		ColumnVar var = replaceVar(node);
 		if (var == null)
 			return;
 		if (!var.getTypes().isLiterals()) {
 			node.replaceWith(new SqlNull());
 		}
 	}
 
 	@Override
-	public void meet(LongLabelColumn node) throws RuntimeException {
+	public void meet(LongLabelColumn node)
+		throws RuntimeException
+	{
 		ColumnVar var = replaceVar(node);
 		if (var == null)
 			return;
 		if (!var.getTypes().isLong() || !var.getTypes().isLiterals()) {
 			node.replaceWith(new SqlNull());
 		}
 	}
 
 	@Override
-	public void meet(LanguageColumn node) throws RuntimeException {
+	public void meet(LanguageColumn node)
+		throws RuntimeException
+	{
 		ColumnVar var = replaceVar(node);
 		if (var == null)
 			return;
 		if (!var.getTypes().isLanguages()) {
 			node.replaceWith(new SqlNull());
 		}
 	}
 
 	@Override
-	public void meet(NumericColumn node) throws RuntimeException {
+	public void meet(NumericColumn node)
+		throws RuntimeException
+	{
 		ColumnVar var = replaceVar(node);
 		if (var == null)
 			return;
 		if (!var.getTypes().isNumeric()) {
 			node.replaceWith(new SqlNull());
 		}
 	}
 
 	@Override
-	public void meet(LongURIColumn node) throws RuntimeException {
+	public void meet(LongURIColumn node)
+		throws RuntimeException
+	{
 		ColumnVar var = replaceVar(node);
 		if (var == null)
 			return;
 		if (!var.getTypes().isLong() || !var.getTypes().isURIs()) {
 			node.replaceWith(new SqlNull());
 		}
 	}
 
 	@Override
-	public void meet(URIColumn node) throws RuntimeException {
+	public void meet(URIColumn node)
+		throws RuntimeException
+	{
 		ColumnVar var = replaceVar(node);
 		if (var == null)
 			return;
 		if (!var.getTypes().isURIs()) {
 			node.replaceWith(new SqlNull());
 		}
 	}
-
-	@Override
-	public void meet(RefIdColumn node) throws RuntimeException {
+	
+	public void meet(PointColumn node) throws RuntimeException {
+		ColumnVar var = replaceVar(node);
+		if (var == null)
+			return;
+		if (!var.getTypes().isLiterals()) {
+			node.replaceWith(new SqlNull());
+		}
+	}	
+
+	@Override
+	public void meet(RefIdColumn node)
+		throws RuntimeException
+	{
 		replaceVar(node);
 	}
 
 	@Override
-	public void meet(HashColumn node) throws RuntimeException {
+	public void meet(HashColumn node)
+		throws RuntimeException
+	{
 		replaceVar(node);
 	}
 
 	private ColumnVar replaceVar(ValueColumnBase node) {
 		ColumnVar var;
-		if (gparent == parent) {
+		if (gparent == parent || gparent instanceof UnionItem) {
 			var = parent.getVar(node.getVarName());
-		} else {
+		}
+		else {
 			var = gparent.getVarForChildren(node.getVarName());
 		}
 		if (var == null) {
 			node.replaceWith(new SqlNull());
-		} else if (var.isImplied() && node.getParentNode() instanceof SqlIsNull) {
+		}
+		else if (var.isImplied() && node.getParentNode() instanceof SqlIsNull) {
 			node.replaceWith(new IdColumn(var.getAlias(), "subj"));
-		} else {
+		}
+		else {
 			node.setRdbmsVar(var);
 		}
 		return var;
 	}
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/optimizers/ValueIdLookupOptimizer.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/optimizers/ValueIdLookupOptimizer.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/optimizers/ValueIdLookupOptimizer.java (revision 85)
@@ -1,44 +1,44 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.optimizers;
 
 import org.openrdf.query.BindingSet;
 import org.openrdf.query.Dataset;
 import org.openrdf.query.algebra.TupleExpr;
 import org.openrdf.query.algebra.Var;
 import org.openrdf.query.algebra.evaluation.QueryOptimizer;
 import org.openrdf.query.algebra.helpers.QueryModelVisitorBase;
 import org.openrdf.sail.rdbms.RdbmsValueFactory;
 
 /**
  * Iterates through the query and converting the values into RDBMS values.
  * 
  * @author James Leigh
  * 
  */
 public class ValueIdLookupOptimizer implements QueryOptimizer {
 	RdbmsValueFactory vf;
 
 	public ValueIdLookupOptimizer(RdbmsValueFactory vf) {
 		super();
 		this.vf = vf;
 	}
 
-	public void optimize(TupleExpr tupleExpr, Dataset dataset,
-			BindingSet bindings) {
+	public void optimize(TupleExpr tupleExpr, Dataset dataset, BindingSet bindings) {
 		tupleExpr.visit(new VarVisitor());
 	}
 
 	protected class VarVisitor extends QueryModelVisitorBase<RuntimeException> {
 
 		@Override
 		public void meet(Var var) {
 			if (var.hasValue()) {
-				var.setValue(vf.asRdbmsValue(var.getValue()));
+				var.setValue(vf.asRdbmsValue(var.getValue(), null));
 			}
 		}
 	}
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/optimizers/SelectQueryOptimizer.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/optimizers/SelectQueryOptimizer.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/optimizers/SelectQueryOptimizer.java (revision 90)
@@ -1,496 +1,548 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.optimizers;
 
 import static org.openrdf.sail.rdbms.algebra.ColumnVar.createCtx;
 import static org.openrdf.sail.rdbms.algebra.ColumnVar.createObj;
 import static org.openrdf.sail.rdbms.algebra.ColumnVar.createPred;
 import static org.openrdf.sail.rdbms.algebra.ColumnVar.createSubj;
 import static org.openrdf.sail.rdbms.algebra.base.SqlExprSupport.coalesce;
 import static org.openrdf.sail.rdbms.algebra.base.SqlExprSupport.eq;
 import static org.openrdf.sail.rdbms.algebra.base.SqlExprSupport.isNull;
 import static org.openrdf.sail.rdbms.algebra.base.SqlExprSupport.or;
 
 import java.sql.SQLException;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 
 import org.openrdf.model.BNode;
 import org.openrdf.model.Literal;
 import org.openrdf.model.Resource;
 import org.openrdf.model.URI;
 import org.openrdf.model.Value;
 import org.openrdf.query.BindingSet;
 import org.openrdf.query.Dataset;
 import org.openrdf.query.algebra.And;
 import org.openrdf.query.algebra.Distinct;
+import org.openrdf.query.algebra.Extension;
 import org.openrdf.query.algebra.Filter;
 import org.openrdf.query.algebra.Join;
 import org.openrdf.query.algebra.LeftJoin;
 import org.openrdf.query.algebra.Order;
 import org.openrdf.query.algebra.OrderElem;
 import org.openrdf.query.algebra.Projection;
 import org.openrdf.query.algebra.ProjectionElem;
 import org.openrdf.query.algebra.ProjectionElemList;
 import org.openrdf.query.algebra.Slice;
 import org.openrdf.query.algebra.StatementPattern;
 import org.openrdf.query.algebra.TupleExpr;
+import org.openrdf.query.algebra.UnaryTupleOperator;
 import org.openrdf.query.algebra.Union;
 import org.openrdf.query.algebra.ValueExpr;
 import org.openrdf.query.algebra.Var;
 import org.openrdf.query.algebra.StatementPattern.Scope;
 import org.openrdf.query.algebra.evaluation.QueryOptimizer;
 import org.openrdf.sail.rdbms.RdbmsValueFactory;
 import org.openrdf.sail.rdbms.algebra.BNodeColumn;
 import org.openrdf.sail.rdbms.algebra.ColumnVar;
 import org.openrdf.sail.rdbms.algebra.DatatypeColumn;
 import org.openrdf.sail.rdbms.algebra.IdColumn;
 import org.openrdf.sail.rdbms.algebra.JoinItem;
 import org.openrdf.sail.rdbms.algebra.LabelColumn;
 import org.openrdf.sail.rdbms.algebra.LanguageColumn;
 import org.openrdf.sail.rdbms.algebra.LongLabelColumn;
 import org.openrdf.sail.rdbms.algebra.LongURIColumn;
 import org.openrdf.sail.rdbms.algebra.NumberValue;
 import org.openrdf.sail.rdbms.algebra.RefIdColumn;
 import org.openrdf.sail.rdbms.algebra.SelectProjection;
 import org.openrdf.sail.rdbms.algebra.SelectQuery;
 import org.openrdf.sail.rdbms.algebra.SqlEq;
 import org.openrdf.sail.rdbms.algebra.SqlOr;
 import org.openrdf.sail.rdbms.algebra.URIColumn;
 import org.openrdf.sail.rdbms.algebra.UnionItem;
 import org.openrdf.sail.rdbms.algebra.base.RdbmsQueryModelVisitorBase;
 import org.openrdf.sail.rdbms.algebra.base.SqlExpr;
 import org.openrdf.sail.rdbms.algebra.factories.SqlExprFactory;
 import org.openrdf.sail.rdbms.exceptions.RdbmsException;
 import org.openrdf.sail.rdbms.exceptions.RdbmsRuntimeException;
 import org.openrdf.sail.rdbms.exceptions.UnsupportedRdbmsOperatorException;
 import org.openrdf.sail.rdbms.managers.TransTableManager;
 import org.openrdf.sail.rdbms.model.RdbmsResource;
 import org.openrdf.sail.rdbms.schema.IdSequence;
 
 /**
  * Rewrites the core algebra model with a relation optimised model, using SQL.
  * 
  * @author James Leigh
  * 
  */
-public class SelectQueryOptimizer extends
-		RdbmsQueryModelVisitorBase<RuntimeException> implements QueryOptimizer {
+public class SelectQueryOptimizer extends RdbmsQueryModelVisitorBase<RuntimeException> implements
+		QueryOptimizer
+{
+
 	private static final String ALIAS = "t";
 	private SqlExprFactory sql;
 	private int aliasCount = 0;
 	private BindingSet bindings;
 	private Dataset dataset;
 	private RdbmsValueFactory vf;
 	private TransTableManager tables;
 	private IdSequence ids;
 
 	public void setSqlExprFactory(SqlExprFactory sql) {
 		this.sql = sql;
 	}
 
 	public void setValueFactory(RdbmsValueFactory vf) {
 		this.vf = vf;
 	}
 
 	public void setTransTableManager(TransTableManager statements) {
 		this.tables = statements;
 	}
 
 	public void setIdSequence(IdSequence ids) {
 		this.ids = ids;
 	}
 
-	public void optimize(TupleExpr tupleExpr, Dataset dataset,
-			BindingSet bindings) {
+	public void optimize(TupleExpr tupleExpr, Dataset dataset, BindingSet bindings) {
 		this.dataset = dataset;
 		this.bindings = bindings;
 		tupleExpr.visit(this);
 	}
 
 	@Override
-	public void meet(Distinct node) throws RuntimeException {
+	public void meet(Distinct node)
+		throws RuntimeException
+	{
 		super.meet(node);
 		if (node.getArg() instanceof SelectQuery) {
-			SelectQuery query = (SelectQuery) node.getArg();
+			SelectQuery query = (SelectQuery)node.getArg();
 			query.setDistinct(true);
 			node.replaceWith(query);
 		}
 	}
 
 	@Override
-	public void meet(Union node) throws RuntimeException {
+	public void meet(Union node)
+		throws RuntimeException
+	{
 		super.meet(node);
 		TupleExpr l = node.getLeftArg();
 		TupleExpr r = node.getRightArg();
 		if (!(l instanceof SelectQuery && r instanceof SelectQuery))
 			return;
-		SelectQuery left = (SelectQuery) l;
-		SelectQuery right = (SelectQuery) r;
+		SelectQuery left = (SelectQuery)l;
+		SelectQuery right = (SelectQuery)r;
 		if (left.isComplex() || right.isComplex())
 			return;
 		UnionItem union = new UnionItem("u" + aliasCount++);
 		union.addUnion(left.getFrom().clone());
 		union.addUnion(right.getFrom().clone());
 		SelectQuery query = new SelectQuery();
 		query.setFrom(union);
 		mergeSelectClause(query, left);
 		mergeSelectClause(query, right);
 		node.replaceWith(query);
 	}
 
 	@Override
-	public void meet(Join node) throws RuntimeException {
+	public void meet(Join node)
+		throws RuntimeException
+	{
 		super.meet(node);
 		TupleExpr l = node.getLeftArg();
 		TupleExpr r = node.getRightArg();
 		if (!(l instanceof SelectQuery && r instanceof SelectQuery))
 			return;
-		SelectQuery left = (SelectQuery) l;
-		SelectQuery right = (SelectQuery) r;
+		SelectQuery left = (SelectQuery)l;
+		SelectQuery right = (SelectQuery)r;
 		if (left.isComplex() || right.isComplex())
 			return;
 		left = left.clone();
 		right = right.clone();
 		filterOn(left, right);
 		mergeSelectClause(left, right);
 		left.addJoin(right);
 		node.replaceWith(left);
 	}
 
 	@Override
-	public void meet(LeftJoin node) throws RuntimeException {
+	public void meet(LeftJoin node)
+		throws RuntimeException
+	{
 		super.meet(node);
 		TupleExpr l = node.getLeftArg();
 		TupleExpr r = node.getRightArg();
 		if (!(l instanceof SelectQuery && r instanceof SelectQuery))
 			return;
-		SelectQuery left = (SelectQuery) l;
-		SelectQuery right = (SelectQuery) r;
+		SelectQuery left = (SelectQuery)l;
+		SelectQuery right = (SelectQuery)r;
 		if (left.isComplex() || right.isComplex())
 			return;
 		left = left.clone();
 		right = right.clone();
 		filterOn(left, right);
 		mergeSelectClause(left, right);
 		left.addLeftJoin(right);
 		List<SqlExpr> filters = new ArrayList<SqlExpr>();
 		if (node.getCondition() != null) {
 			for (ValueExpr expr : flatten(node.getCondition())) {
 				try {
 					filters.add(sql.createBooleanExpr(expr));
-				} catch (UnsupportedRdbmsOperatorException e) {
+				}
+				catch (UnsupportedRdbmsOperatorException e) {
 					return;
 				}
 			}
 		}
 		for (SqlExpr filter : filters) {
 			right.addFilter(filter);
 		}
 		node.replaceWith(left);
 	}
 
 	@Override
 	public void meet(StatementPattern sp) {
 		super.meet(sp);
 		Var subjVar = sp.getSubjectVar();
 		Var predVar = sp.getPredicateVar();
 		Var objVar = sp.getObjectVar();
 		Var ctxVar = sp.getContextVar();
 
 		Value subjValue = getVarValue(subjVar, bindings);
 		Value predValue = getVarValue(predVar, bindings);
 		Value objValue = getVarValue(objVar, bindings);
 		Value ctxValue = getVarValue(ctxVar, bindings);
 
-		if (subjValue instanceof Literal || predValue instanceof Literal
-				|| predValue instanceof BNode || ctxValue instanceof Literal) {
+		if (subjValue instanceof Literal || predValue instanceof Literal || predValue instanceof BNode
+				|| ctxValue instanceof Literal)
+		{
 			// subj and ctx must be a Resource and pred must be a URI
 			return;
 		}
 
 		Resource[] contexts = getContexts(sp, ctxValue);
 		if (contexts == null)
 			return;
 
 		String alias = getTableAlias(predValue) + aliasCount++;
 		Number predId = getInternalId(predValue);
 		String tableName;
 		boolean present;
 		try {
 			tableName = tables.getTableName(predId);
 			present = tables.isPredColumnPresent(predId);
-		} catch (SQLException e) {
+		}
+		catch (SQLException e) {
 			throw new RdbmsRuntimeException(e);
 		}
 		JoinItem from = new JoinItem(alias, tableName, predId);
 
-		ColumnVar s = createSubj(alias, subjVar, (Resource) subjValue);
-		ColumnVar p = createPred(alias, predVar, (URI) predValue, !present);
+		ColumnVar s = createSubj(alias, subjVar, (Resource)subjValue);
+		ColumnVar p = createPred(alias, predVar, (URI)predValue, !present);
 		ColumnVar o = createObj(alias, objVar, objValue);
-		ColumnVar c = createCtx(alias, ctxVar, (Resource) ctxValue);
+		ColumnVar c = createCtx(alias, ctxVar, (Resource)ctxValue);
 
 		s.setTypes(tables.getSubjTypes(predId));
 		o.setTypes(tables.getObjTypes(predId));
 
 		SelectQuery query = new SelectQuery();
 		query.setFrom(from);
 		Map<String, ColumnVar> vars = new HashMap<String, ColumnVar>(4);
 		for (ColumnVar var : new ColumnVar[] { s, p, o, c }) {
 			from.addVar(var);
 			Value value = var.getValue();
 			if (vars.containsKey(var.getName())) {
 				IdColumn existing = new IdColumn(vars.get(var.getName()));
 				from.addFilter(new SqlEq(new IdColumn(var), existing));
-			} else if (value != null && !var.isImplied()) {
+			}
+			else if (value != null && !var.isImplied()) {
 				try {
 					NumberValue vc = new NumberValue(vf.getInternalId(value));
 					from.addFilter(new SqlEq(new RefIdColumn(var), vc));
-				} catch (RdbmsException e) {
+				}
+				catch (RdbmsException e) {
 					throw new RdbmsRuntimeException(e);
 				}
-			} else {
+			}
+			else {
 				vars.put(var.getName(), var);
 			}
 			if (!var.isHidden() && value == null) {
 				SelectProjection proj = new SelectProjection();
 				proj.setVar(var);
 				proj.setId(new RefIdColumn(var));
-				proj.setStringValue(coalesce(new URIColumn(var),
-						new BNodeColumn(var), new LabelColumn(var),
+				proj.setStringValue(coalesce(new URIColumn(var), new BNodeColumn(var), new LabelColumn(var),
 						new LongLabelColumn(var), new LongURIColumn(var)));
 				proj.setDatatype(new DatatypeColumn(var));
 				proj.setLanguage(new LanguageColumn(var));
 				query.addSqlSelectVar(proj);
 			}
 		}
 		if (contexts.length > 0) {
 			RdbmsResource[] ids = vf.asRdbmsResource(contexts);
 			RefIdColumn var = new RefIdColumn(c);
 			SqlExpr in = null;
 			for (RdbmsResource id : ids) {
 				NumberValue longValue;
 				try {
 					longValue = new NumberValue(vf.getInternalId(id));
-				} catch (RdbmsException e) {
+				}
+				catch (RdbmsException e) {
 					throw new RdbmsRuntimeException(e);
 				}
 				SqlEq eq = new SqlEq(var.clone(), longValue);
 				if (in == null) {
 					in = eq;
-				} else {
+				}
+				else {
 					in = new SqlOr(in, eq);
 				}
 			}
 			from.addFilter(in);
 		}
 		sp.replaceWith(query);
 	}
 
 	@Override
-	public void meet(Filter node) throws RuntimeException {
+	public void meet(Filter node)
+		throws RuntimeException
+	{
 		super.meet(node);
 		if (node.getArg() instanceof SelectQuery) {
-			SelectQuery query = (SelectQuery) node.getArg();
+			SelectQuery query = (SelectQuery)node.getArg();
 			ValueExpr condition = null;
 			for (ValueExpr expr : flatten(node.getCondition())) {
 				try {
 					query.addFilter(sql.createBooleanExpr(expr));
-				} catch (UnsupportedRdbmsOperatorException e) {
+				}
+				catch (UnsupportedRdbmsOperatorException e) {
 					if (condition == null) {
 						condition = expr;
-					} else {
+					}
+					else {
 						condition = new And(condition, expr);
 					}
 				}
 			}
 			if (condition == null) {
 				node.replaceWith(node.getArg());
-			} else {
+			}
+			else {
 				node.setCondition(condition);
 			}
 		}
 	}
 
 	@Override
-	public void meet(Projection node) throws RuntimeException {
+	public void meet(Projection node)
+		throws RuntimeException
+	{
 		super.meet(node);
 		if (node.getArg() instanceof SelectQuery) {
-			SelectQuery query = (SelectQuery) node.getArg();
+			SelectQuery query = (SelectQuery)node.getArg();
 			Map<String, String> bindingNames = new HashMap<String, String>();
 			List<SelectProjection> selection = new ArrayList<SelectProjection>();
 			ProjectionElemList list = node.getProjectionElemList();
 			for (ProjectionElem e : list.getElements()) {
 				String source = e.getSourceName();
 				String target = e.getTargetName();
 				bindingNames.put(source, target);
 				SelectProjection s = query.getSelectProjection(source);
 				if (s != null) {
 					selection.add(s);
 				}
 			}
 			query.setBindingNames(bindingNames);
 			query.setSqlSelectVar(selection);
 			node.replaceWith(query);
 		}
 	}
 
 	@Override
-	public void meet(Slice node) throws RuntimeException {
+	public void meet(Slice node)
+		throws RuntimeException
+	{
 		super.meet(node);
 		if (node.getArg() instanceof SelectQuery) {
-			SelectQuery query = (SelectQuery) node.getArg();
+			SelectQuery query = (SelectQuery)node.getArg();
 			if (node.getOffset() > 0) {
 				query.setOffset(node.getOffset());
 			}
 			if (node.getLimit() >= 0) {
 				query.setLimit(node.getLimit());
 			}
 			node.replaceWith(query);
 		}
-	}
-
-	@Override
-	public void meet(Order node) throws RuntimeException {
+		if (node.getArg() instanceof UnaryTupleOperator &&
+			((UnaryTupleOperator)node.getArg()).getArg() instanceof Extension &&
+			((Extension)((UnaryTupleOperator)node.getArg()).getArg()).getArg() instanceof SelectQuery) {
+				SelectQuery query = (SelectQuery) ((Extension)((UnaryTupleOperator)node.getArg()).getArg()).getArg();
+				if (node.getOffset() > 0) {
+					query.setOffset(node.getOffset());
+				}
+				if (node.getLimit() >= 0) {
+					query.setLimit(node.getLimit());
+				}
+				node.replaceWith(node.getArg());				
+			}
+	}
+
+	@Override
+	public void meet(Order node)
+		throws RuntimeException
+	{
 		super.meet(node);
 		if (!(node.getArg() instanceof SelectQuery))
 			return;
-		SelectQuery query = (SelectQuery) node.getArg();
+		SelectQuery query = (SelectQuery)node.getArg();
 		try {
 			for (OrderElem e : node.getElements()) {
 				ValueExpr expr = e.getExpr();
 				boolean asc = e.isAscending();
 				query.addOrder(sql.createBNodeExpr(expr), asc);
 				query.addOrder(sql.createUriExpr(expr), asc);
 				query.addOrder(sql.createNumericExpr(expr), asc);
 				query.addOrder(sql.createDatatypeExpr(expr), asc);
 				query.addOrder(sql.createTimeExpr(expr), asc);
 				query.addOrder(sql.createLanguageExpr(expr), asc);
 				query.addOrder(sql.createLabelExpr(expr), asc);
 			}
 			node.replaceWith(query);
-		} catch (UnsupportedRdbmsOperatorException e) {
+		}
+		catch (UnsupportedRdbmsOperatorException e) {
 			// unsupported
 		}
 	}
 
 	private void filterOn(SelectQuery left, SelectQuery right) {
 		Map<String, ColumnVar> lvars = left.getVarMap();
 		Map<String, ColumnVar> rvars = right.getVarMap();
 		Set<String> names = new HashSet<String>(rvars.keySet());
 		names.retainAll(lvars.keySet());
 		for (String name : names) {
 			ColumnVar l = lvars.get(name);
 			ColumnVar r = rvars.get(name);
 			if (!l.isImplied() && !r.isImplied()) {
 				IdColumn rid = new IdColumn(r);
 				SqlExpr filter = eq(rid, new IdColumn(l));
 				if (r.isNullable()) {
 					filter = or(isNull(rid), filter);
 				}
 				right.addFilter(filter);
 			}
 		}
 	}
 
 	private Number getInternalId(Value predValue) {
 		try {
 			return vf.getInternalId(predValue);
-		} catch (RdbmsException e) {
+		}
+		catch (RdbmsException e) {
 			throw new RdbmsRuntimeException(e);
 		}
 	}
 
 	private Resource[] getContexts(StatementPattern sp, Value ctxValue) {
 		if (dataset == null) {
 			if (ctxValue != null)
-				return new Resource[] { (Resource) ctxValue };
+				return new Resource[] { (Resource)ctxValue };
 			return new Resource[0];
 		}
 		Set<URI> graphs = getGraphs(sp);
 		if (graphs.isEmpty())
 			return null; // Search zero contexts
 		if (ctxValue == null)
 			return graphs.toArray(new Resource[graphs.size()]);
 
 		if (graphs.contains(ctxValue))
-			return new Resource[] { (Resource) ctxValue };
+			return new Resource[] { (Resource)ctxValue };
 		// pattern specifies a context that is not part of the dataset
 		return null;
 	}
 
 	private Set<URI> getGraphs(StatementPattern sp) {
 		if (sp.getScope() == Scope.DEFAULT_CONTEXTS)
 			return dataset.getDefaultGraphs();
 		return dataset.getNamedGraphs();
 	}
 
 	private String getTableAlias(Value predValue) {
 		if (predValue != null) {
-			String localName = ((URI) predValue).getLocalName();
+			String localName = ((URI)predValue).getLocalName();
 			if (localName.length() >= 1) {
 				String alias = localName.substring(0, 1);
 				if (isLetters(alias)) {
 					return alias;
 				}
 			}
 		}
 		return ALIAS;
 	}
 
 	private Value getVarValue(Var var, BindingSet bindings) {
 		if (var == null) {
 			return null;
-		} else if (var.hasValue()) {
+		}
+		else if (var.hasValue()) {
 			return var.getValue();
-		} else {
+		}
+		else {
 			return bindings.getValue(var.getName());
 		}
 	}
 
 	private boolean isLetters(String alias) {
 		for (int i = 0, n = alias.length(); i < n; i++) {
 			if (!Character.isLetter(alias.charAt(i)))
 				return false;
 		}
 		return true;
 	}
 
 	private void mergeSelectClause(SelectQuery left, SelectQuery right) {
 		for (SelectProjection proj : right.getSqlSelectVar()) {
 			if (!left.hasSqlSelectVar(proj)) {
 				proj = proj.clone();
 				ColumnVar var = proj.getVar();
 				String name = var.getName();
 				ColumnVar existing = left.getVar(name);
 				if (existing != null) {
 					proj.setVar(existing);
 				}
 				left.addSqlSelectVar(proj);
 			}
 		}
 	}
 
 	private List<ValueExpr> flatten(ValueExpr condition) {
 		return flatten(condition, new ArrayList<ValueExpr>());
 	}
 
-	private List<ValueExpr> flatten(ValueExpr condition,
-			List<ValueExpr> conditions) {
+	private List<ValueExpr> flatten(ValueExpr condition, List<ValueExpr> conditions) {
 		if (condition instanceof And) {
-			And and = (And) condition;
+			And and = (And)condition;
 			flatten(and.getLeftArg(), conditions);
 			flatten(and.getRightArg(), conditions);
-		} else {
+		}
+		else {
 			conditions.add(condition);
 		}
 		return conditions;
 	}
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/optimizers/SqlConstantOptimizer.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/optimizers/SqlConstantOptimizer.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/optimizers/SqlConstantOptimizer.java (revision 85)
@@ -1,309 +1,358 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.optimizers;
 
 import static org.openrdf.sail.rdbms.algebra.base.SqlExprSupport.and;
 import static org.openrdf.sail.rdbms.algebra.base.SqlExprSupport.isNull;
 import static org.openrdf.sail.rdbms.algebra.base.SqlExprSupport.not;
 import static org.openrdf.sail.rdbms.algebra.base.SqlExprSupport.or;
 import static org.openrdf.sail.rdbms.algebra.base.SqlExprSupport.str;
 
 import java.util.List;
 import java.util.Locale;
 
 import org.openrdf.query.BindingSet;
 import org.openrdf.query.Dataset;
 import org.openrdf.query.algebra.QueryModelNode;
 import org.openrdf.query.algebra.TupleExpr;
 import org.openrdf.query.algebra.evaluation.QueryOptimizer;
 import org.openrdf.sail.rdbms.algebra.FalseValue;
 import org.openrdf.sail.rdbms.algebra.SelectQuery;
 import org.openrdf.sail.rdbms.algebra.SqlAnd;
 import org.openrdf.sail.rdbms.algebra.SqlCase;
 import org.openrdf.sail.rdbms.algebra.SqlCompare;
 import org.openrdf.sail.rdbms.algebra.SqlConcat;
 import org.openrdf.sail.rdbms.algebra.SqlEq;
 import org.openrdf.sail.rdbms.algebra.SqlIsNull;
 import org.openrdf.sail.rdbms.algebra.SqlLowerCase;
 import org.openrdf.sail.rdbms.algebra.SqlNot;
 import org.openrdf.sail.rdbms.algebra.SqlNull;
 import org.openrdf.sail.rdbms.algebra.SqlOr;
 import org.openrdf.sail.rdbms.algebra.StringValue;
 import org.openrdf.sail.rdbms.algebra.TrueValue;
 import org.openrdf.sail.rdbms.algebra.SqlCase.Entry;
 import org.openrdf.sail.rdbms.algebra.base.BinarySqlOperator;
 import org.openrdf.sail.rdbms.algebra.base.FromItem;
 import org.openrdf.sail.rdbms.algebra.base.RdbmsQueryModelVisitorBase;
 import org.openrdf.sail.rdbms.algebra.base.SqlConstant;
 import org.openrdf.sail.rdbms.algebra.base.SqlExpr;
 import org.openrdf.sail.rdbms.algebra.base.UnarySqlOperator;
 
 /**
  * Optimises SQL constants, include operations with static values and null
  * operations.
  * 
  * @author James Leigh
  * 
  */
-public class SqlConstantOptimizer extends
-		RdbmsQueryModelVisitorBase<RuntimeException> implements QueryOptimizer {
-
-	@Override
-	public void meet(SelectQuery node) throws RuntimeException {
+public class SqlConstantOptimizer extends RdbmsQueryModelVisitorBase<RuntimeException> implements
+		QueryOptimizer
+{
+
+	@Override
+	public void meet(SelectQuery node)
+		throws RuntimeException
+	{
 		super.meet(node);
 		List<SqlExpr> filters = node.getFilters();
 		for (int i = filters.size() - 1; i >= 0; i--) {
 			if (filters.get(i) instanceof TrueValue) {
 				node.removeFilter(filters.get(i));
 			}
 		}
 	}
 
 	@Override
-	public void meet(SqlAnd node) throws RuntimeException {
+	public void meet(SqlAnd node)
+		throws RuntimeException
+	{
 		super.meet(node);
 		SqlExpr left = node.getLeftArg();
 		SqlExpr right = node.getRightArg();
 		if (left instanceof FalseValue || right instanceof FalseValue) {
 			replace(node, new FalseValue());
-		} else if (left instanceof TrueValue && right instanceof TrueValue) {
+		}
+		else if (left instanceof TrueValue && right instanceof TrueValue) {
 			replace(node, new TrueValue());
-		} else if (left instanceof TrueValue) {
+		}
+		else if (left instanceof TrueValue) {
 			replace(node, right.clone());
-		} else if (right instanceof TrueValue) {
+		}
+		else if (right instanceof TrueValue) {
 			replace(node, left.clone());
-		} else if (right instanceof SqlNull || left instanceof SqlNull) {
-			replace(node, new SqlNull());
-		} else if (right instanceof SqlNot && ((SqlNot) right).getArg().equals(left)) {
-			replace(node, new FalseValue());
-		} else if (left instanceof SqlNot && ((SqlNot) left).getArg().equals(right)) {
-			replace(node, new FalseValue());
-		}
-	}
-
-	@Override
-	public void meet(SqlCase node) throws RuntimeException {
+		}
+		else if (right instanceof SqlNull || left instanceof SqlNull) {
+			replace(node, new SqlNull());
+		}
+		else if (right instanceof SqlNot && ((SqlNot)right).getArg().equals(left)) {
+			replace(node, new FalseValue());
+		}
+		else if (left instanceof SqlNot && ((SqlNot)left).getArg().equals(right)) {
+			replace(node, new FalseValue());
+		}
+	}
+
+	@Override
+	public void meet(SqlCase node)
+		throws RuntimeException
+	{
 		super.meet(node);
 		List<Entry> entries = node.getEntries();
 		for (SqlCase.Entry e : entries) {
 			if (e.getCondition() instanceof SqlNull) {
 				node.removeEntry(e);
-			} else if (e.getCondition() instanceof FalseValue) {
+			}
+			else if (e.getCondition() instanceof FalseValue) {
 				node.removeEntry(e);
-			} else if (e.getCondition() instanceof TrueValue) {
+			}
+			else if (e.getCondition() instanceof TrueValue) {
 				node.truncateEntries(e);
 				break;
 			}
 		}
 		entries = node.getEntries();
 		if (entries.isEmpty()) {
 			replace(node, new SqlNull());
-		} else if (entries.size() == 1) {
+		}
+		else if (entries.size() == 1) {
 			Entry entry = entries.get(0);
 			if (entry.getCondition() instanceof TrueValue) {
 				replace(node, entry.getResult().clone());
-			} else if (entry.getCondition() instanceof FalseValue) {
+			}
+			else if (entry.getCondition() instanceof FalseValue) {
 				replace(node, new SqlNull());
-			} else if (entry.getCondition() instanceof SqlNot) {
-				SqlNot not = (SqlNot) entry.getCondition();
+			}
+			else if (entry.getCondition() instanceof SqlNot) {
+				SqlNot not = (SqlNot)entry.getCondition();
 				if (not.getArg() instanceof SqlIsNull) {
-					SqlIsNull is = (SqlIsNull) not.getArg();
+					SqlIsNull is = (SqlIsNull)not.getArg();
 					if (is.getArg().equals(entry.getResult())) {
 						replace(node, entry.getResult().clone());
 					}
 				}
 			}
 		}
 	}
 
 	@Override
-	public void meet(SqlCompare node) throws RuntimeException {
+	public void meet(SqlCompare node)
+		throws RuntimeException
+	{
 		super.meet(node);
 		SqlExpr left = node.getLeftArg();
 		SqlExpr right = node.getRightArg();
 		if (left instanceof SqlNull || right instanceof SqlNull) {
 			replace(node, new SqlNull());
 		}
 	}
 
 	@Override
-	public void meet(SqlConcat node) throws RuntimeException {
+	public void meet(SqlConcat node)
+		throws RuntimeException
+	{
 		super.meet(node);
 		SqlExpr left = node.getLeftArg();
 		SqlExpr right = node.getRightArg();
 		if (left instanceof StringValue && right instanceof StringValue) {
-			StringValue l = (StringValue) left;
-			StringValue r = (StringValue) right;
+			StringValue l = (StringValue)left;
+			StringValue r = (StringValue)right;
 			replace(node, new StringValue(l.getValue() + r.getValue()));
 		}
 	}
 
 	@Override
-	public void meet(SqlEq node) throws RuntimeException {
+	public void meet(SqlEq node)
+		throws RuntimeException
+	{
 		super.meet(node);
 		SqlExpr left = node.getLeftArg();
 		SqlExpr right = node.getRightArg();
 		if (left instanceof SqlNull || right instanceof SqlNull) {
 			replace(node, new SqlNull());
-		} else if (left instanceof SqlConstant<?>
-				&& right instanceof SqlConstant<?>) {
-			SqlConstant<?> l = (SqlConstant<?>) left;
-			SqlConstant<?> r = (SqlConstant<?>) right;
+		}
+		else if (left instanceof SqlConstant<?> && right instanceof SqlConstant<?>) {
+			SqlConstant<?> l = (SqlConstant<?>)left;
+			SqlConstant<?> r = (SqlConstant<?>)right;
 			if (l.getValue().equals(r.getValue())) {
 				replace(node, new TrueValue());
-			} else {
+			}
+			else {
 				replace(node, new FalseValue());
 			}
 		}
 	}
 
 	@Override
-	public void meet(SqlIsNull node) throws RuntimeException {
+	public void meet(SqlIsNull node)
+		throws RuntimeException
+	{
 		super.meet(node);
 		SqlExpr arg = node.getArg();
 		if (arg instanceof SqlNull) {
 			replace(node, new TrueValue());
-		} else if (arg instanceof SqlConstant<?>) {
-			replace(node, new FalseValue());
-		} else if (arg instanceof SqlCase) {
+		}
+		else if (arg instanceof SqlConstant<?>) {
+			replace(node, new FalseValue());
+		}
+		else if (arg instanceof SqlCase) {
 			SqlExpr rep = null;
 			SqlExpr prev = null;
-			SqlCase scase = (SqlCase) arg;
+			SqlCase scase = (SqlCase)arg;
 			for (Entry entry : scase.getEntries()) {
 				SqlExpr condition = entry.getCondition();
 				if (rep == null) {
 					rep = and(condition.clone(), isNull(entry.getResult().clone()));
 					prev = not(condition.clone());
-				} else {
+				}
+				else {
 					rep = or(rep, and(and(prev.clone(), condition.clone()), isNull(entry.getResult().clone())));
 					prev = and(prev, not(condition.clone()));
 				}
 			}
 			replace(node, or(rep, prev.clone()));
 		}
 	}
 
 	@Override
-	public void meet(SqlLowerCase node) throws RuntimeException {
+	public void meet(SqlLowerCase node)
+		throws RuntimeException
+	{
 		super.meet(node);
 		if (node.getArg() instanceof SqlNull) {
 			replace(node, new SqlNull());
-		} else if (node.getArg() instanceof SqlConstant) {
-			SqlConstant arg = (SqlConstant) node.getArg();
+		}
+		else if (node.getArg() instanceof SqlConstant) {
+			SqlConstant arg = (SqlConstant)node.getArg();
 			String lower = arg.getValue().toString().toLowerCase(Locale.US);
 			replace(node, str(lower));
 		}
 	}
 
 	@Override
-	public void meet(SqlNot node) throws RuntimeException {
+	public void meet(SqlNot node)
+		throws RuntimeException
+	{
 		super.meet(node);
 		SqlExpr arg = node.getArg();
 		if (arg instanceof TrueValue) {
 			replace(node, new FalseValue());
-		} else if (arg instanceof FalseValue) {
+		}
+		else if (arg instanceof FalseValue) {
 			replace(node, new TrueValue());
-		} else if (arg instanceof SqlNull) {
-			replace(node, new SqlNull());
-		} else if (arg instanceof SqlNot) {
-			SqlNot not = (SqlNot) arg;
+		}
+		else if (arg instanceof SqlNull) {
+			replace(node, new SqlNull());
+		}
+		else if (arg instanceof SqlNot) {
+			SqlNot not = (SqlNot)arg;
 			replace(node, not.getArg().clone());
-		} else if (arg instanceof SqlOr) {
-			SqlOr or = (SqlOr) arg;
+		}
+		else if (arg instanceof SqlOr) {
+			SqlOr or = (SqlOr)arg;
 			replace(node, and(not(or.getLeftArg().clone()), not(or.getRightArg().clone())));
 		}
 	}
 
 	@Override
-	public void meet(SqlOr node) throws RuntimeException {
+	public void meet(SqlOr node)
+		throws RuntimeException
+	{
 		super.meet(node);
 		SqlExpr left = node.getLeftArg();
 		SqlExpr right = node.getRightArg();
 		if (left instanceof TrueValue || right instanceof TrueValue) {
 			replace(node, new TrueValue());
-		} else if (left instanceof FalseValue && right instanceof FalseValue) {
-			replace(node, new FalseValue());
-		} else if (left instanceof FalseValue) {
+		}
+		else if (left instanceof FalseValue && right instanceof FalseValue) {
+			replace(node, new FalseValue());
+		}
+		else if (left instanceof FalseValue) {
 			replace(node, right.clone());
-		} else if (right instanceof FalseValue) {
+		}
+		else if (right instanceof FalseValue) {
 			replace(node, left.clone());
-		} else if (right instanceof SqlNull && andAllTheWay(node)) {
+		}
+		else if (right instanceof SqlNull && andAllTheWay(node)) {
 			replace(node, left.clone());
-		} else if (left instanceof SqlNull && andAllTheWay(node)) {
+		}
+		else if (left instanceof SqlNull && andAllTheWay(node)) {
 			replace(node, right.clone());
-		} else if (right instanceof SqlNull && left instanceof SqlNull) {
-			replace(node, new SqlNull());
-		} else if (left instanceof SqlNull && right instanceof SqlOr) {
-			SqlOr r = (SqlOr) right;
+		}
+		else if (right instanceof SqlNull && left instanceof SqlNull) {
+			replace(node, new SqlNull());
+		}
+		else if (left instanceof SqlNull && right instanceof SqlOr) {
+			SqlOr r = (SqlOr)right;
 			SqlExpr rleft = r.getLeftArg();
 			SqlExpr rright = r.getRightArg();
 			if (rleft instanceof SqlNull || rright instanceof SqlNull) {
 				replace(node, right.clone());
 			}
-		} else if (right instanceof SqlNull && left instanceof SqlOr) {
-			SqlOr l = (SqlOr) left;
+		}
+		else if (right instanceof SqlNull && left instanceof SqlOr) {
+			SqlOr l = (SqlOr)left;
 			SqlExpr lleft = l.getLeftArg();
 			SqlExpr lright = l.getRightArg();
 			if (lleft instanceof SqlNull || lright instanceof SqlNull) {
 				replace(node, left.clone());
 			}
-		} else if (right instanceof SqlNull && left instanceof SqlAnd) {
+		}
+		else if (right instanceof SqlNull && left instanceof SqlAnd) {
 			// value IS NOT NULL AND value = ? OR NULL
 			// -> value = ?
-			SqlAnd l = (SqlAnd) left;
+			SqlAnd l = (SqlAnd)left;
 			SqlExpr lleft = l.getLeftArg();
 			SqlExpr lright = l.getRightArg();
 			SqlExpr isNotNull = arg(arg(lleft, SqlNot.class), SqlIsNull.class);
 			SqlExpr isNotEq = other(lright, isNotNull, SqlEq.class);
 			if (isNotEq instanceof SqlConstant) {
 				replace(node, lright);
 			}
 		}
 	}
 
 	public void optimize(SqlExpr sqlExpr) {
 		sqlExpr.visit(this);
 	}
 
-	public void optimize(TupleExpr tupleExpr, Dataset dataset,
-			BindingSet bindings) {
+	public void optimize(TupleExpr tupleExpr, Dataset dataset, BindingSet bindings) {
 		tupleExpr.visit(this);
 	}
 
 	private boolean andAllTheWay(QueryModelNode node) {
 		if (node.getParentNode() instanceof SelectQuery)
 			return true;
 		if (node.getParentNode() instanceof FromItem)
 			return true;
 		if (node.getParentNode() instanceof SqlAnd)
 			return andAllTheWay(node.getParentNode());
 		return false;
 	}
 
 	private SqlExpr arg(SqlExpr node, Class<? extends UnarySqlOperator> type) {
 		if (type.isInstance(node))
 			return type.cast(node).getArg();
 		return null;
 	}
 
 	private SqlExpr other(SqlExpr node, SqlExpr compare, Class<? extends BinarySqlOperator> type) {
 		if (type.isInstance(node)) {
 			BinarySqlOperator cast = type.cast(node);
 			SqlExpr left = cast.getLeftArg();
 			SqlExpr right = cast.getRightArg();
 			if (left.equals(compare))
 				return right;
 			if (right.equals(compare))
 				return left;
 		}
 		return null;
 	}
 
 	private void replace(SqlExpr before, SqlExpr after) {
 		before.replaceWith(after);
 		after.visit(this);
 	}
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/mysql/MySqlProvider.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/mysql/MySqlProvider.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/mysql/MySqlProvider.java (revision 85)
@@ -1,27 +1,26 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.mysql;
 
 import org.openrdf.sail.rdbms.RdbmsConnectionFactory;
 import org.openrdf.sail.rdbms.RdbmsProvider;
 
 /**
  * Checks the database product name and version to be compatible with this
  * Sesame store.
  * 
  * @author James Leigh
  * 
  */
 public class MySqlProvider implements RdbmsProvider {
 
-	public RdbmsConnectionFactory createRdbmsConnectionFactory(String dbName,
-			String dbVersion) {
+	public RdbmsConnectionFactory createRdbmsConnectionFactory(String dbName, String dbVersion) {
 		if ("MySQL".equalsIgnoreCase(dbName))
 			return new MySqlConnectionFactory();
 		return null;
 	}
 
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/mysql/MySqlStore.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/mysql/MySqlStore.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/mysql/MySqlStore.java (revision 121)
@@ -1,122 +1,143 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.mysql;
 
 import org.apache.commons.dbcp.BasicDataSource;
 import org.openrdf.sail.SailException;
 import org.openrdf.sail.rdbms.RdbmsStore;
 import org.openrdf.sail.rdbms.exceptions.RdbmsException;
 
 /**
  * A convenient way to initialise a MySql RDF store.
  * 
  * @author James Leigh
  * 
  */
 public class MySqlStore extends RdbmsStore {
 	private String name = genName();
 	private String serverName = "localhost";
 	private String databaseName;
 	private int portNumber;
 	private String user;
 	private String password;
 
 	public MySqlStore() {
 		super();
 	}
 
 	public MySqlStore(String databaseName) {
 		setDatabaseName(databaseName);
 	}
 
 	public String getName() {
 		return name;
 	}
 
 	public void setName(String name) {
 		this.name = name;
 	}
 
 	public String getServerName() {
 		return serverName;
 	}
 
 	public void setServerName(String serverName) {
 		this.serverName = serverName;
 	}
 
 	public String getDatabaseName() {
 		return databaseName;
 	}
 
 	public void setDatabaseName(String databaseName) {
 		this.databaseName = databaseName;
 	}
 
 	public int getPortNumber() {
 		return portNumber;
 	}
 
 	public void setPortNumber(int portNumber) {
 		this.portNumber = portNumber;
 	}
 
 	public String getUser() {
 		return user;
 	}
 
 	public void setUser(String user) {
 		this.user = user;
 	}
 
 	public String getPassword() {
 		return password;
 	}
 
 	public void setPassword(String password) {
 		this.password = password;
 	}
 
 	@Override
-	public void initialize() throws SailException {
+	public void initialize()
+		throws SailException
+	{
 		try {
 			Class.forName("com.mysql.jdbc.Driver");
-		} catch (ClassNotFoundException e) {
+		}
+		catch (ClassNotFoundException e) {
 			throw new RdbmsException(e.toString(), e);
 		}
 		StringBuilder url = new StringBuilder();
 		url.append("jdbc:mysql:");
 		if (serverName != null) {
 			url.append("//").append(serverName);
 			if (portNumber > 0) {
 				url.append(":").append(portNumber);
 			}
 			url.append("/");
 		}
 		url.append(databaseName);
-		url.append("?useUnicode=yes&characterEncoding=UTF-8");
+		url.append("?useUnicode=yes&characterEncoding=UTF-8&autoReconnect=true");
 		BasicDataSource ds = new BasicDataSource();
 		ds.setUrl(url.toString());
+		ds.setMaxActive(64);
+		ds.setValidationQuery("SELECT 1 FROM DUAL");
+		
+		/* Based on http://dev.mysql.com/doc/refman/5.0/en/connector-j-usagenotes-j2ee.html */
+		ds.setTestOnBorrow(true);
+		ds.setTestOnReturn(true);
+		ds.setTestWhileIdle(true);
+		ds.setTimeBetweenEvictionRunsMillis(10000);
+		ds.setMinEvictableIdleTimeMillis(30000); /* must correspond to the server's wait_timeout setting! */
+
 		if (user != null) {
 			ds.setUsername(user);
-		} else {
+		}
+		else {
 			ds.setUsername(System.getProperty("user.name"));
 		}
 		if (password != null) {
 			ds.setPassword(password);
 		}
 		MySqlConnectionFactory factory = new MySqlConnectionFactory();
 		factory.setSail(this);
 		factory.setDataSource(ds);
 		setConnectionFactory(factory);
 		super.initialize();
 	}
 
 	private String genName() {
 		String hex = Integer.toHexString(System.identityHashCode(this));
 		return getClass().getSimpleName() + "#" + hex;
 	}
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/mysql/MySqlValueTable.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/mysql/MySqlValueTable.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/mysql/MySqlValueTable.java (revision 85)
@@ -1,32 +1,53 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.mysql;
 
+import java.sql.SQLException;
 import java.sql.Types;
 
 import org.openrdf.sail.rdbms.schema.ValueTable;
-
+import org.openrdf.sail.rdbms.schema.ValueTableFactory;
 
 /**
  *
  * @author James Leigh
  */
 public class MySqlValueTable extends ValueTable {
 	private static final String FEILD_COLLATE = " CHARACTER SET utf8 COLLATE utf8_bin";
 
 	@Override
 	public String sql(int type, int length) {
+		if (type == ValueTableFactory.POINT_TYPE)
+			return "POINT";
+		
 		String declare = super.sql(type, length);
 		if (type == Types.VARCHAR) {
 			return declare + FEILD_COLLATE;
-		} else if (type == Types.LONGVARCHAR) {
-			return declare + FEILD_COLLATE;
-		} else {
+		}
+		else if (type == Types.LONGVARCHAR) {
+			return "LONGTEXT" + FEILD_COLLATE;
+		}
+		else {
 			return declare;
+		}
+	}
+	
+	@Override
+	public void initialize() throws SQLException {
+		super.initialize();
+
+		/* For POINT type, insert using MySQL WKT functions */
+		if (getSqlType() == ValueTableFactory.POINT_TYPE) {
+			StringBuilder sb = new StringBuilder();
+			sb.append("INSERT INTO ").append(getInsertTable().getName());
+			sb.append(" (id, value) VALUES (?, PointFromText(CONCAT('POINT(', ?, ')')))");
+			setINSERT(sb.toString());
+			/* No need to change INSERT_SELECT, as it will is constructed using the POINT datatype and will also use this INSERT statement */
 		}
 	}
 
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/mysql/MySqlConnectionFactory.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/mysql/MySqlConnectionFactory.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/mysql/MySqlConnectionFactory.java (revision 85)
@@ -1,129 +1,147 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.mysql;
 
 import static org.openrdf.sail.rdbms.algebra.base.SqlExprSupport.unsupported;
 
 import java.sql.Connection;
 import java.sql.SQLException;
+import java.sql.Types;
 
 import org.openrdf.query.algebra.Regex;
 import org.openrdf.query.algebra.ValueConstant;
 import org.openrdf.query.algebra.ValueExpr;
 import org.openrdf.sail.rdbms.RdbmsConnectionFactory;
 import org.openrdf.sail.rdbms.algebra.factories.BooleanExprFactory;
 import org.openrdf.sail.rdbms.evaluation.QueryBuilderFactory;
+import org.openrdf.sail.rdbms.evaluation.SqlCastBuilder;
 import org.openrdf.sail.rdbms.evaluation.SqlExprBuilder;
 import org.openrdf.sail.rdbms.evaluation.SqlRegexBuilder;
 import org.openrdf.sail.rdbms.exceptions.UnsupportedRdbmsOperatorException;
 import org.openrdf.sail.rdbms.optimizers.SelectQueryOptimizerFactory;
 import org.openrdf.sail.rdbms.schema.NamespacesTable;
 import org.openrdf.sail.rdbms.schema.RdbmsTable;
 import org.openrdf.sail.rdbms.schema.TableFactory;
 import org.openrdf.sail.rdbms.schema.ValueTable;
 import org.openrdf.sail.rdbms.schema.ValueTableFactory;
 
 public class MySqlConnectionFactory extends RdbmsConnectionFactory {
 
 	private static final String FEILD_COLLATE = " CHARACTER SET utf8 COLLATE utf8_bin";
 
 	@Override
 	protected TableFactory createTableFactory() {
 		return new TableFactory() {
 			@Override
 			protected RdbmsTable newTable(String name) {
 				return new MySqlTable(name);
 			}
 		};
 	}
 
 	@Override
 	protected ValueTableFactory createValueTableFactory() {
-		return new ValueTableFactory(createTableFactory())
-		{
+		return new ValueTableFactory(createTableFactory()) {
 
 			@Override
 			protected ValueTable newValueTable() {
 				return new MySqlValueTable();
 			}
 
 			@Override
 			public NamespacesTable createNamespacesTable(Connection conn) {
 				return new NamespacesTable(createTable(conn, NAMESPACES)) {
 
 					@Override
 					protected void createTable()
 						throws SQLException
 					{
 						StringBuilder sb = new StringBuilder();
 						sb.append("  prefix VARCHAR(127)");
 						sb.append(FEILD_COLLATE);
 						sb.append(",\n  namespace TEXT ");
 						sb.append(FEILD_COLLATE);
 						sb.append(" NOT NULL\n");
 						createTable(sb);
 					}
 				};
 			}
 		};
 	}
 
 	@Override
 	protected SelectQueryOptimizerFactory createSelectQueryOptimizerFactory() {
 		return new SelectQueryOptimizerFactory() {
 
 			@Override
 			protected BooleanExprFactory createBooleanExprFactory() {
 				return new BooleanExprFactory() {
 
 					@Override
 					public void meet(Regex node)
 						throws UnsupportedRdbmsOperatorException
 					{
 						ValueExpr flagsArg = node.getFlagsArg();
 						if (flagsArg == null) {
 							super.meet(node);
 						}
 						else if (flagsArg instanceof ValueConstant) {
 							ValueConstant flags = (ValueConstant)flagsArg;
 							if (flags.getValue().stringValue().equals("i")) {
 								super.meet(node);
 							}
 							else {
 								throw unsupported(node);
 							}
 						}
 						else {
 							throw unsupported(node);
 						}
 					}
 				};
 			}
 		};
 	}
 
 	@Override
 	protected QueryBuilderFactory createQueryBuilderFactory() {
 		return new QueryBuilderFactory() {
 
 			@Override
 			public SqlRegexBuilder createSqlRegexBuilder(SqlExprBuilder where) {
 				return new SqlRegexBuilder(where, this) {
 
 					@Override
 					protected void appendRegExp(SqlExprBuilder where) {
 						appendValue(where);
 						if (!this.flags().getParameters().isEmpty()) {
 							where.append(" COLLATE utf8_general_ci");
 						}
 						where.append(" REGEXP ");
 						appendPattern(where);
 					}
 				};
 			}
+
+			//@Override
+			public SqlCastBuilder createSqlCastBuilder(SqlExprBuilder where, int type) {
+				return new SqlCastBuilder(where, this, type) {
+
+					@Override
+					protected CharSequence getSqlType(int type) {
+						switch (type) {
+							case Types.VARCHAR:
+								return "CHAR";
+							default:
+								return super.getSqlType(type);
+						}
+					}
+				};
+			}
 		};
 	}
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/mysql/MySqlTable.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/mysql/MySqlTable.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/mysql/MySqlTable.java (revision 149)
@@ -1,44 +1,61 @@
 package org.openrdf.sail.rdbms.mysql;
 
 import java.sql.SQLException;
 
 import org.openrdf.sail.rdbms.schema.RdbmsTable;
+import org.openrdf.sail.rdbms.schema.ValueTableFactory;
 
 public class MySqlTable extends RdbmsTable {
 
 	public MySqlTable(String name) {
 		super(name);
 	}
 
 	@Override
 	protected String buildCreateTransactionalTable(CharSequence columns) {
 		StringBuilder sb = new StringBuilder();
 		sb.append("CREATE TABLE ").append(getName());
 		sb.append(" (\n").append(columns).append(")");
-		sb.append(" type = InnoDB");
+		sb.append(" engine = MyISAM"); /* using MyISAM here although it is not transactional, as mixing of InnoDB and MyISAM tables yields bad index selection orders */
 		return sb.toString();
 	}
 
 	@Override
-	protected String buildLongIndex(String... columns) {
-		StringBuilder sb = new StringBuilder();
+	protected String buildLongIndex(int sqlType, String... columns) {
+		return "SELECT NULL";
+		/*StringBuilder sb = new StringBuilder();
 		sb.append("CREATE INDEX ").append(buildIndexName(columns));
 		sb.append(" ON ").append(getName());
 		sb.append(" (value(1024))");
 		return sb.toString();
-	}
+	*/}
 
 	@Override
-	protected String buildOptimize() throws SQLException {
-		return "OPTIMIZE TABLE " + getName();
+	protected String buildOptimize()
+		throws SQLException
+	{
+		return "SELECT NULL"; //	return "OPTIMIZE TABLE " + getName();
 	}
 
 	@Override
 	protected String buildDropIndex(String name) {
-		StringBuilder sb = new StringBuilder();
+		return "SELECT NULL"; /*StringBuilder sb = new StringBuilder();
 		sb.append("DROP INDEX ").append(name);
 		sb.append(" ON ").append(getName());
+		return sb.toString();*/
+	}
+	
+	protected String buildIndex(int sqlType, String... columns) {
+		return "SELECT NULL"; /* StringBuilder sb = new StringBuilder();
+		sb.append("CREATE " + (sqlType == ValueTableFactory.POINT_TYPE ? "SPATIAL " : "") + "INDEX ").append(buildIndexName(columns));
+		sb.append(" ON ").append(getName()).append(" (");
+		for (int i = 0; i < columns.length; i++) {
+			if (i > 0) {
+				sb.append(", ");
+			}
+			sb.append(columns[i]);
+		}
+		sb.append(")");
 		return sb.toString();
-	}
-
+	*/}	
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/config/RdbmsStoreSchema.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/config/RdbmsStoreSchema.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/config/RdbmsStoreSchema.java (revision 85)
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/config/RdbmsStoreConfig.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/config/RdbmsStoreConfig.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/config/RdbmsStoreConfig.java (revision 85)
@@ -1,134 +1,143 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.config;
 
 import static org.openrdf.model.util.GraphUtil.getOptionalObjectLiteral;
 import static org.openrdf.sail.rdbms.config.RdbmsStoreSchema.INDEXED;
 import static org.openrdf.sail.rdbms.config.RdbmsStoreSchema.JDBC_DRIVER;
 import static org.openrdf.sail.rdbms.config.RdbmsStoreSchema.LAYOUT;
 import static org.openrdf.sail.rdbms.config.RdbmsStoreSchema.PASSWORD;
 import static org.openrdf.sail.rdbms.config.RdbmsStoreSchema.URL;
 import static org.openrdf.sail.rdbms.config.RdbmsStoreSchema.USER;
 
 import org.openrdf.model.Graph;
 import org.openrdf.model.Literal;
 import org.openrdf.model.Resource;
 import org.openrdf.model.URI;
 import org.openrdf.model.util.GraphUtilException;
 import org.openrdf.sail.config.SailConfigException;
 import org.openrdf.sail.config.SailImplConfigBase;
 
 /**
  * Holds the JDBC Driver, URL, user, and password.
  * 
  * @author James Leigh
  * 
  */
 public class RdbmsStoreConfig extends SailImplConfigBase {
 	private String jdbcDriver;
 	private String url;
 	private String user;
 	private String password;
 	private String layout;
 	private String indexed;
 
 	public RdbmsStoreConfig() {
 		super(RdbmsStoreFactory.SAIL_TYPE);
 	}
 
 	public String getJdbcDriver() {
 		return jdbcDriver;
 	}
 
 	public void setJdbcDriver(String jdbcDriver) {
 		this.jdbcDriver = jdbcDriver;
 	}
 
 	public String getUrl() {
 		return url;
 	}
 
 	public void setUrl(String url) {
 		this.url = url;
 	}
 
 	public String getUser() {
 		return user;
 	}
 
 	public void setUser(String user) {
 		this.user = user;
 	}
 
 	public String getPassword() {
 		return password;
 	}
 
 	public void setPassword(String password) {
 		this.password = password;
 	}
 
 	public String getLayout() {
 		return layout;
 	}
 
 	public void setLayout(String layout) {
 		this.layout = layout;
 	}
 
 	public String getIndexed() {
 		return indexed;
 	}
 
 	public void setIndexed(String indexed) {
 		this.indexed = indexed;
 	}
 
 	@Override
 	public Resource export(Graph graph) {
 		Resource implNode = super.export(graph);
 		set(graph, implNode, JDBC_DRIVER, jdbcDriver);
 		set(graph, implNode, URL, url);
 		set(graph, implNode, USER, user);
 		set(graph, implNode, PASSWORD, password);
 		set(graph, implNode, LAYOUT, layout);
 		set(graph, implNode, INDEXED, indexed);
 		return implNode;
 	}
 
 	@Override
 	public void parse(Graph graph, Resource implNode)
-			throws SailConfigException {
+		throws SailConfigException
+	{
 		super.parse(graph, implNode);
 
 		try {
 			jdbcDriver = get(graph, implNode, JDBC_DRIVER);
 			url = get(graph, implNode, URL);
 			user = get(graph, implNode, USER);
 			password = get(graph, implNode, PASSWORD);
 			layout = get(graph, implNode, LAYOUT);
 			indexed = get(graph, implNode, INDEXED);
-		} catch (GraphUtilException e) {
+		}
+		catch (GraphUtilException e) {
 			throw new SailConfigException(e.getMessage(), e);
 		}
 	}
 
 	private String get(Graph graph, Resource implNode, URI predicate)
-			throws GraphUtilException {
+		throws GraphUtilException
+	{
 		Literal lit = getOptionalObjectLiteral(graph, implNode, predicate);
 		if (lit == null)
 			return null;
 		return lit.getLabel();
 	}
 
 	private void set(Graph graph, Resource implNode, URI predicate, String value) {
 		if (value != null) {
 			Literal lit = graph.getValueFactory().createLiteral(value);
 			graph.add(implNode, predicate, lit);
 		}
 	}
 
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/config/RdbmsStoreFactory.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/config/RdbmsStoreFactory.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/config/RdbmsStoreFactory.java (revision 85)
@@ -1,62 +1,79 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.config;
 
 import org.openrdf.sail.SailException;
 import org.openrdf.sail.config.SailConfigException;
 import org.openrdf.sail.config.SailFactory;
 import org.openrdf.sail.config.SailImplConfig;
 import org.openrdf.sail.rdbms.RdbmsStore;
 
 /**
  * Creates a {@link RdbmsStore} from a {@link RdbmsStoreConfig}.
  * 
  * @author James Leigh
  * 
  */
 public class RdbmsStoreFactory implements SailFactory {
 	public static final String SAIL_TYPE = "openrdf:RdbmsStore";
 
 	public String getSailType() {
 		return SAIL_TYPE;
 	}
 
 	public RdbmsStoreConfig getConfig() {
 		return new RdbmsStoreConfig();
 	}
 
-	public RdbmsStore getSail(SailImplConfig config) throws SailConfigException {
+	public RdbmsStore getSail(SailImplConfig config)
+		throws SailConfigException
+	{
 		if (!SAIL_TYPE.equals(config.getType())) {
-			throw new SailConfigException("Invalid Sail type: "
-					+ config.getType());
+			throw new SailConfigException("Invalid Sail type: " + config.getType());
 		}
 
-		RdbmsStoreConfig rdbms = (RdbmsStoreConfig) config;
+		RdbmsStoreConfig rdbms = (RdbmsStoreConfig)config;
 		String jdbcDriver = rdbms.getJdbcDriver();
 		String url = rdbms.getUrl();
 		String user = rdbms.getUser();
 		String password = rdbms.getPassword();
 		String layout = rdbms.getLayout();
 		String indexed = rdbms.getIndexed();
 		RdbmsStore store = new RdbmsStore(jdbcDriver, url, user, password);
 		if ("layout2".equals(layout)) {
 			store.setMaxNumberOfTripleTables(1);
-		} else {
-			assert "layout3".equals(layout) : layout;
+		}
+		else if ("layout2/hash".equals(layout)) {
+			store.setMaxNumberOfTripleTables(1);
+			store.setSequenced(false);
+		}
+		else if ("layout2/index".equals(layout)) {
+			store.setMaxNumberOfTripleTables(1);
+			store.setSequenced(true);
+		}
+		else if ("layout3/hash".equals(layout)) {
+			store.setSequenced(false);
+		}
+		else if ("layout3/index".equals(layout)) {
+			store.setSequenced(true);
+		}
+		else {
+			assert "layout3".equals(layout);
 		}
 		if (indexed != null) {
 			try {
 				store.setIndexed(Boolean.valueOf(indexed));
 			}
 			catch (SailException e) {
 				// this shouldn't happen
 				throw new AssertionError(e);
 			}
 		}
 		return store;
 	}
 
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/evaluation/RdbmsEvaluation.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/evaluation/RdbmsEvaluation.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/evaluation/RdbmsEvaluation.java (revision 85)
@@ -1,153 +1,161 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.evaluation;
 
-import info.aduna.iteration.CloseableIteration;
-
 import java.sql.Connection;
 import java.sql.PreparedStatement;
 import java.sql.SQLException;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.List;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import info.aduna.iteration.CloseableIteration;
 
 import org.openrdf.query.BindingSet;
 import org.openrdf.query.Dataset;
 import org.openrdf.query.QueryEvaluationException;
 import org.openrdf.query.algebra.TupleExpr;
 import org.openrdf.query.algebra.evaluation.QueryBindingSet;
 import org.openrdf.query.algebra.evaluation.impl.EvaluationStrategyImpl;
 import org.openrdf.sail.rdbms.RdbmsTripleRepository;
 import org.openrdf.sail.rdbms.RdbmsValueFactory;
 import org.openrdf.sail.rdbms.algebra.ColumnVar;
 import org.openrdf.sail.rdbms.algebra.SelectProjection;
 import org.openrdf.sail.rdbms.algebra.SelectQuery;
 import org.openrdf.sail.rdbms.algebra.SelectQuery.OrderElem;
 import org.openrdf.sail.rdbms.exceptions.RdbmsException;
 import org.openrdf.sail.rdbms.exceptions.RdbmsQueryEvaluationException;
 import org.openrdf.sail.rdbms.exceptions.UnsupportedRdbmsOperatorException;
 import org.openrdf.sail.rdbms.iteration.RdbmsBindingIteration;
 import org.openrdf.sail.rdbms.schema.IdSequence;
 
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
 /**
  * Extends the default strategy by accepting {@link SelectQuery} and evaluating
  * them on a database.
  * 
  * @author James Leigh
  * 
  */
 public class RdbmsEvaluation extends EvaluationStrategyImpl {
 	private Logger logger = LoggerFactory.getLogger(RdbmsEvaluation.class);
 	private QueryBuilderFactory factory;
 	private RdbmsValueFactory vf;
 	private RdbmsTripleRepository triples;
 	private IdSequence ids;
 
-	public RdbmsEvaluation(QueryBuilderFactory factory,
-			RdbmsTripleRepository triples, Dataset dataset, IdSequence ids) {
+	public RdbmsEvaluation(QueryBuilderFactory factory, RdbmsTripleRepository triples, Dataset dataset,
+			IdSequence ids)
+	{
 		super(new RdbmsTripleSource(triples), dataset);
 		this.factory = factory;
 		this.triples = triples;
 		this.vf = triples.getValueFactory();
 		this.ids = ids;
 	}
 
 	@Override
-	public CloseableIteration<BindingSet, QueryEvaluationException> evaluate(
-			TupleExpr expr, BindingSet bindings)
-			throws QueryEvaluationException {
+	public CloseableIteration<BindingSet, QueryEvaluationException> evaluate(TupleExpr expr,
+			BindingSet bindings)
+		throws QueryEvaluationException
+	{
 		if (expr instanceof SelectQuery)
-			return evaluate((SelectQuery) expr, bindings);
+			return evaluate((SelectQuery)expr, bindings);
 		return super.evaluate(expr, bindings);
 	}
 
-	private CloseableIteration<BindingSet, QueryEvaluationException> evaluate(
-			SelectQuery qb, BindingSet b)
-			throws UnsupportedRdbmsOperatorException,
-			RdbmsQueryEvaluationException {
+	private CloseableIteration<BindingSet, QueryEvaluationException> evaluate(SelectQuery qb, BindingSet b)
+		throws UnsupportedRdbmsOperatorException, RdbmsQueryEvaluationException
+	{
 		List<Object> parameters = new ArrayList<Object>();
 		try {
 			QueryBindingSet bindings = new QueryBindingSet(b);
 			String query = toQueryString(qb, bindings, parameters);
 			try {
 				Connection conn = triples.getConnection();
 				PreparedStatement stmt = conn.prepareStatement(query);
 				int p = 0;
 				for (Object o : parameters) {
 					stmt.setObject(++p, o);
 				}
 				Collection<ColumnVar> proj = qb.getProjections();
 				RdbmsBindingIteration result = new RdbmsBindingIteration(stmt);
 				result.setProjections(proj);
 				result.setBindings(bindings);
 				result.setValueFactory(vf);
 				result.setIdSequence(ids);
 				return result;
-			} catch (SQLException e) {
-				throw new RdbmsQueryEvaluationException(e.toString() + "\n"
-						+ query, e);
 			}
-		} catch (RdbmsException e) {
+			catch (SQLException e) {
+				throw new RdbmsQueryEvaluationException(e.toString() + "\n" + query, e);
+			}
+		}
+		catch (RdbmsException e) {
 			throw new RdbmsQueryEvaluationException(e);
 		}
 	}
 
-	private String toQueryString(SelectQuery qb, QueryBindingSet bindings,
-			List<Object> parameters) throws RdbmsException,
-			UnsupportedRdbmsOperatorException {
+	private String toQueryString(SelectQuery qb, QueryBindingSet bindings, List<Object> parameters)
+		throws RdbmsException, UnsupportedRdbmsOperatorException
+	{
 		QueryBuilder query = factory.createQueryBuilder();
 		if (qb.isDistinct()) {
 			query.distinct();
 		}
 		query.from(qb.getFrom());
 		for (ColumnVar var : qb.getVars()) {
 			String name = qb.getBindingName(var);
 			if (var.getValue() == null && bindings.hasBinding(name)) {
 				query.filter(var, bindings.getValue(name));
-			} else if (var.getValue() != null && !bindings.hasBinding(name)
-					&& qb.getBindingNames().contains(name)) {
+			}
+			else if (var.getValue() != null && !bindings.hasBinding(name) && qb.getBindingNames().contains(name))
+			{
 				bindings.addBinding(name, var.getValue());
 			}
 		}
 		int index = 0;
 		for (SelectProjection proj : qb.getSqlSelectVar()) {
 			ColumnVar var = proj.getVar();
 			String name = qb.getBindingName(var);
 			if (!var.isHidden() && !bindings.hasBinding(name)) {
 				var.setIndex(index);
 				query.select(proj.getId());
 				query.select(proj.getStringValue());
 				index += 2;
 				if (var.getTypes().isLiterals()) {
 					query.select(proj.getLanguage());
 					query.select(proj.getDatatype());
 					index += 2;
 				}
 			}
 		}
 		for (OrderElem by : qb.getOrderElems()) {
 			query.orderBy(by.sqlExpr, by.isAscending);
 			if (qb.isDistinct()) {
 				query.select(by.sqlExpr);
 			}
 		}
 		if (qb.getLimit() != null) {
 			query.limit(qb.getLimit());
 		}
 		if (qb.getOffset() != null) {
 			query.offset(qb.getOffset());
 		}
 		parameters.addAll(query.getParameters());
 		if (logger.isDebugEnabled()) {
 			logger.debug(query.toString());
 			logger.debug(parameters.toString());
 		}
 		return query.toString();
 	}
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/evaluation/SqlCastBuilder.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/evaluation/SqlCastBuilder.java (revision 85)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/evaluation/SqlCastBuilder.java (revision 85)
@@ -0,0 +1,46 @@
+/*
+ * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
+ *
+ * Licensed under the Aduna BSD-style license.
+ */
+package org.openrdf.sail.rdbms.evaluation;
+
+import java.sql.Types;
+
+/**
+ * Prints round brackets in an SQL query.
+ * 
+ * @author James Leigh
+ * 
+ */
+public class SqlCastBuilder extends SqlExprBuilder {
+
+	private SqlExprBuilder where;
+
+	private int jdbcType;
+
+	public SqlCastBuilder(SqlExprBuilder where, QueryBuilderFactory factory, int jdbcType) {
+		super(factory);
+		this.where = where;
+		this.jdbcType = jdbcType;
+		append(" CAST(");
+	}
+
+	public SqlExprBuilder close() {
+		append(" AS ");
+		append(getSqlType(jdbcType));
+		append(")");
+		where.append(toSql());
+		where.addParameters(getParameters());
+		return where;
+	}
+
+	protected CharSequence getSqlType(int type) {
+		switch (type) {
+			case Types.VARCHAR:
+				return "VARCHAR";
+			default:
+				throw new AssertionError(type);
+		}
+	}
+}
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/evaluation/SqlBracketBuilder.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/evaluation/SqlBracketBuilder.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/evaluation/SqlBracketBuilder.java (revision 61)
@@ -1,38 +1,42 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.evaluation;
 
 /**
  * Prints round brackets in an SQL query.
  * 
  * @author James Leigh
  * 
  */
 public class SqlBracketBuilder extends SqlExprBuilder {
 	private SqlExprBuilder where;
 	private String closing = ")";
 
-	public SqlBracketBuilder(SqlExprBuilder where, QueryBuilderFactory factory) {
+	public SqlBracketBuilder(SqlExprBuilder where, QueryBuilderFactory factory, String open) {
 		super(factory);
 		this.where = where;
-		append("(");
+		append(open);
+	}
+	
+	public SqlBracketBuilder(SqlExprBuilder where, QueryBuilderFactory factory) {
+		this(where, factory, "(");
 	}
 
 	public String getClosing() {
 		return closing;
 	}
 
 	public void setClosing(String closing) {
 		this.closing = closing;
 	}
 
 	public SqlExprBuilder close() {
 		append(closing);
 		where.append(toSql());
 		where.addParameters(getParameters());
 		return where;
 	}
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/evaluation/QueryBuilderFactory.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/evaluation/QueryBuilderFactory.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/evaluation/QueryBuilderFactory.java (revision 61)
@@ -1,54 +1,58 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.evaluation;
 
 import org.openrdf.sail.rdbms.RdbmsValueFactory;
 
 /**
  * Creates the SQL query building components.
  * 
  * @author James Leigh
  * 
  */
 public class QueryBuilderFactory {
 	private RdbmsValueFactory vf;
 	private boolean usingHashTable;
 
 	public void setValueFactory(RdbmsValueFactory vf) {
 		this.vf = vf;
 	}
 
 	public void setUsingHashTable(boolean b) {
 		this.usingHashTable = b;
 	}
 
 	public QueryBuilder createQueryBuilder() {
 		QueryBuilder query = new QueryBuilder(createSqlQueryBuilder());
 		query.setValueFactory(vf);
 		query.setUsingHashTable(usingHashTable);
 		return query;
 	}
 
 	public SqlQueryBuilder createSqlQueryBuilder() {
 		return new SqlQueryBuilder(this);
 	}
 
 	public SqlExprBuilder createSqlExprBuilder() {
 		return new SqlExprBuilder(this);
 	}
 
 	public SqlRegexBuilder createSqlRegexBuilder(SqlExprBuilder where) {
 		return new SqlRegexBuilder(where, this);
 	}
 
+	public SqlBracketBuilder createSqlBracketBuilder(SqlExprBuilder where, String open) {
+		return new SqlBracketBuilder(where, this, open);
+	}
+
 	public SqlBracketBuilder createSqlBracketBuilder(SqlExprBuilder where) {
 		return new SqlBracketBuilder(where, this);
 	}
 
 	public SqlJoinBuilder createSqlJoinBuilder(String table, String alias) {
 		return new SqlJoinBuilder(table, alias, this);
 	}
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/evaluation/SqlExprBuilder.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/evaluation/SqlExprBuilder.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/evaluation/SqlExprBuilder.java (revision 62)
@@ -1,259 +1,297 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.evaluation;
 
 import java.util.ArrayList;
 import java.util.List;
 
 import org.openrdf.query.algebra.MathExpr;
 import org.openrdf.sail.rdbms.algebra.SqlCompare;
 
 /**
  * Assemblies an SQL expression.
  * 
  * @author James Leigh
  * 
  */
 public class SqlExprBuilder {
 	protected class Mark {
 		int length;
 		int size;
 
 		Mark(int length, int size) {
 			this.length = length;
 			this.size = size;
 		}
 	}
 
 	private static final String NULL = " NULL ";
 	private QueryBuilderFactory factory;
 	private List<Object> parameters = new ArrayList<Object>();
 	private StringBuilder where = new StringBuilder();
 
 	public SqlExprBuilder(QueryBuilderFactory factory) {
 		super();
 		this.factory = factory;
 	}
 
 	public SqlBracketBuilder abs() {
 		where.append(" ABS");
 		return open();
 	}
 
 	public SqlExprBuilder and() {
 		if (!isEmpty()) {
 			where.append("\n AND ");
 		}
 		return this;
 	}
 
 	public SqlExprBuilder append(CharSequence sql) {
 		where.append(sql);
 		return this;
 	}
 
 	public void appendBoolean(boolean booleanValue) {
 		if (booleanValue) {
 			where.append(" 1=1 ");
 		} else {
 			where.append(" 0=1 ");
 		}
 	}
 
 	public SqlExprBuilder appendNull() {
 		where.append(getSqlNull());
 		return this;
 	}
 
 	public SqlExprBuilder appendNumeric(double doubleValue) {
 		where.append(" ? ");
 		parameters.add(doubleValue);
 		return this;
 	}
 
 	public void appendOperator(SqlCompare.Operator op) {
 		switch (op) {
 		case GE:
 			where.append(" >= ");
 			break;
 		case GT:
 			where.append(" > ");
 			break;
 		case LE:
 			where.append(" <= ");
 			break;
 		case LT:
 			where.append(" < ");
 			break;
 		}
 	}
 
 	public void as(String column) {
 		where.append(" AS ").append(column);
 	}
 
 	public SqlExprBuilder number(Number time) {
 		where.append(" ? ");
 		parameters.add(time);
 		return this;
 	}
 
+	public SqlExprBuilder bool(Boolean b) {
+		where.append(" ? ");
+		parameters.add(b);
+		return this;
+	}
+
 	public SqlCaseBuilder caseBegin() {
 		return new SqlCaseBuilder(this);
 	}
 
 	public SqlExprBuilder column(String alias, String column) {
 		where.append(alias).append(".").append(column);
 		return this;
 	}
 
 	public SqlExprBuilder columnEquals(String alias, String column, Number id) {
 		return column(alias, column).eq().number(id);
 	}
 
 	public SqlExprBuilder columnEquals(String alias, String column, String label) {
 		return column(alias, column).eq().varchar(label);
 	}
 
+	public SqlExprBuilder columnEquals(String alias, String column, Boolean b) {
+		return column(alias, column).eq().bool(b);
+	}
+	
 	public SqlExprBuilder columnIn(String alias, String column, Number[] ids) {
 		if (ids.length == 1) {
 			return columnEquals(alias, column, ids[0]);
 		}
 		SqlBracketBuilder open = open();
 		for (int i = 0; i < ids.length; i++) {
 			if (i > 0) {
 				open.or();
 			}
 			open.column(alias, column);
 			open.eq();
 			open.number(ids[i]);
 		}
 		open.close();
 		return this;
 	}
 
 	public SqlExprBuilder columnsEqual(String al1, String col1, String al2,
 			String col2) {
 		return column(al1, col1).eq().column(al2, col2);
 	}
 
 	public void concat() {
 		append(" || ");
 	}
 
 	public SqlExprBuilder eq() {
 		where.append(" = ");
 		return this;
 	}
 
 	public List<Object> getParameters() {
 		return parameters;
 	}
 
 	public boolean isEmpty() {
 		return where.length() == 0;
 	}
 
 	public SqlExprBuilder isNotNull() {
 		where.append(" IS NOT NULL ");
 		return this;
 	}
 
 	public SqlExprBuilder isNull() {
 		where.append(" IS NULL ");
 		return this;
 	}
 
 	public void like() {
 		where.append(" LIKE ");
 	}
 
 	public SqlBracketBuilder lowerCase() {
 		where.append(" lower");
 		return open();
 	}
 
 	public void math(MathExpr.MathOp op) {
 		append(" ").append(op.getSymbol()).append(" ");
 	}
 
 	public SqlBracketBuilder mod(int value) {
 		where.append(" MOD");
 		SqlBracketBuilder open = open();
 		open.setClosing("," + value + open.getClosing());
 		return open;
 	}
 
 	public SqlBracketBuilder not() {
 		where.append(" NOT");
 		return open();
 	}
 
 	public SqlExprBuilder notEqual() {
 		where.append(" != ");
 		return this;
 	}
 
+	public SqlBracketBuilder open(String open) {
+		return factory.createSqlBracketBuilder(this, open);
+	}
+	
 	public SqlBracketBuilder open() {
 		return factory.createSqlBracketBuilder(this);
 	}
 
 	public SqlExprBuilder or() {
 		append(" OR ");
 		return this;
 	}
 
 	public void plus(int range) {
 		where.append(" + " + range);
 	}
 
 	public SqlRegexBuilder regex() {
 		return factory.createSqlRegexBuilder(this);
 	}
 
 	public void rightShift(int rightShift) {
 		where.append(" >> " + rightShift);
 	}
 
 	public CharSequence toSql() {
 		return where;
 	}
 
 	@Override
 	public String toString() {
 		return where.toString();
 	}
 
 	public SqlExprBuilder varchar(String stringValue) {
 		if (stringValue == null) {
 			appendNull();
 		} else {
 			where.append(" ? ");
 			parameters.add(stringValue);
 		}
 		return this;
 	}
 
 	protected void addParameters(List<Object> params) {
 		parameters.addAll(params);
 	}
 
 	protected String getSqlNull() {
 		return NULL;
 	}
 
 	protected Mark mark() {
 		return new Mark(where.length(), parameters.size());
 	}
 
 	protected void reset(Mark mark) {
 		where.delete(mark.length, where.length());
 		for (int i = parameters.size() - 1; i >= mark.size; i--) {
 			parameters.remove(i);
 		}
 	}
 
+	public SqlBracketBuilder MbrContains() {
+		where.append("MBRContains");
+		return open();
+	}
+
+	public SqlBracketBuilder PolyFromText() {
+		where.append("PolyFromText");
+//		SqlBracketBuilder open = open("(CONCAT(\"'\",");
+//		open.setClosing(",\"'\"))");
+//		return open;
+		return open();
+	}
+
+	public SqlBracketBuilder Polygon() {
+		where.append("POLYGON");
+		SqlBracketBuilder open = open("((");
+		open.setClosing("))");
+		return open;
+	}
+	
+	public void comma() {
+		where.append(", ");
+	}	
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/evaluation/RdbmsTripleSource.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/evaluation/RdbmsTripleSource.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/evaluation/RdbmsTripleSource.java (revision 54)
@@ -1,54 +1,55 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.evaluation;
 
 import info.aduna.iteration.CloseableIteration;
 
 import org.openrdf.model.Resource;
+import org.openrdf.model.Statement;
 import org.openrdf.model.URI;
 import org.openrdf.model.Value;
 import org.openrdf.query.QueryEvaluationException;
 import org.openrdf.query.algebra.evaluation.TripleSource;
 import org.openrdf.sail.SailException;
 import org.openrdf.sail.rdbms.RdbmsTripleRepository;
 import org.openrdf.sail.rdbms.RdbmsValueFactory;
 import org.openrdf.sail.rdbms.model.RdbmsResource;
 import org.openrdf.sail.rdbms.model.RdbmsURI;
 import org.openrdf.sail.rdbms.model.RdbmsValue;
 
 /**
  * Proxies request to a {@link RdbmsTripleRepository}.
  * 
  * @author James Leigh
  * 
  */
 public class RdbmsTripleSource implements TripleSource {
 	private RdbmsTripleRepository triples;
 
 	public RdbmsTripleSource(RdbmsTripleRepository triples) {
 		super();
 		this.triples = triples;
 	}
 
 	public RdbmsValueFactory getValueFactory() {
 		return triples.getValueFactory();
 	}
 
 	public CloseableIteration getStatements(Resource subj, URI pred, Value obj,
 			Resource... contexts) throws QueryEvaluationException {
 		try {
 			RdbmsValueFactory vf = triples.getValueFactory();
 			RdbmsResource s = vf.asRdbmsResource(subj);
 			RdbmsURI p = vf.asRdbmsURI(pred);
-			RdbmsValue o = vf.asRdbmsValue(obj);
+			RdbmsValue o = vf.asRdbmsValue(obj, pred);
 			RdbmsResource[] c = vf.asRdbmsResource(contexts);
-			return triples.find(s, p, o, c);
+			return triples.find(s, p, o, false, c);
 		} catch (SailException e) {
 			throw new QueryEvaluationException(e);
 		}
 	}
 
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/evaluation/QueryBuilder.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/evaluation/QueryBuilder.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/evaluation/QueryBuilder.java (revision 62)
@@ -1,589 +1,619 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.evaluation;
 
 import java.util.ArrayList;
 import java.util.List;
 
 import org.openrdf.model.Value;
 import org.openrdf.sail.rdbms.RdbmsValueFactory;
 import org.openrdf.sail.rdbms.algebra.BNodeColumn;
 import org.openrdf.sail.rdbms.algebra.ColumnVar;
 import org.openrdf.sail.rdbms.algebra.DatatypeColumn;
 import org.openrdf.sail.rdbms.algebra.DateTimeColumn;
 import org.openrdf.sail.rdbms.algebra.DoubleValue;
 import org.openrdf.sail.rdbms.algebra.FalseValue;
 import org.openrdf.sail.rdbms.algebra.HashColumn;
 import org.openrdf.sail.rdbms.algebra.IdColumn;
 import org.openrdf.sail.rdbms.algebra.JoinItem;
 import org.openrdf.sail.rdbms.algebra.LabelColumn;
 import org.openrdf.sail.rdbms.algebra.LanguageColumn;
 import org.openrdf.sail.rdbms.algebra.LongLabelColumn;
 import org.openrdf.sail.rdbms.algebra.LongURIColumn;
 import org.openrdf.sail.rdbms.algebra.NumberValue;
 import org.openrdf.sail.rdbms.algebra.NumericColumn;
+import org.openrdf.sail.rdbms.algebra.PointColumn;
 import org.openrdf.sail.rdbms.algebra.RefIdColumn;
 import org.openrdf.sail.rdbms.algebra.SqlAbs;
 import org.openrdf.sail.rdbms.algebra.SqlAnd;
 import org.openrdf.sail.rdbms.algebra.SqlCase;
 import org.openrdf.sail.rdbms.algebra.SqlCompare;
 import org.openrdf.sail.rdbms.algebra.SqlConcat;
 import org.openrdf.sail.rdbms.algebra.SqlEq;
 import org.openrdf.sail.rdbms.algebra.SqlIsNull;
 import org.openrdf.sail.rdbms.algebra.SqlLike;
 import org.openrdf.sail.rdbms.algebra.SqlLowerCase;
 import org.openrdf.sail.rdbms.algebra.SqlMathExpr;
+import org.openrdf.sail.rdbms.algebra.SqlMbrContains;
 import org.openrdf.sail.rdbms.algebra.SqlNot;
 import org.openrdf.sail.rdbms.algebra.SqlNull;
 import org.openrdf.sail.rdbms.algebra.SqlOr;
 import org.openrdf.sail.rdbms.algebra.SqlRegex;
 import org.openrdf.sail.rdbms.algebra.SqlShift;
 import org.openrdf.sail.rdbms.algebra.StringValue;
 import org.openrdf.sail.rdbms.algebra.TrueValue;
 import org.openrdf.sail.rdbms.algebra.URIColumn;
 import org.openrdf.sail.rdbms.algebra.UnionItem;
 import org.openrdf.sail.rdbms.algebra.base.BinarySqlOperator;
 import org.openrdf.sail.rdbms.algebra.base.FromItem;
 import org.openrdf.sail.rdbms.algebra.base.SqlConstant;
 import org.openrdf.sail.rdbms.algebra.base.SqlExpr;
 import org.openrdf.sail.rdbms.algebra.base.UnarySqlOperator;
 import org.openrdf.sail.rdbms.algebra.base.ValueColumnBase;
 import org.openrdf.sail.rdbms.exceptions.RdbmsException;
 import org.openrdf.sail.rdbms.exceptions.UnsupportedRdbmsOperatorException;
 
 /**
  * Constructs an SQL query from {@link SqlExpr}s and {@link FromItem}s.
  * 
  * @author James Leigh
  * 
  */
 public class QueryBuilder {
 	private SqlQueryBuilder query;
 	private RdbmsValueFactory vf;
 	private boolean usingHashTable;
 
 	public QueryBuilder(SqlQueryBuilder builder) {
 		super();
 		this.query = builder;
 	}
 
 	public void setValueFactory(RdbmsValueFactory vf) {
 		this.vf = vf;
 	}
 
 	public void setUsingHashTable(boolean usingHashTable) {
 		this.usingHashTable = usingHashTable;
 	}
 
 	public void distinct() {
 		query.distinct();
 	}
 
 	public QueryBuilder filter(ColumnVar var, Value val) throws RdbmsException {
 		String alias = var.getAlias();
 		String column = var.getColumn();
 		query.filter().and().columnEquals(alias, column, vf.getInternalId(val));
 		return this;
 	}
 
 	public void from(FromItem from) throws RdbmsException,
 			UnsupportedRdbmsOperatorException {
 		from(query, from);
 	}
 
 	public List<?> getParameters() {
 		return query.findParameters(new ArrayList<Object>());
 	}
 
 	public void limit(Integer limit) {
 		query.limit(limit);
 	}
 
 	public void offset(Integer offset) {
 		query.offset(offset);
 	}
 
 	public void orderBy(SqlExpr expr, boolean isAscending)
 			throws UnsupportedRdbmsOperatorException {
 		SqlExprBuilder orderBy = query.orderBy();
 		dispatch(expr, orderBy);
 		if (!isAscending) {
 			orderBy.append(" DESC");
 		}
 	}
 
 	public QueryBuilder select(SqlExpr expr)
 			throws UnsupportedRdbmsOperatorException {
 		dispatch(expr, query.select());
 		return this;
 	}
 
 	@Override
 	public String toString() {
 		return query.toString();
 	}
 
 	private void append(BNodeColumn var, SqlExprBuilder filter) {
 		String alias = getBNodeAlias(var.getRdbmsVar());
 		filter.column(alias, "value");
 	}
 
 	private void append(DatatypeColumn var, SqlExprBuilder filter) {
 		if (var.getRdbmsVar().isResource()) {
 			filter.appendNull();
 		} else {
 			String alias = getDatatypeAlias(var.getRdbmsVar());
 			filter.column(alias, "value");
 		}
 	}
 
 	private void append(DateTimeColumn var, SqlExprBuilder filter) {
 		if (var.getRdbmsVar().isResource()) {
 			filter.appendNull();
 		} else {
 			String alias = getDateTimeAlias(var.getRdbmsVar());
 			filter.column(alias, "value");
 		}
 	}
 
 	private void append(DoubleValue expr, SqlExprBuilder filter) {
 		filter.appendNumeric(expr.getValue());
 	}
 
 	private void append(FalseValue expr, SqlExprBuilder filter) {
 		filter.appendBoolean(false);
 	}
 
 	private void append(HashColumn var, SqlExprBuilder filter) {
 		if (usingHashTable) {
 			String alias = getHashAlias(var.getRdbmsVar());
 			filter.column(alias, "value");
 		} else {
 			filter.column(var.getAlias(), var.getColumn());
 		}
 	}
 
 	private void append(IdColumn expr, SqlExprBuilder filter) {
 		filter.column(expr.getAlias(), expr.getColumn());
 	}
 
 	private void append(LabelColumn var, SqlExprBuilder filter) {
 		if (var.getRdbmsVar().isResource()) {
 			filter.appendNull();
 		} else {
 			String alias = getLabelAlias(var.getRdbmsVar());
 			filter.column(alias, "value");
 		}
 	}
 
 	private void append(LongLabelColumn var, SqlExprBuilder filter) {
 		if (var.getRdbmsVar().isResource()) {
 			filter.appendNull();
 		} else {
 			String alias = getLongLabelAlias(var.getRdbmsVar());
 			filter.column(alias, "value");
 		}
 	}
 
 	private void append(LanguageColumn var, SqlExprBuilder filter) {
 		if (var.getRdbmsVar().isResource()) {
 			filter.appendNull();
 		} else {
 			String alias = getLanguageAlias(var.getRdbmsVar());
 			filter.column(alias, "value");
 		}
 	}
 
 	private void append(LongURIColumn uri, SqlExprBuilder filter) {
 		ColumnVar var = uri.getRdbmsVar();
 		String alias = getLongURIAlias(var);
 		filter.column(alias, "value");
 	}
 
 	private void append(NumberValue expr, SqlExprBuilder filter) {
 		filter.number(expr.getValue());
 	}
 
 	private void append(NumericColumn var, SqlExprBuilder filter) {
 		if (var.getRdbmsVar().isResource()) {
 			filter.appendNull();
 		} else {
 			String alias = getNumericAlias(var.getRdbmsVar());
 			filter.column(alias, "value");
 		}
 	}
+	
+	private void append(PointColumn var, SqlExprBuilder filter) {
+		if (var.getRdbmsVar().isResource()) {
+			filter.appendNull();
+		} else {
+			String alias = getPointAlias(var.getRdbmsVar());
+			filter.column(alias, "value");
+		}		
+	}	
 
 	private void append(RefIdColumn expr, SqlExprBuilder filter) {
 		filter.column(expr.getAlias(), expr.getColumn());
 	}
 
 	private void append(SqlAbs expr, SqlExprBuilder filter)
 			throws UnsupportedRdbmsOperatorException {
 		SqlBracketBuilder abs = filter.abs();
 		dispatch(expr.getArg(), abs);
 		abs.close();
 	}
 
 	private void append(SqlAnd expr, SqlExprBuilder filter)
 			throws UnsupportedRdbmsOperatorException {
 		dispatch(expr.getLeftArg(), filter);
 		filter.and();
 		dispatch(expr.getRightArg(), filter);
 	}
 
 	private void append(SqlCase expr, SqlExprBuilder filter)
 			throws UnsupportedRdbmsOperatorException {
 		SqlCaseBuilder caseExpr = filter.caseBegin();
 		for (SqlCase.Entry e : expr.getEntries()) {
 			caseExpr.when();
 			dispatch(e.getCondition(), filter);
 			caseExpr.then();
 			dispatch(e.getResult(), filter);
 		}
 		caseExpr.end();
 	}
 
 	private void append(SqlCompare expr, SqlExprBuilder filter)
 			throws UnsupportedRdbmsOperatorException {
 		dispatch(expr.getLeftArg(), filter);
 		filter.appendOperator(expr.getOperator());
 		dispatch(expr.getRightArg(), filter);
 	}
 
 	private void append(SqlConcat expr, SqlExprBuilder filter)
 			throws UnsupportedRdbmsOperatorException {
 		SqlBracketBuilder open = filter.open();
 		dispatch(expr.getLeftArg(), open);
 		open.concat();
 		dispatch(expr.getRightArg(), open);
 		open.close();
 	}
 
 	private void append(SqlEq expr, SqlExprBuilder filter)
 			throws UnsupportedRdbmsOperatorException {
 		dispatch(expr.getLeftArg(), filter);
 		filter.eq();
 		dispatch(expr.getRightArg(), filter);
 	}
 
 	private void append(SqlIsNull expr, SqlExprBuilder filter)
 			throws UnsupportedRdbmsOperatorException {
 		dispatch(expr.getArg(), filter);
 		filter.isNull();
 	}
 
 	private void append(SqlLike expr, SqlExprBuilder filter)
 			throws UnsupportedRdbmsOperatorException {
 		dispatch(expr.getLeftArg(), filter);
 		filter.like();
 		dispatch(expr.getRightArg(), filter);
 	}
 
 	private void append(SqlLowerCase expr, SqlExprBuilder filter)
 			throws UnsupportedRdbmsOperatorException {
 		SqlBracketBuilder lower = filter.lowerCase();
 		dispatch(expr.getArg(), lower);
 		lower.close();
 	}
 
 	private void append(SqlMathExpr expr, SqlExprBuilder filter)
 			throws UnsupportedRdbmsOperatorException {
 		dispatch(expr.getLeftArg(), filter);
 		filter.math(expr.getOperator());
 		dispatch(expr.getRightArg(), filter);
+	}
+
+	private void append(SqlMbrContains expr, SqlExprBuilder filter) throws UnsupportedRdbmsOperatorException {
+		SqlBracketBuilder openMbrContains = filter.MbrContains();
+		SqlBracketBuilder openPolyFromText = openMbrContains.PolyFromText();
+		dispatch(expr.toPolygon(), openPolyFromText);
+		openPolyFromText.close();
+		openMbrContains.comma();
+		dispatch(expr.getPointCol(), openMbrContains);
+		openMbrContains.close();
+		//MBRContains(PolyFromText('POLYGON((sw_long sw_lat, ne_long sw_lat, ne_long ne_lat, sw_long ne_lat, sw_long sw_lat))'),point)
 	}
 
 	private void append(SqlNot expr, SqlExprBuilder filter)
 			throws UnsupportedRdbmsOperatorException {
 		if (expr.getArg() instanceof SqlIsNull) {
 			SqlIsNull arg = (SqlIsNull) expr.getArg();
 			dispatch(arg.getArg(), filter);
 			filter.isNotNull();
 		} else {
 			SqlBracketBuilder open = filter.not();
 			dispatch(expr.getArg(), open);
 			open.close();
 		}
 	}
 
 	private void append(SqlNull expr, SqlExprBuilder filter) {
 		filter.appendNull();
 	}
 
 	private void append(SqlOr expr, SqlExprBuilder filter)
 			throws UnsupportedRdbmsOperatorException {
 		SqlBracketBuilder open = filter.open();
 		dispatch(expr.getLeftArg(), open);
 		open.or();
 		dispatch(expr.getRightArg(), open);
 		open.close();
 	}
 
 	private void append(SqlRegex expr, SqlExprBuilder filter)
 			throws UnsupportedRdbmsOperatorException {
 		SqlRegexBuilder regex = filter.regex();
 		dispatch(expr.getArg(), regex.value());
 		dispatch(expr.getPatternArg(), regex.pattern());
 		SqlExpr flags = expr.getFlagsArg();
 		if (flags != null) {
 			dispatch(flags, regex.flags());
 		}
 		regex.close();
 	}
 
 	private void append(SqlShift expr, SqlExprBuilder filter) throws UnsupportedRdbmsOperatorException {
 		SqlBracketBuilder mod = filter.mod(expr.getRange());
 		SqlBracketBuilder open = mod.open();
 		dispatch(expr.getArg(), open);
 		open.rightShift(expr.getRightShift());
 		open.close();
 		mod.plus(expr.getRange());
 		mod.close();
 	}
 
 	private void append(StringValue expr, SqlExprBuilder filter) {
 		filter.varchar(expr.getValue());
 	}
 
 	private void append(TrueValue expr, SqlExprBuilder filter) {
 		filter.appendBoolean(true);
 	}
 
 	private void append(URIColumn uri, SqlExprBuilder filter) {
 		ColumnVar var = uri.getRdbmsVar();
 		String alias = getURIAlias(var);
 		filter.column(alias, "value");
 	}
 
 	private void dispatch(SqlExpr expr, SqlExprBuilder filter)
 			throws UnsupportedRdbmsOperatorException {
 		if (expr instanceof ValueColumnBase) {
 			dispatchValueColumnBase((ValueColumnBase) expr, filter);
 		} else if (expr instanceof IdColumn) {
 			append((IdColumn) expr, filter);
 		} else if (expr instanceof SqlConstant<?>) {
 			dispatchSqlConstant((SqlConstant<?>) expr, filter);
 		} else if (expr instanceof UnarySqlOperator) {
 			dispatchUnarySqlOperator((UnarySqlOperator) expr, filter);
 		} else if (expr instanceof BinarySqlOperator) {
 			dispatchBinarySqlOperator((BinarySqlOperator) expr, filter);
 		} else {
 			dispatchOther(expr, filter);
 		}
 	}
 
 	private void dispatchBinarySqlOperator(BinarySqlOperator expr,
 			SqlExprBuilder filter) throws UnsupportedRdbmsOperatorException {
 		if (expr instanceof SqlAnd) {
 			append((SqlAnd) expr, filter);
 		} else if (expr instanceof SqlEq) {
 			append((SqlEq) expr, filter);
 		} else if (expr instanceof SqlOr) {
 			append((SqlOr) expr, filter);
 		} else if (expr instanceof SqlCompare) {
 			append((SqlCompare) expr, filter);
 		} else if (expr instanceof SqlRegex) {
 			append((SqlRegex) expr, filter);
 		} else if (expr instanceof SqlConcat) {
 			append((SqlConcat) expr, filter);
 		} else if (expr instanceof SqlMathExpr) {
 			append((SqlMathExpr) expr, filter);
 		} else if (expr instanceof SqlLike) {
 			append((SqlLike) expr, filter);
 		} else {
 			throw unsupported(expr);
 		}
 	}
 
 	private void dispatchOther(SqlExpr expr, SqlExprBuilder filter)
 			throws UnsupportedRdbmsOperatorException {
 		if (expr instanceof SqlCase) {
 			append((SqlCase) expr, filter);
+		} else if (expr instanceof SqlMbrContains) {
+			append((SqlMbrContains) expr, filter);
 		} else {
 			throw unsupported(expr);
 		}
 	}
 
 	private void dispatchSqlConstant(SqlConstant<?> expr, SqlExprBuilder filter)
 			throws UnsupportedRdbmsOperatorException {
 		if (expr instanceof DoubleValue) {
 			append((DoubleValue) expr, filter);
 		} else if (expr instanceof FalseValue) {
 			append((FalseValue) expr, filter);
 		} else if (expr instanceof TrueValue) {
 			append((TrueValue) expr, filter);
 		} else if (expr instanceof NumberValue) {
 			append((NumberValue) expr, filter);
 		} else if (expr instanceof SqlNull) {
 			append((SqlNull) expr, filter);
 		} else if (expr instanceof StringValue) {
 			append((StringValue) expr, filter);
 		} else {
 			throw unsupported(expr);
 		}
 	}
 
 	private void dispatchUnarySqlOperator(UnarySqlOperator expr,
 			SqlExprBuilder filter) throws UnsupportedRdbmsOperatorException {
 		if (expr instanceof SqlAbs) {
 			append((SqlAbs) expr, filter);
 		} else if (expr instanceof SqlIsNull) {
 			append((SqlIsNull) expr, filter);
 		} else if (expr instanceof SqlNot) {
 			append((SqlNot) expr, filter);
 		} else if (expr instanceof SqlShift) {
 			append((SqlShift) expr, filter);
 		} else if (expr instanceof SqlLowerCase) {
 			append((SqlLowerCase) expr, filter);
 		} else {
 			throw unsupported(expr);
 		}
 	}
 
 	private void dispatchValueColumnBase(ValueColumnBase expr,
 			SqlExprBuilder filter) throws UnsupportedRdbmsOperatorException {
 		if (expr instanceof BNodeColumn) {
 			append((BNodeColumn) expr, filter);
 		} else if (expr instanceof DatatypeColumn) {
 			append((DatatypeColumn) expr, filter);
 		} else if (expr instanceof HashColumn) {
 			append((HashColumn) expr, filter);
 		} else if (expr instanceof DateTimeColumn) {
 			append((DateTimeColumn) expr, filter);
 		} else if (expr instanceof LabelColumn) {
 			append((LabelColumn) expr, filter);
 		} else if (expr instanceof LongLabelColumn) {
 			append((LongLabelColumn) expr, filter);
 		} else if (expr instanceof LongURIColumn) {
 			append((LongURIColumn) expr, filter);
 		} else if (expr instanceof LanguageColumn) {
 			append((LanguageColumn) expr, filter);
 		} else if (expr instanceof NumericColumn) {
 			append((NumericColumn) expr, filter);
+		} else if (expr instanceof PointColumn) {
+			append((PointColumn) expr, filter);
 		} else if (expr instanceof URIColumn) {
 			append((URIColumn) expr, filter);
 		} else if (expr instanceof RefIdColumn) {
 			append((RefIdColumn) expr, filter);
 		} else {
 			throw unsupported(expr);
 		}
 	}
 
 	private void from(SqlQueryBuilder subquery, FromItem item)
 			throws RdbmsException, UnsupportedRdbmsOperatorException {
 		assert !item.isLeft() : item;
 		String alias = item.getAlias();
 		if (item instanceof JoinItem) {
 			String tableName = ((JoinItem) item).getTableName();
 			subJoinAndFilter(subquery.from(tableName, alias), item);
 		} else {
 			subJoinAndFilter(subquery.from(alias), item);
 		}
 	}
 
 	private String getBNodeAlias(ColumnVar var) {
 		return "b" + getDBName(var);
 	}
 
 	private String getDatatypeAlias(ColumnVar var) {
 		return "d" + getDBName(var);
 	}
 
 	private String getDateTimeAlias(ColumnVar var) {
 		return "t" + getDBName(var);
 	}
 
 	private String getDBName(ColumnVar var) {
 		String name = var.getName();
 		if (name.indexOf('-') >= 0)
 			return name.replace('-', '_');
 		return "_" + name; // might be a keyword otherwise
 	}
 
 	private String getHashAlias(ColumnVar var) {
 		return "h" + getDBName(var);
 	}
 
 	private String getLabelAlias(ColumnVar var) {
 		return "l" + getDBName(var);
 	}
 
 	private String getLongLabelAlias(ColumnVar var) {
 		return "ll" + getDBName(var);
 	}
 
 	private String getLongURIAlias(ColumnVar var) {
 		return "lu" + getDBName(var);
 	}
 
 	private String getLanguageAlias(ColumnVar var) {
 		return "g" + getDBName(var);
 	}
 
 	private String getNumericAlias(ColumnVar var) {
 		return "n" + getDBName(var);
 	}
+	
+	private String getPointAlias(ColumnVar var) {
+		return "p" + getDBName(var);
+	}	
 
 	private String getURIAlias(ColumnVar var) {
 		return "u" + getDBName(var);
 	}
 
 	private void join(SqlJoinBuilder query, FromItem join)
 			throws RdbmsException, UnsupportedRdbmsOperatorException {
 		String alias = join.getAlias();
 		if (join instanceof JoinItem) {
 			String tableName = ((JoinItem) join).getTableName();
 			if (join.isLeft()) {
 				subJoinAndFilter(query.leftjoin(tableName, alias), join);
 			} else {
 				subJoinAndFilter(query.join(tableName, alias), join);
 			}
 		} else {
 			if (join.isLeft()) {
 				subJoinAndFilter(query.leftjoin(alias), join);
 			} else {
 				subJoinAndFilter(query.join(alias), join);
 			}
 		}
 	}
 
 	private SqlJoinBuilder subJoinAndFilter(SqlJoinBuilder query, FromItem from)
 			throws RdbmsException, UnsupportedRdbmsOperatorException {
 		if (from instanceof UnionItem) {
 			UnionItem union = (UnionItem) from;
 			List<String> names = union.getSelectVarNames();
 			List<ColumnVar> vars = union.appendVars(new ArrayList<ColumnVar>());
 			SqlQueryBuilder subquery = query.subquery();
 			for (FromItem item : union.getUnion()) {
 				for (int i = 0, n = names.size(); i < n; i++) {
 					ColumnVar var = item.getVar(names.get(i));
 					SqlExprBuilder select = subquery.select();
 					if (var == null) {
 						select.appendNull();
 					} else {
 						select.column(var.getAlias(), var.getColumn());
 					}
 					select.as(vars.get(i).getColumn());
 				}
 				from(subquery, item);
 				subquery = subquery.union();
 			}
 		}
 		for (FromItem join : from.getJoins()) {
 			join(query, join);
 		}
 		for (SqlExpr expr : from.getFilters()) {
 			dispatch(expr, query.on().and());
 		}
 		return query;
 	}
 
 	private UnsupportedRdbmsOperatorException unsupported(Object object)
 			throws UnsupportedRdbmsOperatorException {
 		return new UnsupportedRdbmsOperatorException(object.toString());
 	}
 
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/evaluation/SqlQueryBuilder.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/evaluation/SqlQueryBuilder.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/evaluation/SqlQueryBuilder.java (revision 97)
@@ -1,144 +1,157 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms.evaluation;
 
 import java.util.List;
 
 /**
  * Facilitates the building of a SQL query.
  * 
  * @author James Leigh
  * 
  */
 public class SqlQueryBuilder {
 	private QueryBuilderFactory factory;
 	private boolean distinct;
 	private SqlExprBuilder select;
 	private SqlJoinBuilder from;
 	private StringBuilder group = new StringBuilder();
 	private SqlExprBuilder order;
 	private SqlQueryBuilder union;
 	private Integer offset;
 	private Integer limit;
 
 	public SqlQueryBuilder(QueryBuilderFactory factory) {
 		super();
 		this.factory = factory;
 		select = factory.createSqlExprBuilder();
 		order = factory.createSqlExprBuilder();
 	}
 
 	public List<Object> findParameters(List<Object> parameters) {
 		parameters.addAll(select.getParameters());
 		if (from != null) {
 			from.findParameters(parameters);
 		}
 		if (union != null) {
 			union.findParameters(parameters);
 		}
 		parameters.addAll(order.getParameters());
 		return parameters;
 	}
 
 	public void distinct() {
 		distinct = true;
 	}
 
 	public SqlExprBuilder select() {
 		if (!select.isEmpty())
 			select.append(",\n ");
 		return select;
 	}
 
 	public SqlJoinBuilder from(String table, String alias) {
 		assert from == null : alias;
 		return from = factory.createSqlJoinBuilder(table, alias);
 	}
 
 	public SqlJoinBuilder from(String alias) {
 		assert from == null : alias;
 		return from = factory.createSqlJoinBuilder(null, alias);
 	}
 
 	public SqlExprBuilder filter() {
 		assert from != null;
 		return from.on();
 	}
 
 	public SqlQueryBuilder groupBy(String... expressions) {
 		for (String expr : expressions) {
 			if (group.length() == 0) {
 				group.append("\nGROUP BY ");
 			} else {
 				group.append(", ");
 			}
 			group.append(expr);
 		}
 		return this;
 	}
 
 	public SqlQueryBuilder union() {
 		assert union == null : union;
 		return union = factory.createSqlQueryBuilder();
 	}
 
 	public boolean isEmpty() {
 		return select.isEmpty() && from == null;
 	}
 
 	@Override
 	public String toString() {
 		StringBuilder sb = new StringBuilder();
+		if (union != null && !union.isEmpty()) {
+			sb.append("SELECT * FROM (");
+		}
 		sb.append("SELECT ");
-		if (distinct) {
+		/* TODO Workaround: Always make results distinct, so that LIMIT can be applied in a meaningful way
+		 * Reduces the number of results from of the based_near sample query from 1,300 to 60
+		 * 
+		 * - This is not caused by duplicate DB entries, cf. SELECT * FROM [LABEL_VALUES, URI_VALUES etc.]id IN (208531, 805506008, 1603, 805312806, 208432,208433)
+		 * - Neither by the modified behavior of always joining on LONG_LABEL_URIs etc. (they are empty).
+		 * - Thus the cause probably lies with a join on NULL columns somewhere
+		 */  
+//		if (distinct) {
 			sb.append("DISTINCT ");
-		}
+//		}
 		if (select.isEmpty()) {
 			sb.append("*");
 		} else {
 			sb.append(select.toSql());
 		}
 		if (from != null) {
 			sb.append("\nFROM ").append(from.getFromClause());
 			if (!from.on().isEmpty()) {
 				sb.append("\nWHERE ");
 				sb.append(from.on().toSql());
 			}
 		}
 		sb.append(group);
 		if (union != null && !union.isEmpty()) {
 			sb.append("\nUNION ALL ");
 			sb.append(union.toString());
 		}
 		if (!order.isEmpty()) {
 			sb.append("\nORDER BY ").append(order.toSql());
 		}
 		if (limit != null) {
 			sb.append("\nLIMIT ").append(limit);
 		}
 		if (offset != null) {
 			sb.append("\nOFFSET ").append(offset);
 		}
+		if (union != null && !union.isEmpty()) {
+			sb.append(") mysqlfix ");
+		}
 		return sb.toString();
 	}
 
 	public SqlExprBuilder orderBy() {
 		if (!order.isEmpty())
 			order.append(",\n ");
 		return order;
 	}
 
 	public void offset(Integer offset) {
 		this.offset = offset;
 		if (limit == null) {
 			limit = Integer.MAX_VALUE;
 		}
 	}
 
 	public void limit(Integer limit) {
 		this.limit = limit;
 	}
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/RdbmsTripleRepository.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/RdbmsTripleRepository.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/RdbmsTripleRepository.java (revision 76)
@@ -1,498 +1,542 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms;
 
 import java.sql.Connection;
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.LinkedList;
 import java.util.List;
 import java.util.concurrent.locks.Lock;
 
 import org.openrdf.model.Resource;
 import org.openrdf.model.URI;
 import org.openrdf.model.Value;
 import org.openrdf.sail.SailException;
 import org.openrdf.sail.helpers.DefaultSailChangedEvent;
 import org.openrdf.sail.rdbms.evaluation.QueryBuilderFactory;
 import org.openrdf.sail.rdbms.evaluation.SqlBracketBuilder;
 import org.openrdf.sail.rdbms.evaluation.SqlJoinBuilder;
 import org.openrdf.sail.rdbms.evaluation.SqlQueryBuilder;
 import org.openrdf.sail.rdbms.exceptions.RdbmsException;
 import org.openrdf.sail.rdbms.iteration.EmptyRdbmsResourceIteration;
 import org.openrdf.sail.rdbms.iteration.EmptyRdbmsStatementIteration;
 import org.openrdf.sail.rdbms.iteration.RdbmsResourceIteration;
 import org.openrdf.sail.rdbms.iteration.RdbmsStatementIteration;
 import org.openrdf.sail.rdbms.managers.TransTableManager;
 import org.openrdf.sail.rdbms.managers.TripleManager;
 import org.openrdf.sail.rdbms.model.RdbmsResource;
 import org.openrdf.sail.rdbms.model.RdbmsStatement;
 import org.openrdf.sail.rdbms.model.RdbmsURI;
 import org.openrdf.sail.rdbms.model.RdbmsValue;
 import org.openrdf.sail.rdbms.schema.BNodeTable;
 import org.openrdf.sail.rdbms.schema.IdSequence;
 import org.openrdf.sail.rdbms.schema.LiteralTable;
 import org.openrdf.sail.rdbms.schema.URITable;
 import org.openrdf.sail.rdbms.schema.ValueTable;
 
 /**
  * Facade to {@link TransTableManager}, {@link ResourceTable}, and
  * {@link LiteralTable} for adding, removing, and retrieving statements from the
  * database.
  * 
  * @author James Leigh
  * 
  */
 public class RdbmsTripleRepository {
 	public static int STMT_BUFFER = 32; 
 	private Connection conn;
 	private RdbmsValueFactory vf;
 	private TransTableManager statements;
 	private QueryBuilderFactory factory;
 	private BNodeTable bnodes;
 	private URITable uris;
 	private LiteralTable literals;
 	private Lock readLock;
 	private DefaultSailChangedEvent sailChangedEvent;
 	private TripleManager manager;
 	private LinkedList<RdbmsStatement> queue = new LinkedList<RdbmsStatement>();
+	private LinkedList<RdbmsStatement> statementsAdded = new LinkedList<RdbmsStatement>();
 	private IdSequence ids; 
 
 	public Connection getConnection() {
 		return conn;
 	}
 
 	public void setConnection(Connection conn) {
 		this.conn = conn;
 	}
 
 	public void setIdSequence(IdSequence ids) {
 		this.ids = ids;
 	}
 
 	public RdbmsValueFactory getValueFactory() {
 		return vf;
 	}
 
 	public void setValueFactory(RdbmsValueFactory vf) {
 		this.vf = vf;
 	}
 
 	public DefaultSailChangedEvent getSailChangedEvent() {
 		return sailChangedEvent;
 	}
 
 	public void setSailChangedEvent(DefaultSailChangedEvent sailChangedEvent) {
 		this.sailChangedEvent = sailChangedEvent;
 	}
 
 	public void setQueryBuilderFactory(QueryBuilderFactory factory) {
 		this.factory = factory;
 	}
 
 	public void setBNodeTable(BNodeTable bnodes) {
 		this.bnodes = bnodes;
 	}
 
 	public void setURITable(URITable uris) {
 		this.uris = uris;
 	}
 
 	public void setLiteralTable(LiteralTable literals) {
 		this.literals = literals;
 	}
 
 	public void setTransaction(TransTableManager temporary) {
 		this.statements = temporary;
 	}
 
 	public void setTripleManager(TripleManager tripleManager) {
 		this.manager = tripleManager;
 	}
 
 	public void flush() throws RdbmsException {
 		try {
 			synchronized (queue) {
 				while (!queue.isEmpty()) {
 					insert(queue.removeFirst());
 				}
 			}
 			vf.flush();
 			manager.flush();
 		}
 		catch (SQLException e) {
 			throw new RdbmsException(e);
 		}
 		catch (InterruptedException e) {
 			throw new RdbmsException(e);
 		}
 	}
 
 	public synchronized void begin() throws SQLException {
 		conn.setAutoCommit(false);
 	}
 
 	public synchronized void close() throws SQLException {
 		manager.close();
 		if (!conn.getAutoCommit()) {
 			conn.rollback();
 		}
 		conn.setAutoCommit(true);
 		conn.close();
-	}
-
-	public synchronized void commit() throws SQLException, RdbmsException, InterruptedException {
+		if (readLock != null) {
+			readLock.unlock();
+			readLock = null;
+		}
+	}
+
+	public synchronized List<RdbmsStatement> commit() throws SQLException, RdbmsException, InterruptedException {
 		synchronized (queue) {
 			while (!queue.isEmpty()) {
 				insert(queue.removeFirst());
 			}
 		}
-		manager.flush();
-		conn.commit();
-		conn.setAutoCommit(true);
+
+		LinkedList<RdbmsStatement> committedStatements = new LinkedList<RdbmsStatement>(); 		
+
+		synchronized (statementsAdded) {
+			manager.flush();
+			conn.commit();
+			conn.setAutoCommit(true);
+			committedStatements.addAll(statementsAdded);
+			statementsAdded.clear();
+		}
+			
 		if (readLock != null) {
 			readLock.unlock();
 			readLock = null;
 		}
 		Lock writeLock = vf.getIdWriteLock();
 		boolean locked = writeLock.tryLock();
 		try {
 			vf.flush();
 			statements.committed(locked);
 		} finally {
 			if (locked) {
 				writeLock.unlock();
 			}
 		}
+		
+		return committedStatements;
 	}
 
 	public void rollback() throws SQLException, SailException {
 		synchronized (queue) {
 			queue.clear();
 		}
 		manager.clear();
 		if (!conn.getAutoCommit()) {
 			conn.rollback();
 			conn.setAutoCommit(true);
 		}
 		if (readLock != null) {
 			readLock.unlock();
 			readLock = null;
 		}
 	}
 
+	@Override
+	protected void finalize()
+		throws Throwable
+	{
+		if (readLock != null) {
+			readLock.unlock();
+			readLock = null;
+		}
+		super.finalize();
+	}
+
 	public void add(RdbmsStatement st) throws SailException, SQLException, InterruptedException {
 		if (readLock == null) {
 			readLock = vf.getIdReadLock();
 			readLock.lock();
 		}
 		synchronized (queue) {
 			queue.add(st);
 			if (queue.size() > getMaxQueueSize()) {
 				insert(queue.removeFirst());
 			}
 		}
 	}
 
 	public RdbmsStatementIteration find(Resource subj, URI pred, Value obj,
-			Resource... ctxs) throws RdbmsException {
+			boolean includeInferred, Resource... ctxs) throws RdbmsException {
 		try {
 			RdbmsResource s = vf.asRdbmsResource(subj);
 			RdbmsURI p = vf.asRdbmsURI(pred);
-			RdbmsValue o = vf.asRdbmsValue(obj);
+			RdbmsValue o = vf.asRdbmsValue(obj, pred);
 			RdbmsResource[] c = vf.asRdbmsResource(ctxs);
 			flush();
-			SqlQueryBuilder query = buildSelectQuery(s, p, o, c);
+			SqlQueryBuilder query = buildSelectQuery(s, p, o, includeInferred, c);
 			if (query == null)
 				return new EmptyRdbmsStatementIteration();
 			List<?> parameters = query.findParameters(new ArrayList<Object>());
 			PreparedStatement stmt = conn.prepareStatement(query.toString());
 			try {
 				for (int i = 0, n = parameters.size(); i < n; i++) {
 					stmt.setObject(i + 1, parameters.get(i));
 				}
 				return new RdbmsStatementIteration(vf, stmt, ids);
 			} catch (SQLException e) {
 				stmt.close();
 				throw e;
 			}
 		} catch (SQLException e) {
 			throw new RdbmsException(e);
 		}
 
 	}
 
 	public RdbmsResourceIteration findContexts() throws SQLException,
 			RdbmsException {
 		flush();
 		String qry = buildContextQuery();
 		if (qry == null)
 			return new EmptyRdbmsResourceIteration();
 		PreparedStatement stmt = conn.prepareStatement(qry);
 		try {
 			return new RdbmsResourceIteration(vf, stmt);
 		} catch (SQLException e) {
 			stmt.close();
 			throw e;
 		}
 	}
 
 	public boolean isClosed() throws SQLException {
 		return conn.isClosed();
 	}
 
-	public int remove(Resource subj, URI pred, Value obj, Resource... ctxs)
+	public int remove(Resource subj, URI pred, Value obj, boolean explicit, Resource... ctxs)
 			throws RdbmsException {
 		RdbmsResource s = vf.asRdbmsResource(subj);
 		RdbmsURI p = vf.asRdbmsURI(pred);
-		RdbmsValue o = vf.asRdbmsValue(obj);
+		RdbmsValue o = vf.asRdbmsValue(obj, pred);
 		RdbmsResource[] c = vf.asRdbmsResource(ctxs);
 		flush();
 		try {
 			Collection<Number> predicates;
 			if (p == null) {
 				predicates = statements.getPredicateIds();
 			} else {
 				predicates = Collections.singleton(vf.getInternalId(p));
 			}
 			int total = 0;
 			for (Number id : predicates) {
 				String tableName = statements.findTableName(id);
 				if (!statements.isPredColumnPresent(id)) {
 					p = null;
 				}
-				String query = buildDeleteQuery(tableName, s, p, o, c);
+				String query = buildDeleteQuery(tableName, s, p, o, explicit, c);
 				PreparedStatement stmt = conn.prepareStatement(query);
 				try {
 					setSelectQuery(stmt, s, p, o, c);
 					int count = stmt.executeUpdate();
 					statements.removed(id, count);
 					total += count;
 				} finally {
 					stmt.close();
 				}
 			}
 			if (total > 0) {
 				sailChangedEvent.setStatementsRemoved(true);
 			}
 			return total;
 		} catch (SQLException e) {
 			throw new RdbmsException(e);
 		}
 	}
 
 	public long size(RdbmsResource... ctxs) throws SQLException, SailException {
 		flush();
 		String qry = buildCountQuery(ctxs);
 		if (qry == null)
 			return 0;
 		PreparedStatement stmt = conn.prepareStatement(qry);
 		try {
 			setCountQuery(stmt, ctxs);
 			ResultSet rs = stmt.executeQuery();
 			try {
 				if (rs.next())
 					return rs.getLong(1);
 				throw new RdbmsException("Could not determine size");
 			} finally {
 				rs.close();
 			}
 		} finally {
 			stmt.close();
 		}
 	}
 
 	protected int getMaxQueueSize() {
 		return STMT_BUFFER;
 	}
 
 	private String buildContextQuery() throws SQLException {
 		if (statements.isEmpty())
 			return null;
 		String tableName = statements.getCombinedTableName();
 		SqlQueryBuilder query = factory.createSqlQueryBuilder();
 		query.select().column("t", "ctx");
 		query
 				.select()
 				.append(
 						"CASE WHEN MIN(u.value) IS NOT NULL THEN MIN(u.value) ELSE MIN(b.value) END");
 		SqlJoinBuilder join = query.from(tableName, "t");
 		join.leftjoin(bnodes.getName(), "b").on("id", "t.ctx");
 		join.leftjoin(uris.getShortTableName(), "u").on("id", "t.ctx");
 		SqlBracketBuilder open = query.filter().and().open();
 		open.column("u", "value").isNotNull();
 		open.or();
 		open.column("b", "value").isNotNull();
 		open.close();
 		query.groupBy("t.ctx");
 		return query.toString();
 	}
 
 	private String buildCountQuery(RdbmsResource... ctxs) throws SQLException {
 		String tableName = statements.getCombinedTableName();
 		StringBuilder sb = new StringBuilder();
 		sb.append("SELECT COUNT(*) FROM ");
 		sb.append(tableName).append(" t");
 		if (ctxs != null && ctxs.length > 0) {
 			sb.append("\nWHERE ");
 			for (int i = 0; i < ctxs.length; i++) {
 				sb.append("t.ctx = ?");
 				if (i < ctxs.length - 1) {
 					sb.append(" OR ");
 				}
 			}
 		}
 		return sb.toString();
 	}
 
 	private String buildDeleteQuery(String tableName, RdbmsResource subj,
-			RdbmsURI pred, RdbmsValue obj, RdbmsResource... ctxs)
+			RdbmsURI pred, RdbmsValue obj, boolean explicit, RdbmsResource... ctxs)
 			throws RdbmsException, SQLException {
 		StringBuilder sb = new StringBuilder();
 		sb.append("DELETE FROM ").append(tableName);
-		return buildWhere(sb, subj, pred, obj, ctxs);
+		return buildWhere(sb, subj, pred, obj, explicit, ctxs);
 	}
 
 	private SqlQueryBuilder buildSelectQuery(RdbmsResource subj, RdbmsURI pred,
-			RdbmsValue obj, RdbmsResource... ctxs) throws RdbmsException,
+			RdbmsValue obj, boolean includeInferred, RdbmsResource... ctxs) throws RdbmsException,
 			SQLException {
-		String tableName = statements.getTableName(vf.getInternalId(pred));
+		Number[] ctxIds = null;
+		Number subjId = null, objId = null;
+		
+		if (ctxs != null && ctxs.length > 0) {
+			ctxIds = new Number[ctxs.length];
+			for (int i = 0; i < ctxIds.length; i++) {
+				ctxIds[i] = vf.getInternalId(ctxs[i]);
+			}
+		}
+
+		if (subj != null)
+			subjId = vf.getInternalId(subj);
+	
+		if (obj != null)
+			objId = vf.getInternalId(obj);
+		
+		String tableName = statements.getTableName(vf.getInternalId(pred), subjId, objId, ctxIds);
 		SqlQueryBuilder query = factory.createSqlQueryBuilder();
 		query.select().column("t", "ctx");
 		query.select().append("CASE WHEN cu.value IS NOT NULL THEN cu.value WHEN clu.value IS NOT NULL THEN clu.value ELSE cb.value END");
 		query.select().column("t", "subj");
 		query.select().append("CASE WHEN su.value IS NOT NULL THEN su.value WHEN slu.value IS NOT NULL THEN slu.value ELSE sb.value END");
 		query.select().column("pu", "id");
 		query.select().column("pu", "value");
 		query.select().column("t", "obj");
 		query.select().append("CASE WHEN ou.value IS NOT NULL THEN ou.value" +
 				" WHEN olu.value IS NOT NULL THEN olu.value" +
 				" WHEN ob.value IS NOT NULL THEN ob.value" +
 				" WHEN ol.value IS NOT NULL THEN ol.value ELSE oll.value END");
 		query.select().column("od", "value");
 		query.select().column("og", "value");
+		query.select().column("t", "expl");
 		SqlJoinBuilder join;
 		if (pred != null) {
 			join = query.from(uris.getShortTableName(), "pu");
 			// TODO what about long predicate URIs? 
 			join = join.join(tableName, "t");
 		} else {
 			join = query.from(tableName, "t");
 		}
 		if (pred == null) {
 			join.join(uris.getShortTableName(), "pu").on("id", "t.pred");
 		}
 		join.leftjoin(uris.getShortTableName(), "cu").on("id", "t.ctx");
 		join.leftjoin(uris.getLongTableName(), "clu").on("id", "t.ctx");
 		join.leftjoin(bnodes.getName(), "cb").on("id", "t.ctx");
 		join.leftjoin(uris.getShortTableName(), "su").on("id", "t.subj");
 		join.leftjoin(uris.getLongTableName(), "slu").on("id", "t.subj");
 		join.leftjoin(bnodes.getName(), "sb").on("id", "t.subj");
 		join.leftjoin(uris.getShortTableName(), "ou").on("id", "t.obj");
 		join.leftjoin(uris.getLongTableName(), "olu").on("id", "t.obj");
 		join.leftjoin(bnodes.getName(), "ob").on("id", "t.obj");
 		join.leftjoin(literals.getLabelTable().getName(), "ol").on("id", "t.obj");
 		join.leftjoin(literals.getLongLabelTable().getName(), "oll").on("id", "t.obj");
 		join.leftjoin(literals.getLanguageTable().getName(), "og").on("id", "t.obj");
 		join.leftjoin(literals.getDatatypeTable().getName(), "od").on("id", "t.obj");
-		if (ctxs != null && ctxs.length > 0) {
-			Number[] ids = new Number[ctxs.length];
-			for (int i = 0; i < ids.length; i++) {
-				ids[i] = vf.getInternalId(ctxs[i]);
-			}
-			query.filter().and().columnIn("t", "ctx", ids);
-		}
-		if (subj != null) {
-			Number id = vf.getInternalId(subj);
-			query.filter().and().columnEquals("t", "subj", id);
+		if (ctxIds != null) {
+			query.filter().and().columnIn("t", "ctx", ctxIds);
+		}
+		if (subjId != null) {
+			query.filter().and().columnEquals("t", "subj", subjId);
 		}
 		if (pred != null) {
 			Number id = vf.getInternalId(pred);
 			query.filter().and().columnEquals("pu", "id", id);
 			if (statements.isPredColumnPresent(id)) {
 				query.filter().and().columnEquals("t", "pred", id);
 			}
 		}
-		if (obj != null) {
-			Number id = vf.getInternalId(obj);
-			query.filter().and().columnEquals("t", "obj", id);
+		if (objId != null) {
+			query.filter().and().columnEquals("t", "obj", objId);
+		}
+		if (!includeInferred) {
+			query.filter().and().columnEquals("t", "expl", new Boolean(true));
 		}
 		return query;
 	}
 
 	private String buildWhere(StringBuilder sb, RdbmsResource subj,
-			RdbmsURI pred, RdbmsValue obj, RdbmsResource... ctxs) {
+			RdbmsURI pred, RdbmsValue obj, boolean explicit, RdbmsResource... ctxs) {
 		sb.append("\nWHERE 1=1");
 		if (ctxs != null && ctxs.length > 0) {
 			sb.append(" AND (");
 			for (int i = 0; i < ctxs.length; i++) {
 				sb.append("ctx = ?");
 				if (i < ctxs.length - 1) {
 					sb.append(" OR ");
 				}
 			}
 			sb.append(")");
 		}
 		if (subj != null) {
 			sb.append(" AND subj = ?");
 		}
 		if (pred != null) {
 			sb.append(" AND pred = ?");
 		}
 		if (obj != null) {
 			sb.append(" AND obj = ?");
 		}
+		sb.append(" AND expl = " + Boolean.toString(explicit));
 		return sb.toString();
 	}
 
 	private void insert(RdbmsStatement st)
 		throws RdbmsException, SQLException, InterruptedException
 	{
 		Number ctx = vf.getInternalId(st.getContext());
 		Number subj = vf.getInternalId(st.getSubject());
 		Number pred = vf.getPredicateId(st.getPredicate());
-		Number obj = vf.getInternalId(st.getObject());
-		manager.insert(ctx, subj, pred, obj);
+		Number obj = vf.getInternalId(st.getObject(), st.getPredicate());
+		manager.insert(ctx, subj, pred, obj, st.isExplicit());
+		synchronized (statementsAdded) {
+			statementsAdded.add(st);
+		}
 	}
 
 	private void setCountQuery(PreparedStatement stmt, RdbmsResource... ctxs)
 			throws SQLException, RdbmsException {
 		if (ctxs != null && ctxs.length > 0) {
 			for (int i = 0; i < ctxs.length; i++) {
 				stmt.setObject(i + 1, vf.getInternalId(ctxs[i]));
 			}
 		}
 	}
 
 	private void setSelectQuery(PreparedStatement stmt, RdbmsResource subj,
 			RdbmsURI pred, RdbmsValue obj, RdbmsResource... ctxs)
 			throws SQLException, RdbmsException {
 		int p = 0;
 		if (ctxs != null && ctxs.length > 0) {
 			for (int i = 0; i < ctxs.length; i++) {
 				if (ctxs[i] == null) {
 					stmt.setLong(++p, ValueTable.NIL_ID);
 				} else {
 					stmt.setObject(++p, vf.getInternalId(ctxs[i]));
 				}
 			}
 		}
 		if (subj != null) {
 			stmt.setObject(++p, vf.getInternalId(subj));
 		}
 		if (pred != null) {
 			stmt.setObject(++p, vf.getInternalId(pred));
 		}
 		if (obj != null) {
 			stmt.setObject(++p, vf.getInternalId(obj));
 		}
 	}
 
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/RdbmsConnection.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/RdbmsConnection.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/RdbmsConnection.java (revision 54)
@@ -1,225 +1,363 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms;
 
+import info.aduna.concurrent.locks.Lock;
+import info.aduna.iteration.CloseableIteration;
+import info.aduna.iteration.Iterations;
+
 import java.sql.SQLException;
 import java.util.Collection;
-
-import info.aduna.iteration.CloseableIteration;
+import java.util.Collections;
+import java.util.List;
 
 import org.openrdf.model.Namespace;
 import org.openrdf.model.Resource;
 import org.openrdf.model.Statement;
 import org.openrdf.model.URI;
 import org.openrdf.model.Value;
 import org.openrdf.query.BindingSet;
 import org.openrdf.query.Dataset;
 import org.openrdf.query.QueryEvaluationException;
 import org.openrdf.query.algebra.TupleExpr;
 import org.openrdf.query.algebra.evaluation.EvaluationStrategy;
 import org.openrdf.sail.SailConnection;
 import org.openrdf.sail.SailException;
 import org.openrdf.sail.helpers.DefaultSailChangedEvent;
 import org.openrdf.sail.helpers.SailConnectionBase;
+import org.openrdf.sail.inferencer.InferencerConnection;
 import org.openrdf.sail.rdbms.evaluation.RdbmsEvaluationFactory;
 import org.openrdf.sail.rdbms.exceptions.RdbmsException;
 import org.openrdf.sail.rdbms.iteration.NamespaceIteration;
 import org.openrdf.sail.rdbms.iteration.RdbmsResourceIteration;
+import org.openrdf.sail.rdbms.iteration.RdbmsStatementIteration;
 import org.openrdf.sail.rdbms.managers.NamespaceManager;
 import org.openrdf.sail.rdbms.model.RdbmsResource;
+import org.openrdf.sail.rdbms.model.RdbmsStatement;
 import org.openrdf.sail.rdbms.model.RdbmsURI;
 import org.openrdf.sail.rdbms.model.RdbmsValue;
 import org.openrdf.sail.rdbms.optimizers.RdbmsQueryOptimizer;
 
 /**
  * Coordinates the triple store, namespace manager, optimizer, and evaluation
  * strategy into the {@link SailConnection} interface.
  * 
  * @author James Leigh
  * 
  */
-public class RdbmsConnection extends SailConnectionBase {
+public class RdbmsConnection extends SailConnectionBase implements InferencerConnection {
 	private RdbmsStore sail;
 	private RdbmsValueFactory vf;
 	private RdbmsTripleRepository triples;
 	private NamespaceManager namespaces;
 	private RdbmsQueryOptimizer optimizer;
 	private RdbmsEvaluationFactory factory;
+	private java.util.concurrent.locks.Lock lock;
+	private boolean locked;
 
 	public RdbmsConnection(RdbmsStore sail, RdbmsTripleRepository triples) {
 		super(sail);
 		this.sail = sail;
 		this.vf = sail.getValueFactory();
 		this.triples = triples;
 	}
 
 	public void setNamespaces(NamespaceManager namespaces) {
 		this.namespaces = namespaces;
 	}
 
 	public void setRdbmsQueryOptimizer(RdbmsQueryOptimizer optimizer) {
 		this.optimizer = optimizer;
 	}
 
 	public void setRdbmsEvaluationFactory(RdbmsEvaluationFactory factory) {
 		this.factory = factory;
 	}
 
+	public void setLock(java.util.concurrent.locks.Lock lock) {
+		this.lock = lock;
+	}
+
 	@Override
 	protected void addStatementInternal(Resource subj, URI pred, Value obj,
 			Resource... contexts) throws SailException {
+		addStatement(subj, pred, obj, true, contexts);
+	}
+	
+	protected void addStatement(Resource subj, URI pred, Value obj,
+			boolean explicit, Resource... contexts) throws SailException {
 		try {
 			if (contexts.length == 0) {
-				triples.add(vf.createStatement(subj, pred, obj));
-			} else {
-				for (Resource ctx : contexts) {
-					triples.add(vf.createStatement(subj, pred, obj, ctx));
-				}
+				contexts = new Resource[] { null };
+			}
+
+			for (Resource context : contexts) {			
+				triples.add(vf.createStatement(subj, pred, obj, explicit, context));
 			}
 		} catch (SQLException e) {
 			throw new RdbmsException(e);
 		}
 		catch (InterruptedException e) {
 			throw new RdbmsException(e);
 		}
 	}
 
 	@Override
 	protected void clearInternal(Resource... contexts) throws SailException {
-		removeStatementsInternal(null, null, null, contexts);
+		removeStatements(null, null, null, contexts);
 	}
 
 	@Override
 	protected void closeInternal() throws SailException {
 		try {
 			triples.close();
 		} catch (SQLException e) {
 			throw new RdbmsException(e);
+		} finally {
+			unlock();
 		}
 	}
 
 	@Override
 	protected void commitInternal() throws SailException {
-		try {
-			triples.commit();
+		List <RdbmsStatement> committedStatements = null;
+		try {
+			 committedStatements = triples.commit();
+			unlock();
 		} catch (SQLException e) {
 			throw new RdbmsException(e);
 		}
 		catch (InterruptedException e) {
 			throw new RdbmsException(e);
 		}
 
+		if (hasConnectionListeners()) {
+			for (Statement st : committedStatements)
+				notifyStatementAdded(st);
+		}		
+		
 		sail.notifySailChanged(triples.getSailChangedEvent());
 		// create a fresh event object.
 		triples.setSailChangedEvent(new DefaultSailChangedEvent(sail));
 	}
 
 	@Override
 	protected RdbmsResourceIteration getContextIDsInternal()
 			throws SailException {
 		try {
 			return triples.findContexts();
 		} catch (SQLException e) {
 			throw new RdbmsException(e);
 		}
 	}
 
 	@Override
 	protected CloseableIteration<? extends Statement, SailException> getStatementsInternal(
 			Resource subj, URI pred, Value obj, boolean includeInferred,
 			Resource... contexts) throws SailException {
 		RdbmsResource s = vf.asRdbmsResource(subj);
 		RdbmsURI p = vf.asRdbmsURI(pred);
-		RdbmsValue o = vf.asRdbmsValue(obj);
+		RdbmsValue o = vf.asRdbmsValue(obj, pred);
 		RdbmsResource[] c = vf.asRdbmsResource(contexts);
-		return triples.find(s, p, o, c);
+		return triples.find(s, p, o, includeInferred, c);
 	}
 
 	@Override
 	protected void removeStatementsInternal(Resource subj, URI pred, Value obj,
 			Resource... contexts) throws SailException {
+		removeStatements(subj, pred, obj, true, contexts);
+	}	
+	protected int removeStatements(Resource subj, URI pred, Value obj,
+			boolean explicit, Resource... contexts) throws SailException {
 		RdbmsResource s = vf.asRdbmsResource(subj);
 		RdbmsURI p = vf.asRdbmsURI(pred);
-		RdbmsValue o = vf.asRdbmsValue(obj);
+		RdbmsValue o = vf.asRdbmsValue(obj, pred);
 		RdbmsResource[] c = vf.asRdbmsResource(contexts);
-		triples.remove(s, p, o, c);
+		
+		int removeCount = 0;
+
+		List<RdbmsStatement> removedStatements = Collections.emptyList();
+
+		if (hasConnectionListeners()) {
+			// We need to iterate over all matching triples so that they can
+			// be reported
+			RdbmsStatementIteration it = triples.find(s, p, o, explicit, c);
+			removedStatements = Iterations.asList(it);
+		}
+
+		removeCount += triples.remove(s, p, o, explicit, c);
+
+		for (Statement st : removedStatements) {
+			notifyStatementRemoved(st);
+		}
+		
+		return removeCount;
 	}
 
 	@Override
 	protected void rollbackInternal() throws SailException {
 		try {
 			triples.rollback();
 		} catch (SQLException e) {
 			throw new RdbmsException(e);
+		} finally {
+			unlock();
 		}
 	}
 
 	@Override
 	protected CloseableIteration<BindingSet, QueryEvaluationException> evaluateInternal(
 			TupleExpr expr, Dataset dataset, BindingSet bindings,
 			boolean includeInferred) throws SailException {
 		triples.flush();
 		try {
 			TupleExpr tupleExpr;
 			EvaluationStrategy strategy;
 			strategy = factory.createRdbmsEvaluation(dataset);
 			tupleExpr = optimizer.optimize(expr, dataset, bindings, strategy);
 			return strategy.evaluate(tupleExpr, bindings);
 		} catch (QueryEvaluationException e) {
 			throw new SailException(e);
 		}
 	}
 
 	@Override
 	protected void clearNamespacesInternal() throws SailException {
 		namespaces.clearPrefixes();
 	}
 
 	@Override
 	protected String getNamespaceInternal(String prefix) throws SailException {
 		Namespace ns = namespaces.findByPrefix(prefix);
 		if (ns == null)
 			return null;
 		return ns.getName();
 	}
 
 	@Override
 	protected CloseableIteration<? extends Namespace, SailException> getNamespacesInternal()
 			throws SailException {
 		Collection<? extends Namespace> ns = namespaces.getNamespacesWithPrefix();
 		return new NamespaceIteration(ns.iterator());
 	}
 
 	@Override
 	protected void removeNamespaceInternal(String prefix) throws SailException {
 		namespaces.removePrefix(prefix);
 	}
 
 	@Override
 	protected void setNamespaceInternal(String prefix, String name)
 			throws SailException {
 		namespaces.setPrefix(prefix, name);
 	}
 
 	@Override
 	protected long sizeInternal(Resource... contexts) throws SailException {
 		try {
 			return triples.size(vf.asRdbmsResource(contexts));
 		} catch (SQLException e) {
 			throw new RdbmsException(e);
 		}
 	}
 
 	@Override
 	protected void startTransactionInternal() throws SailException {
 		try {
+			lock();
 			triples.begin();
 		} catch (SQLException e) {
 			throw new RdbmsException(e);
 		}
 	}
-
+	
+	public boolean addInferredStatement(Resource subj, URI pred, Value obj,
+			Resource... contexts) throws SailException {
+		Lock conLock = getSharedConnectionLock();
+		try {
+			verifyIsOpen();
+
+			Lock txnLock = getTransactionLock();
+			try {
+				autoStartTransaction();
+				addStatement(subj, pred, obj, false, contexts);
+			}
+			finally {
+				txnLock.release();
+			}
+		}
+		finally {
+			conLock.release();
+		}
+		return true;
+	}
+
+	public void clearInferred(Resource... contexts) throws SailException {
+		Lock conLock = getSharedConnectionLock();
+		try {
+			verifyIsOpen();
+
+			Lock txnLock = getTransactionLock();
+			try {
+				autoStartTransaction();
+				removeStatements(null, null, null, false, contexts);
+			}
+			finally {
+				txnLock.release();
+			}
+		}
+		finally {
+			conLock.release();
+		}
+	}
+
+	public void flushUpdates() throws SailException {
+		// no-op; changes are reported as soon as they come in
+	}
+
+	public boolean removeInferredStatement(Resource subj, URI pred, Value obj,
+			Resource... contexts) throws SailException {
+		Lock conLock = getSharedConnectionLock();
+		try {
+			verifyIsOpen();
+
+			Lock txnLock = getTransactionLock();
+			try {
+				autoStartTransaction();
+				int removeCount = removeStatements(subj, pred, obj, false, contexts);
+				return removeCount > 0;
+			}
+			finally {
+				txnLock.release();
+			}
+		}
+		finally {
+			conLock.release();
+		}
+	}
+
+	@Override
+	protected void finalize()
+		throws Throwable
+	{
+		unlock();
+		super.finalize();
+	}
+
+	private void lock() {
+		if (lock != null) {
+			lock.lock();
+			locked = true;
+		}
+	}
+
+	private void unlock() {
+		if (locked && lock != null) {
+			locked = false;
+			lock.unlock();
+		}
+	}
 }
Index: trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/RdbmsValueFactory.java
===================================================================
--- trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/RdbmsValueFactory.java (revision 45)
+++ trunk/sesame/core/sail/rdbms/src/main/java/org/openrdf/sail/rdbms/RdbmsValueFactory.java (revision 54)
@@ -1,294 +1,317 @@
 /*
  * Copyright Aduna (http://www.aduna-software.com/) (c) 2008.
  *
  * Licensed under the Aduna BSD-style license.
  */
 package org.openrdf.sail.rdbms;
 
 import java.sql.SQLException;
 import java.util.concurrent.locks.Lock;
 import java.util.concurrent.locks.ReentrantReadWriteLock;
 
 import org.openrdf.model.BNode;
 import org.openrdf.model.Literal;
 import org.openrdf.model.Resource;
 import org.openrdf.model.Statement;
 import org.openrdf.model.URI;
 import org.openrdf.model.Value;
 import org.openrdf.model.ValueFactory;
 import org.openrdf.model.impl.ValueFactoryBase;
 import org.openrdf.sail.rdbms.exceptions.RdbmsException;
 import org.openrdf.sail.rdbms.exceptions.RdbmsRuntimeException;
 import org.openrdf.sail.rdbms.managers.BNodeManager;
 import org.openrdf.sail.rdbms.managers.LiteralManager;
 import org.openrdf.sail.rdbms.managers.PredicateManager;
 import org.openrdf.sail.rdbms.managers.UriManager;
 import org.openrdf.sail.rdbms.model.RdbmsBNode;
 import org.openrdf.sail.rdbms.model.RdbmsLiteral;
 import org.openrdf.sail.rdbms.model.RdbmsResource;
 import org.openrdf.sail.rdbms.model.RdbmsStatement;
 import org.openrdf.sail.rdbms.model.RdbmsURI;
 import org.openrdf.sail.rdbms.model.RdbmsValue;
 import org.openrdf.sail.rdbms.schema.IdSequence;
 import org.openrdf.sail.rdbms.schema.LiteralTable;
 import org.openrdf.sail.rdbms.schema.ValueTable;
 
 /**
  * Provides basic value creation both for traditional values as well as values
  * with an internal id. {@link RdbmsValue}s behaviour similar to the default
  * {@link Value} implementation with the addition that they also include an
  * internal id and a version associated with that id. The internal ids should
  * not be accessed directly, but rather either through this class or the
  * corresponding manager class.
  * 
  * @author James Leigh
  * 
  */
 public class RdbmsValueFactory extends ValueFactoryBase {
 	@Deprecated
 	public static final String NIL_LABEL = "nil";
 	private ValueFactory vf;
 	private BNodeManager bnodes;
 	private UriManager uris;
 	private LiteralManager literals;
 	private PredicateManager predicates;
 	private ReentrantReadWriteLock lock = new ReentrantReadWriteLock();
 	private IdSequence ids;
 
 	public void setIdSequence(IdSequence ids) {
 		this.ids = ids;
 	}
 
 	public void setBNodeManager(BNodeManager bnodes) {
 		this.bnodes = bnodes;
 	}
 
 	public void setURIManager(UriManager uris) {
 		this.uris = uris;
 	}
 
 	public void setLiteralManager(LiteralManager literals) {
 		this.literals = literals;
 	}
 
 	public void setPredicateManager(PredicateManager predicates) {
 		this.predicates = predicates;
 	}
 
 	public void setDelegate(ValueFactory vf) {
 		this.vf = vf;
 	}
 
 	public void flush() throws RdbmsException {
 		try {
 			bnodes.flush();
 			uris.flush();
 			literals.flush();
 		} catch (SQLException e) {
 			throw new RdbmsException(e);
 		}
 		catch (InterruptedException e) {
 			throw new RdbmsException(e);
 		}
 	}
 
 	public RdbmsBNode createBNode(String nodeID) {
 		RdbmsBNode resource = bnodes.findInCache(nodeID);
 		if (resource == null) {
 			try {
 				BNode impl = vf.createBNode(nodeID);
 				resource = new RdbmsBNode(impl);
 				bnodes.cache(resource);
 			} catch (SQLException e) {
 				throw new RdbmsRuntimeException(e);
 			} catch (InterruptedException e) {
 				throw new RdbmsRuntimeException(e);
 			}
 		}
 		return resource;
 	}
 
 	public RdbmsLiteral createLiteral(String label) {
-		return asRdbmsLiteral(vf.createLiteral(label));
+		return asRdbmsLiteral(vf.createLiteral(label), null);
 	}
 
 	public RdbmsLiteral createLiteral(String label, String language) {
 		if (LiteralTable.ONLY_INSERT_LABEL)
 			return createLiteral(label);
-		return asRdbmsLiteral(vf.createLiteral(label, language));
+		return asRdbmsLiteral(vf.createLiteral(label, language), null);
 	}
 
 	public RdbmsLiteral createLiteral(String label, URI datatype) {
 		if (LiteralTable.ONLY_INSERT_LABEL)
 			return createLiteral(label);
-		return asRdbmsLiteral(vf.createLiteral(label, datatype));
-	}
+		return asRdbmsLiteral(vf.createLiteral(label, datatype), null);
+	}
+	
+	public RdbmsLiteral createLiteral(String label, URI datatype, URI predicate) {
+		if (LiteralTable.ONLY_INSERT_LABEL)
+			return createLiteral(label);
+		return asRdbmsLiteral(vf.createLiteral(label, datatype), predicate);
+	}	
 
 	public RdbmsStatement createStatement(Resource subject, URI predicate,
+			Value object, boolean explicit) {
+		return createStatement(subject, predicate, object, explicit, null);
+	}
+	
+	public Statement createStatement(Resource subject, URI predicate,
 			Value object) {
-		return createStatement(subject, predicate, object, null);
-	}
+		return createStatement(subject, predicate, object, true, null);
+	}
+
+	public Statement createStatement(Resource subject, URI predicate,
+			Value object, Resource context) {
+		return createStatement(subject, predicate, object, true, context);
+	}	
 
 	public RdbmsStatement createStatement(Resource subject, URI predicate,
-			Value object, Resource context) {
+			Value object, boolean explicit, Resource context) {
 		RdbmsResource subj = asRdbmsResource(subject);
 		RdbmsURI pred = asRdbmsURI(predicate);
-		RdbmsValue obj = asRdbmsValue(object);
+		RdbmsValue obj = asRdbmsValue(object, predicate);
 		RdbmsResource ctx = asRdbmsResource(context);
-		return new RdbmsStatement(subj, pred, obj, ctx);
+		return new RdbmsStatement(subj, pred, obj, explicit, ctx);
 	}
 
 	public RdbmsURI createURI(String uri) {
 		RdbmsURI resource = uris.findInCache(uri);
 		if (resource == null) {
 			try {
 				URI impl = vf.createURI(uri);
 				resource = new RdbmsURI(impl);
 				uris.cache(resource);
 			} catch (SQLException e) {
 				throw new RdbmsRuntimeException(e);
 			} catch (InterruptedException e) {
 				throw new RdbmsRuntimeException(e);
 			}
 		}
 		return resource;
 	}
 
 	public RdbmsURI createURI(String namespace, String localName) {
 		return createURI(namespace + localName);
 	}
 
 	public RdbmsResource getRdbmsResource(Number num, String stringValue) {
 		Number id = ids.idOf(num);
 		if (ids.isURI(id))
 			return new RdbmsURI(id, uris.getIdVersion(), vf.createURI(stringValue));
 		return new RdbmsBNode(id, bnodes.getIdVersion(), vf.createBNode(stringValue));
 	}
 
 	public RdbmsLiteral getRdbmsLiteral(Number num, String label, String language,
 			String datatype) {
 		Number id = ids.idOf(num);
 		if (datatype == null && language == null)
-			return new RdbmsLiteral(id, literals.getIdVersion(), vf.createLiteral(label));
+			return new RdbmsLiteral(id, literals.getIdVersion(), vf.createLiteral(label), null);
 		if (datatype == null)
-			return new RdbmsLiteral(id, literals.getIdVersion(), vf.createLiteral(label, language));
-		return new RdbmsLiteral(id, literals.getIdVersion(), vf.createLiteral(label, vf.createURI(datatype)));
+			return new RdbmsLiteral(id, literals.getIdVersion(), vf.createLiteral(label, language), null);
+		return new RdbmsLiteral(id, literals.getIdVersion(), vf.createLiteral(label, vf.createURI(datatype)), null);
 	}
 
 	public RdbmsResource asRdbmsResource(Resource node) {
 		if (node == null)
 			return null;
 		if (node instanceof URI)
 			return asRdbmsURI((URI) node);
 		if (node instanceof RdbmsBNode) {
 			try {
 				bnodes.cache((RdbmsBNode) node);
 				return (RdbmsBNode) node;
 			} catch (SQLException e) {
 				throw new RdbmsRuntimeException(e);
 			} catch (InterruptedException e) {
 				throw new RdbmsRuntimeException(e);
 			}
 		}
 		return createBNode(((BNode) node).getID());
 	}
 
 	public RdbmsURI asRdbmsURI(URI uri) {
 		if (uri == null)
 			return null;
 		if (uri instanceof RdbmsURI) {
 			try {
 				uris.cache((RdbmsURI) uri);
 				return (RdbmsURI) uri;
 			} catch (SQLException e) {
 				throw new RdbmsRuntimeException(e);
 			} catch (InterruptedException e) {
 				throw new RdbmsRuntimeException(e);
 			}
 		}
 		return createURI(uri.stringValue());
 	}
 
-	public RdbmsValue asRdbmsValue(Value value) {
+	public RdbmsValue asRdbmsValue(Value value, URI predicate) {
 		if (value == null)
 			return null;
 		if (value instanceof Literal)
-			return asRdbmsLiteral((Literal) value);
+			return asRdbmsLiteral((Literal) value, predicate);
 		return asRdbmsResource((Resource) value);
 	}
 
-	public RdbmsLiteral asRdbmsLiteral(Literal literal) {
+	public RdbmsLiteral asRdbmsLiteral(Literal literal, URI predicate) {
 		try {
 			if (literal instanceof RdbmsLiteral) {
 				literals.cache((RdbmsLiteral) literal);
+				((RdbmsLiteral)literal).setPredicate(predicate);
 				return (RdbmsLiteral) literal;
 			}
 			RdbmsLiteral lit = literals.findInCache(literal);
 			if (lit == null) {
-				lit = new RdbmsLiteral(literal);
+				lit = new RdbmsLiteral(literal, predicate);
 				literals.cache(lit);
 			}
 			return lit;
 		} catch (SQLException e) {
 			throw new RdbmsRuntimeException(e);
 		} catch (InterruptedException e) {
 			throw new RdbmsRuntimeException(e);
 		}
 	}
 
 	public RdbmsResource[] asRdbmsResource(Resource... contexts) {
 		RdbmsResource[] ctxs = new RdbmsResource[contexts.length];
 		for (int i = 0; i < ctxs.length; i++) {
 			ctxs[i] = asRdbmsResource(contexts[i]);
 		}
 		return ctxs;
 	}
 
-	public RdbmsStatement asRdbmsStatement(Statement stmt) {
+	public RdbmsStatement asRdbmsStatement(Statement stmt, boolean explicit) {
 		if (stmt instanceof RdbmsStatement)
 			return (RdbmsStatement) stmt;
 		Resource s = stmt.getSubject();
 		URI p = stmt.getPredicate();
 		Value o = stmt.getObject();
 		Resource c = stmt.getContext();
-		return createStatement(s, p, o, c);
+		return createStatement(s, p, o, explicit, c);
 	}
 
 	public Number getInternalId(Value r)
+	throws RdbmsException
+	{
+		return getInternalId(r, null);
+	}
+
+	public Number getInternalId(Value r, URI predicate)
 		throws RdbmsException
 	{
 		try {
 			if (r == null)
 				return ValueTable.NIL_ID;
-			RdbmsValue value = asRdbmsValue(r);
+			RdbmsValue value = asRdbmsValue(r, predicate);
 			if (value instanceof RdbmsURI)
 				return uris.getInternalId((RdbmsURI)value);
 			if (value instanceof RdbmsBNode)
 				return bnodes.getInternalId((RdbmsBNode)value);
 			return literals.getInternalId((RdbmsLiteral)value);
 		}
 		catch (SQLException e) {
 			throw new RdbmsException(e);
 		} catch (InterruptedException e) {
 			throw new RdbmsRuntimeException(e);
 		}
 	}
 
 	public Number getPredicateId(RdbmsURI predicate) throws RdbmsException {
 		try {
 			return predicates.getIdOfPredicate(predicate);
 		} catch (SQLException e) {
 			throw new RdbmsException(e);
 		} catch (InterruptedException e) {
 			throw new RdbmsRuntimeException(e);
 		}
 	}
 
 	public Lock getIdReadLock() {
 		return lock.readLock();
 	}
 
 	public Lock getIdWriteLock() {
 		return lock.writeLock();
 	}
 }
Index: trunk/sesame/core/sail/rdbms/pom.xml
===================================================================
--- trunk/sesame/core/sail/rdbms/pom.xml (revision 45)
+++ trunk/sesame/core/sail/rdbms/pom.xml (revision 47)
@@ -1,83 +1,88 @@
 <project xmlns="http://maven.apache.org/POM/4.0.0"
 	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
 	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
 
 	<modelVersion>4.0.0</modelVersion>
 
 	<parent>
 		<groupId>org.openrdf.sesame</groupId>
 		<artifactId>sesame-sail</artifactId>
 		<version>2.1-SNAPSHOT</version>
 	</parent>
 
 	<artifactId>sesame-sail-rdbms</artifactId>
 
 	<name>OpenRDF Sesame: RDBMS Sail</name>
 	<description>Sail implementation that stores data in a relational database.</description>
 
 	<dependencies>
 		<dependency>
 			<groupId>${project.groupId}</groupId>
 			<artifactId>sesame-sail-api</artifactId>
 		</dependency>
+
+                <dependency>
+                        <groupId>${project.groupId}</groupId>
+                        <artifactId>sesame-sail-inferencer</artifactId>
+                </dependency>
 
 		<dependency>
 			<groupId>${project.groupId}</groupId>
 			<artifactId>sesame-queryalgebra-evaluation</artifactId>
 		</dependency>
 		<dependency>
 			<groupId>${project.groupId}</groupId>
 			<artifactId>sesame-queryalgebra-model</artifactId>
 		</dependency>
 		<dependency>
 			<groupId>${project.groupId}</groupId>
 			<artifactId>sesame-query</artifactId>
 		</dependency>
 
 		<dependency>
 			<groupId>${project.groupId}</groupId>
 			<artifactId>sesame-model</artifactId>
 		</dependency>
 
 		<dependency>
 			<groupId>info.aduna.commons</groupId>
 			<artifactId>aduna-commons-collections</artifactId>
 		</dependency>
 
 		<dependency>
 			<groupId>org.slf4j</groupId>
 			<artifactId>slf4j-api</artifactId>
 		</dependency>
 
 		<dependency>
 			<groupId>commons-dbcp</groupId>
 			<artifactId>commons-dbcp</artifactId>
 		</dependency>
 
 		<dependency>
 			<groupId>junit</groupId>
 			<artifactId>junit</artifactId>
 		</dependency>
 
 		<dependency>
 			<groupId>postgresql</groupId>
 			<artifactId>postgresql</artifactId>
 			<version>8.2-507.jdbc3</version>
 			<scope>provided</scope>
 		</dependency>
 
 		<dependency>
 			<groupId>mysql</groupId>
 			<artifactId>mysql-connector-java</artifactId>
 			<version>5.1.5</version>
 			<scope>provided</scope>
 		</dependency>
 	</dependencies>
 
 	<scm>
 		<connection>scm:svn:https://repo.aduna-software.org/svn/org.openrdf/sesame/trunk/core/sail/rdbms</connection>
 		<developerConnection>scm:svn:https://repo.aduna-software.org/svn/org.openrdf/sesame/trunk/core/sail/rdbms</developerConnection>
 		<url>http://repo.aduna-software.org/viewvc/org.openrdf/sesame/trunk/core/sail/rdbms</url>
 	</scm>
 
 </project>
Index: trunk/sesame/core/pom.xml
===================================================================
--- trunk/sesame/core/pom.xml (revision 45)
+++ trunk/sesame/core/pom.xml (revision 48)
@@ -1,137 +1,138 @@
 <project xmlns="http://maven.apache.org/POM/4.0.0"
 	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
 	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
 
 	<modelVersion>4.0.0</modelVersion>
 
 	<parent>
 		<groupId>org.openrdf.sesame</groupId>
 		<artifactId>sesame</artifactId>
 		<version>2.1-SNAPSHOT</version>
+		<relativePath>../../pom.xml</relativePath>
 	</parent>
 
 	<artifactId>sesame-core</artifactId>
 	<packaging>pom</packaging>
 
 	<modules>
 		<module>console</module>
-		<module>http</module>
+		<!--<module>http</module>-->
 		<module>model</module>
 		<module>query</module>
 		<module>queryalgebra</module>
 		<module>queryparser</module>
 		<module>queryresultio</module>
 		<module>repository</module>
 		<module>rio</module>
 		<module>runtime</module>
 		<module>sail</module>
 	</modules>
 
 	<name>OpenRDF Sesame Core</name>
 	<description>Core modules for OpenRDF Sesame</description>
 
 	<build>
 		<plugins>
 			<plugin>
 				<artifactId>maven-assembly-plugin</artifactId>
 				<inherited>false</inherited>
 				<configuration>
 					<finalName>openrdf-sesame-${project.version}</finalName>
 					<descriptors>
 						<descriptor>src/main/assembly/onejar.xml</descriptor>
-						<descriptor>src/main/assembly/sdk.xml</descriptor>
+						<!--<descriptor>src/main/assembly/sdk.xml</descriptor>-->
 					</descriptors>
 				</configuration>
 			</plugin>
 			<plugin>
 				<groupId>org.apache.maven.plugins</groupId>
 				<artifactId>maven-antrun-plugin</artifactId>
 				<inherited>false</inherited>
 				<executions>
 					<execution>
 						<phase>site</phase>
 						<configuration>
 							<tasks>
 								<ant antfile="${basedir}/src/main/doc/build.xml" inheritRefs="true">
 									<target name="userdoc"/>
 								</ant>
 								<ant antfile="${basedir}/src/main/doc/build.xml" inheritRefs="true">
 									<target name="systemdoc"/>
 								</ant>
 							</tasks>
 						</configuration>
 						<goals>
 							<goal>run</goal>
 						</goals>
 					</execution>
 				</executions>
 				<dependencies>
 					<dependency>
 						<groupId>saxon</groupId>
 						<artifactId>saxon</artifactId>
 						<version>6.5.3</version>
 					</dependency>
 				</dependencies>
 			</plugin>
 		</plugins>
 	</build>
 
 	<reporting>
 		<plugins>
 			<plugin>
 				<groupId>org.apache.maven.plugins</groupId>
 				<artifactId>maven-javadoc-plugin</artifactId>
 				<configuration>
 					<aggregate>true</aggregate>
 					<source>1.5</source>
 					<destDir>../docs/apidocs</destDir>
 					<groups>
 						<group>
 							<title>Repository API</title>
 							<packages>org.openrdf.repository*</packages>
 						</group>
 						<group>
 							<title>RDF Model API</title>
 							<packages>org.openrdf.model*</packages>
 						</group>
 						<group>
 							<title>Storage And Inference Layer (SAIL) API</title>
 							<packages>org.openrdf.sail*</packages>
 						</group>
 						<group>
 							<title>RDF Parsers and Writers (Rio) </title>
 							<packages>org.openrdf.rio*</packages>
 						</group>
 						<group>
 							<title>Query API and query engines</title>
 							<packages>org.openrdf.query:org.openrdf.query.impl:org.openrdf.query.algebra*:org.openrdf.query.parser*</packages>
 						</group>
 						<group>
 							<title>Query Result Parsers and Writers</title>
 							<packages>org.openrdf.query.resultio*</packages>
 						</group>
 						<group>
 							<title>OpenRDF Web Client</title>
 							<packages>org.openrdf.http.webclient*</packages>
 						</group>
 						<group>
 							<title>HTTP Protocol for Client/Server Communication</title>
 							<packages>org.openrdf.http*</packages>
 						</group>
 					</groups>
 					<links>
 						<link>http://java.sun.com/j2se/1.5.0/docs/api/</link>
 						<link>http://repository.aduna-software.org/docs/info.aduna/api/</link>
 					</links>
 				</configuration>
 			</plugin>
 		</plugins>
 	</reporting>
 
 	<scm>
 		<connection>scm:svn:https://repo.aduna-software.org/svn/org.openrdf/sesame/trunk/core</connection>
 		<developerConnection>scm:svn:https://repo.aduna-software.org/svn/org.openrdf/sesame/trunk/core</developerConnection>
 		<url>http://repo.aduna-software.org/viewvc/org.openrdf/sesame/trunk/core</url>
 	</scm>
 
 </project>
Index: trunk/sesame/core/.classpath
===================================================================
--- trunk/sesame/core/.classpath (revision 162)
+++ trunk/sesame/core/.classpath (revision 162)
@@ -0,0 +1,91 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="console/src/main/java"/>
+	<classpathentry kind="src" path="http/client/src/main/java"/>
+	<classpathentry kind="src" path="http/protocol/src/main/java"/>
+	<classpathentry kind="src" path="http/protocol/src/test/java"/>
+	<classpathentry kind="src" path="http/server-spring/src/main/java"/>
+	<classpathentry kind="src" path="http/server/src/test/java"/>
+	<classpathentry kind="src" path="http/webclient-spring/src/main/java"/>
+	<classpathentry kind="src" path="http/webclient/src/test/java"/>
+	<classpathentry kind="src" path="model/src/main/java"/>
+	<classpathentry kind="src" path="model/src/test/java"/>
+	<classpathentry kind="src" path="query/src/main/java"/>
+	<classpathentry kind="src" path="queryalgebra/evaluation/src/main/java"/>
+	<classpathentry kind="src" path="queryalgebra/evaluation/src/test/java"/>
+	<classpathentry kind="src" path="queryalgebra/model/src/main/java"/>
+	<classpathentry kind="src" path="queryparser/api/src/main/java"/>
+	<classpathentry kind="src" path="queryparser/serql/src/main/java"/>
+	<classpathentry kind="src" path="queryparser/sparql/src/main/java"/>
+	<classpathentry kind="src" path="queryresultio/api/src/main/java"/>
+	<classpathentry kind="src" path="queryresultio/binary/src/main/java"/>
+	<classpathentry kind="src" path="queryresultio/sparqljson/src/main/java"/>
+	<classpathentry kind="src" path="queryresultio/sparqlxml/src/main/java"/>
+	<classpathentry kind="src" path="queryresultio/text/src/main/java"/>
+	<classpathentry kind="src" path="repository/api/src/main/java"/>
+	<classpathentry kind="src" path="repository/dataset/src/main/java"/>
+	<classpathentry kind="src" path="repository/event/src/main/java"/>
+	<classpathentry kind="src" path="repository/http/src/main/java"/>
+	<classpathentry kind="src" path="repository/manager/src/main/java"/>
+	<classpathentry kind="src" path="repository/sail/src/main/java"/>
+	<classpathentry kind="src" path="rio/api/src/main/java"/>
+	<classpathentry kind="src" path="rio/n3/src/main/java"/>
+	<classpathentry kind="src" path="rio/ntriples/src/main/java"/>
+	<classpathentry kind="src" path="rio/rdfxml/src/main/java"/>
+	<classpathentry kind="src" path="rio/trig/src/main/java"/>
+	<classpathentry kind="src" path="rio/trix/src/main/java"/>
+	<classpathentry kind="src" path="rio/turtle/src/main/java"/>
+	<classpathentry kind="src" path="runtime/src/main/java"/>
+	<classpathentry kind="src" path="sail/api/src/main/java"/>
+	<classpathentry kind="src" path="sail/inferencer/src/main/java"/>
+	<classpathentry kind="src" path="sail/memory/src/main/java"/>
+	<classpathentry kind="src" path="sail/memory/src/test/java"/>
+	<classpathentry kind="src" path="sail/nativerdf/src/main/java"/>
+	<classpathentry kind="src" path="sail/nativerdf/src/test/java"/>
+	<classpathentry kind="src" path="sail/rdbms/src/main/java"/>
+	<classpathentry kind="src" path="sail/rdbms/src/test/java"/>
+	<classpathentry kind="lib" path="src/main/doc/src/docbook-xsl-1.68.1/extensions/saxon653.jar"/>
+	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER"/>
+	<classpathentry kind="lib" path="/Users/Christian/Sites/DBpediaMobile/Marbles/web/WEB-INF/lib/antlr-2.7.7.jar"/>
+	<classpathentry kind="lib" path="/Users/Christian/Sites/DBpediaMobile/Marbles/web/WEB-INF/lib/commons-codec-1.3.jar"/>
+	<classpathentry kind="lib" path="/Users/Christian/Sites/DBpediaMobile/Marbles/web/WEB-INF/lib/commons-collections-3.0.jar"/>
+	<classpathentry kind="lib" path="/Users/Christian/Sites/DBpediaMobile/Marbles/web/WEB-INF/lib/commons-dbcp-1.2.2.jar" sourcepath="/Users/Christian/Sites/DBpediaMobile/Marbles/web/WEB-INF/lib/commons-dbcp-1.2.2-src.zip"/>
+	<classpathentry kind="lib" path="/Users/Christian/Sites/DBpediaMobile/Marbles/web/WEB-INF/lib/commons-httpclient-3.1.jar"/>
+	<classpathentry kind="lib" path="/Users/Christian/Sites/DBpediaMobile/Marbles/web/WEB-INF/lib/commons-lang-2.3.jar"/>
+	<classpathentry kind="lib" path="/Users/Christian/Sites/DBpediaMobile/Marbles/web/WEB-INF/lib/commons-logging-1.1.1-javadoc.jar"/>
+	<classpathentry kind="lib" path="/Users/Christian/Sites/DBpediaMobile/Marbles/web/WEB-INF/lib/commons-logging-1.1.1-sources.jar"/>
+	<classpathentry kind="lib" path="/Users/Christian/Sites/DBpediaMobile/Marbles/web/WEB-INF/lib/commons-logging-1.1.1.jar"/>
+	<classpathentry kind="lib" path="/Users/Christian/Sites/DBpediaMobile/Marbles/web/WEB-INF/lib/commons-logging-adapters-1.1.1.jar"/>
+	<classpathentry kind="lib" path="/Users/Christian/Sites/DBpediaMobile/Marbles/web/WEB-INF/lib/commons-logging-api-1.1.1.jar"/>
+	<classpathentry kind="lib" path="/Users/Christian/Sites/DBpediaMobile/Marbles/web/WEB-INF/lib/commons-logging-tests.jar"/>
+	<classpathentry kind="lib" path="/Users/Christian/Sites/DBpediaMobile/Marbles/web/WEB-INF/lib/commons-pool-1.3.jar"/>
+	<classpathentry kind="lib" path="/Users/Christian/Sites/DBpediaMobile/Marbles/web/WEB-INF/lib/junit-3.8.1.jar"/>
+	<classpathentry kind="lib" path="/Users/Christian/Sites/DBpediaMobile/Marbles/web/WEB-INF/lib/junit-4.1.jar"/>
+	<classpathentry kind="lib" path="/Users/Christian/Sites/DBpediaMobile/Marbles/web/WEB-INF/lib/log4j-1.2.13.jar"/>
+	<classpathentry kind="lib" path="/Users/Christian/Sites/DBpediaMobile/Marbles/web/WEB-INF/lib/mysql-connector-java-5.0.7-bin.jar"/>
+	<classpathentry kind="lib" path="/Users/Christian/Sites/DBpediaMobile/Marbles/web/WEB-INF/lib/saxon8-ant.jar"/>
+	<classpathentry kind="lib" path="/Users/Christian/Sites/DBpediaMobile/Marbles/web/WEB-INF/lib/saxon8-dom.jar"/>
+	<classpathentry kind="lib" path="/Users/Christian/Sites/DBpediaMobile/Marbles/web/WEB-INF/lib/saxon8-dom4j.jar"/>
+	<classpathentry kind="lib" path="/Users/Christian/Sites/DBpediaMobile/Marbles/web/WEB-INF/lib/saxon8-jdom.jar"/>
+	<classpathentry kind="lib" path="/Users/Christian/Sites/DBpediaMobile/Marbles/web/WEB-INF/lib/saxon8-sql.jar"/>
+	<classpathentry kind="lib" path="/Users/Christian/Sites/DBpediaMobile/Marbles/web/WEB-INF/lib/saxon8-xom.jar"/>
+	<classpathentry kind="lib" path="/Users/Christian/Sites/DBpediaMobile/Marbles/web/WEB-INF/lib/saxon8-xpath.jar"/>
+	<classpathentry kind="lib" path="/Users/Christian/Sites/DBpediaMobile/Marbles/web/WEB-INF/lib/saxon8-xqj.jar"/>
+	<classpathentry kind="lib" path="/Users/Christian/Sites/DBpediaMobile/Marbles/web/WEB-INF/lib/saxon8.jar"/>
+	<classpathentry kind="lib" path="/Users/Christian/Sites/DBpediaMobile/Marbles/web/WEB-INF/lib/slf4j-api-1.3.0.jar"/>
+	<classpathentry kind="lib" path="/Users/Christian/Sites/DBpediaMobile/Marbles/web/WEB-INF/lib/slf4j-log4j12-1.0.1.jar"/>
+	<classpathentry kind="lib" path="/Users/Christian/Sites/DBpediaMobile/Marbles/web/WEB-INF/lib/Tidy.jar"/>
+	<classpathentry kind="lib" path="/Users/Christian/Sites/DBpediaMobile/Marbles/web/WEB-INF/lib/velocity-1.4.jar"/>
+	<classpathentry kind="lib" path="/Users/Christian/Sites/DBpediaMobile/Marbles/web/WEB-INF/lib/xercesImpl.jar"/>
+	<classpathentry kind="lib" path="/Users/Christian/Sites/DBpediaMobile/Marbles/web/WEB-INF/lib/xml-apis.jar"/>
+	<classpathentry kind="lib" path="/Users/Christian/Sites/DBpediaMobile/Marbles/web/WEB-INF/lib/zvtm.jar"/>
+	<classpathentry kind="lib" path="/Users/Christian/Sites/DBpediaMobile/Marbles/web/WEB-INF/lib/aduna-collections-1.4.jar"/>
+	<classpathentry kind="lib" path="/Users/Christian/Sites/DBpediaMobile/Marbles/web/WEB-INF/lib/aduna-concurrent-1.4.jar"/>
+	<classpathentry kind="lib" path="/Users/Christian/Sites/DBpediaMobile/Marbles/web/WEB-INF/lib/aduna-io-1.3.jar"/>
+	<classpathentry kind="lib" path="/Users/Christian/Sites/DBpediaMobile/Marbles/web/WEB-INF/lib/aduna-iteration-1.5.jar"/>
+	<classpathentry kind="lib" path="/Users/Christian/Sites/DBpediaMobile/Marbles/web/WEB-INF/lib/aduna-lang-1.4.jar"/>
+	<classpathentry kind="lib" path="/Users/Christian/Sites/DBpediaMobile/Marbles/web/WEB-INF/lib/aduna-net-1.5.jar"/>
+	<classpathentry kind="lib" path="/Users/Christian/Sites/DBpediaMobile/Marbles/web/WEB-INF/lib/aduna-text-1.3.jar"/>
+	<classpathentry kind="lib" path="/Users/Christian/Sites/DBpediaMobile/Marbles/web/WEB-INF/lib/aduna-xml-1.5.jar"/>
+	<classpathentry kind="output" path="bin"/>
+</classpath>
Index: trunk/sesame/core/build.sh
===================================================================
--- trunk/sesame/core/build.sh (revision 76)
+++ trunk/sesame/core/build.sh (revision 76)
@@ -0,0 +1,9 @@
+#mvn -Dmaven.test.skip=true package assembly:directory source:aggregate
+mvn -Dmaven.test.skip=true package assembly:directory
+cd target
+cp ~/Desktop/Diplomarbeit/sesame-2.0/META-INF/services/* openrdf-sesame-2.1-SNAPSHOT-onejar.dir/META-INF/services/
+cd openrdf-sesame-2.1-SNAPSHOT-onejar.dir 
+jar cmf META-INF/MANIFEST.MF ../openrdf-sesame-2.1-SNAPSHOT-onejar.jar *
+cd ../..
+cp target/openrdf-sesame-2.1-SNAPSHOT-onejar.jar ../../Marbles/web/WEB-INF/lib/
+cp target/openrdf-sesame-2.1-SNAPSHOT-onejar.jar ../../SesameTool/lib/ 
Index: trunk/sesame/org.openrdf.pom.xml
===================================================================
--- trunk/sesame/org.openrdf.pom.xml (revision 49)
+++ trunk/sesame/org.openrdf.pom.xml (revision 49)
@@ -0,0 +1,22 @@
+<project xmlns="http://maven.apache.org/POM/4.0.0"
+         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
+                             http://maven.apache.org/maven-v4_0_0.xsd">
+
+	<modelVersion>4.0.0</modelVersion>
+
+	<parent>
+		<groupId>org.aduna-software</groupId>
+		<artifactId>aduna-opensource-root-pom</artifactId>
+		<version>1</version>
+	</parent>
+
+	<groupId>org.openrdf</groupId>
+	<artifactId>openrdf-root-pom</artifactId>
+	<version>1</version>
+	<packaging>pom</packaging>
+
+	<name>OpenRDF</name>
+	<description>OpenRDF project</description>
+	<url>http://www.openrdf.org/</url>
+</project>
