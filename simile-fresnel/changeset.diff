Index: trunk/simile-fresnel/build-vocabs.sh
===================================================================
--- trunk/simile-fresnel/build-vocabs.sh (revision 19)
+++ trunk/simile-fresnel/build-vocabs.sh (revision 19)
@@ -0,0 +1,1 @@
+mvn -f bootstrap.xml generate-sources
Index: trunk/simile-fresnel/.project
===================================================================
--- trunk/simile-fresnel/.project (revision 19)
+++ trunk/simile-fresnel/.project (revision 19)
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>simile-fresnel</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+</projectDescription>
Index: trunk/simile-fresnel/src/main/java/MANIFEST.MF
===================================================================
--- trunk/simile-fresnel/src/main/java/MANIFEST.MF (revision 3)
+++ trunk/simile-fresnel/src/main/java/MANIFEST.MF (revision 3)
@@ -0,0 +1,3 @@
+Manifest-Version: 1.0
+Class-Path: 
+
Index: trunk/simile-fresnel/src/main/java/edu/mit/simile/vocabularies/FresnelExtended.java
===================================================================
--- trunk/simile-fresnel/src/main/java/edu/mit/simile/vocabularies/FresnelExtended.java (revision 19)
+++ trunk/simile-fresnel/src/main/java/edu/mit/simile/vocabularies/FresnelExtended.java (revision 19)
@@ -0,0 +1,119 @@
+/* CVS $Id: $ */
+package edu.mit.simile.vocabularies; 
+import org.openrdf.model.*;
+import org.openrdf.model.impl.*;
+import org.openrdf.repository.*;
+import org.openrdf.repository.sail.*;
+import org.openrdf.sail.memory.MemoryStore;
+ 
+/**
+ * Vocabulary definitions from file:./ontologies/extended.owl 
+ * @author Auto-generated by schemagen on 07 Mar 2008 21:56 
+ */
+public class FresnelExtended {
+    /** <p>The RDF model that holds the vocabulary terms</p> */
+    private static Repository m_model;
+    static {
+    	try {
+    			m_model = new SailRepository(new MemoryStore());
+    			m_model.initialize();
+    		} catch (RepositoryException e) {
+    			System.err.println("Failed to initialize");
+    		}
+    }
+    
+    /** <p>The namespace of the vocabulary as a string</p> */
+    public static final String NS = "http://www.w3.org/2004/09/fresnel#";
+    
+    /** <p>The namespace of the vocabulary as a string</p>
+     *  @see #NS */
+    public static String getURI() {return NS;}
+    
+    /** <p>The namespace of the vocabulary as a resource</p> */
+    public static final Resource NAMESPACE = m_model.getValueFactory().createURI( NS );
+    
+    /** <p></p> */
+    public static final URI alternateProperties = m_model.getValueFactory().createURI( "http://www.w3.org/2004/09/fresnel#alternateProperties" );
+    
+    /** <p></p> */
+    public static final URI mergeProperties = m_model.getValueFactory().createURI( "http://www.w3.org/2004/09/fresnel#mergeProperties" );
+    
+    /** <p></p> */
+    public static final URI moreDetailsFor = m_model.getValueFactory().createURI( "http://www.w3.org/2004/09/fresnel#moreDetailsFor" );
+    
+    /** <p></p> */
+    public static final URI stylesheetLink = m_model.getValueFactory().createURI( "http://www.w3.org/2004/09/fresnel#stylesheetLink" );
+    
+    /** <p></p> */
+    public static final URI active = m_model.getValueFactory().createURI( "http://www.w3.org/2004/09/fresnel#active" );
+    
+    /** <p></p> */
+    public static final URI contentReplace = m_model.getValueFactory().createURI( "http://www.w3.org/2004/09/fresnel#contentReplace" );
+    
+    /** <p></p> */
+    public static final URI firstLetter = m_model.getValueFactory().createURI( "http://www.w3.org/2004/09/fresnel#firstLetter" );
+    
+    /** <p></p> */
+    public static final URI focus = m_model.getValueFactory().createURI( "http://www.w3.org/2004/09/fresnel#focus" );
+    
+    /** <p></p> */
+    public static final URI hover = m_model.getValueFactory().createURI( "http://www.w3.org/2004/09/fresnel#hover" );
+    
+    /** <p></p> */
+    public static final URI link = m_model.getValueFactory().createURI( "http://www.w3.org/2004/09/fresnel#link" );
+    
+    /** <p></p> */
+    public static final URI visited = m_model.getValueFactory().createURI( "http://www.w3.org/2004/09/fresnel#visited" );
+    
+    /** <p></p> */
+    public static final URI containerStyle = m_model.getValueFactory().createURI( "http://www.w3.org/2004/09/fresnel#containerStyle" );
+    
+    /** <p></p> */
+    public static final URI displayAs = m_model.getValueFactory().createURI( "http://www.w3.org/2004/09/fresnel#displayAs" );
+    
+    /** <p></p> */
+    public static final Resource PropertyDescription = m_model.getValueFactory().createURI( "http://www.w3.org/2004/09/fresnel#PropertyDescription" );
+    
+    /** <p></p> */
+    public static final Resource animation = m_model.getValueFactory().createURI( "http://www.w3.org/2004/09/fresnel#animation" );
+    
+    /** <p></p> */
+    public static final Resource audio = m_model.getValueFactory().createURI( "http://www.w3.org/2004/09/fresnel#audio" );
+    
+    /** <p></p> */
+    public static final Resource fslSelector = m_model.getValueFactory().createURI( "http://www.w3.org/2004/09/fresnel#fslSelector" );
+    
+    /** <p></p> */
+    public static final Resource html = m_model.getValueFactory().createURI( "http://www.w3.org/2004/09/fresnel#html" );
+    
+    /** <p></p> */
+    public static final Resource labelOfParent = m_model.getValueFactory().createURI( "http://www.w3.org/2004/09/fresnel#labelOfParent" );
+    
+    /** <p></p> */
+    public static final Resource print = m_model.getValueFactory().createURI( "http://www.w3.org/2004/09/fresnel#print" );
+    
+    /** <p></p> */
+    public static final Resource projection = m_model.getValueFactory().createURI( "http://www.w3.org/2004/09/fresnel#projection" );
+    
+    /** <p></p> */
+    public static final Resource screen = m_model.getValueFactory().createURI( "http://www.w3.org/2004/09/fresnel#screen" );
+    
+    /** <p></p> */
+    public static final Resource sparqlSelector = m_model.getValueFactory().createURI( "http://www.w3.org/2004/09/fresnel#sparqlSelector" );
+    
+    /** <p></p> */
+    public static final Resource styleClass = m_model.getValueFactory().createURI( "http://www.w3.org/2004/09/fresnel#styleClass" );
+    
+    /** <p></p> */
+    public static final Resource stylingInstructions = m_model.getValueFactory().createURI( "http://www.w3.org/2004/09/fresnel#stylingInstructions" );
+    
+    /** <p></p> */
+    public static final Resource text = m_model.getValueFactory().createURI( "http://www.w3.org/2004/09/fresnel#text" );
+    
+    /** <p></p> */
+    public static final Resource textstream = m_model.getValueFactory().createURI( "http://www.w3.org/2004/09/fresnel#textstream" );
+    
+    /** <p></p> */
+    public static final Resource video = m_model.getValueFactory().createURI( "http://www.w3.org/2004/09/fresnel#video" );
+    
+}
Index: trunk/simile-fresnel/src/main/java/edu/mit/simile/vocabularies/Namespaces.java
===================================================================
--- trunk/simile-fresnel/src/main/java/edu/mit/simile/vocabularies/Namespaces.java (revision 19)
+++ trunk/simile-fresnel/src/main/java/edu/mit/simile/vocabularies/Namespaces.java (revision 19)
@@ -0,0 +1,41 @@
+/* CVS $Id: $ */
+package edu.mit.simile.vocabularies; 
+import org.openrdf.model.*;
+import org.openrdf.model.impl.*;
+import org.openrdf.repository.*;
+import org.openrdf.repository.sail.*;
+import org.openrdf.sail.memory.MemoryStore;
+ 
+/**
+ * Vocabulary definitions from file:./ontologies/namespaces.owl 
+ * @author Auto-generated by schemagen on 07 Mar 2008 21:56 
+ */
+public class Namespaces {
+    /** <p>The RDF model that holds the vocabulary terms</p> */
+    private static Repository m_model;
+    static {
+    	try {
+    			m_model = new SailRepository(new MemoryStore());
+    			m_model.initialize();
+    		} catch (RepositoryException e) {
+    			System.err.println("Failed to initialize");
+    		}
+    }
+    
+    /** <p>The namespace of the vocabulary as a string</p> */
+    public static final String NS = "http://simile.mit.edu/2006/01/ontologies/fsl-ns#";
+    
+    /** <p>The namespace of the vocabulary as a string</p>
+     *  @see #NS */
+    public static String getURI() {return NS;}
+    
+    /** <p>The namespace of the vocabulary as a resource</p> */
+    public static final Resource NAMESPACE = m_model.getValueFactory().createURI( NS );
+    
+    /** <p></p> */
+    public static final URI abbreviated = m_model.getValueFactory().createURI( "http://simile.mit.edu/2006/01/ontologies/fsl-ns#abbreviated" );
+    
+    /** <p></p> */
+    public static final Resource Namespace = m_model.getValueFactory().createURI( "http://simile.mit.edu/2006/01/ontologies/fsl-ns#Namespace" );
+    
+}
Index: trunk/simile-fresnel/src/main/java/edu/mit/simile/vocabularies/Facets.java
===================================================================
--- trunk/simile-fresnel/src/main/java/edu/mit/simile/vocabularies/Facets.java (revision 19)
+++ trunk/simile-fresnel/src/main/java/edu/mit/simile/vocabularies/Facets.java (revision 19)
@@ -0,0 +1,59 @@
+/* CVS $Id: $ */
+package edu.mit.simile.vocabularies; 
+import org.openrdf.model.*;
+import org.openrdf.model.impl.*;
+import org.openrdf.repository.*;
+import org.openrdf.repository.sail.*;
+import org.openrdf.sail.memory.MemoryStore;
+ 
+/**
+ * Vocabulary definitions from file:./ontologies/facets.owl 
+ * @author Auto-generated by schemagen on 07 Mar 2008 21:56 
+ */
+public class Facets {
+    /** <p>The RDF model that holds the vocabulary terms</p> */
+    private static Repository m_model;
+    static {
+    	try {
+    			m_model = new SailRepository(new MemoryStore());
+    			m_model.initialize();
+    		} catch (RepositoryException e) {
+    			System.err.println("Failed to initialize");
+    		}
+    }
+    
+    /** <p>The namespace of the vocabulary as a string</p> */
+    public static final String NS = "http://simile.mit.edu/2006/01/ontologies/fresnel-facets#";
+    
+    /** <p>The namespace of the vocabulary as a string</p>
+     *  @see #NS */
+    public static String getURI() {return NS;}
+    
+    /** <p>The namespace of the vocabulary as a resource</p> */
+    public static final Resource NAMESPACE = m_model.getValueFactory().createURI( NS );
+    
+    /** <p></p> */
+    public static final URI facets = m_model.getValueFactory().createURI( "http://simile.mit.edu/2006/01/ontologies/fresnel-facets#facets" );
+    
+    /** <p></p> */
+    public static final URI hides = m_model.getValueFactory().createURI( "http://simile.mit.edu/2006/01/ontologies/fresnel-facets#hides" );
+    
+    /** <p></p> */
+    public static final URI types = m_model.getValueFactory().createURI( "http://simile.mit.edu/2006/01/ontologies/fresnel-facets#types" );
+    
+    /** <p></p> */
+    public static final Resource Facet = m_model.getValueFactory().createURI( "http://simile.mit.edu/2006/01/ontologies/fresnel-facets#Facet" );
+    
+    /** <p></p> */
+    public static final Resource FacetList = m_model.getValueFactory().createURI( "http://simile.mit.edu/2006/01/ontologies/fresnel-facets#FacetList" );
+    
+    /** <p></p> */
+    public static final Resource FacetSet = m_model.getValueFactory().createURI( "http://simile.mit.edu/2006/01/ontologies/fresnel-facets#FacetSet" );
+    
+    /** <p></p> */
+    public static final Resource TypeList = m_model.getValueFactory().createURI( "http://simile.mit.edu/2006/01/ontologies/fresnel-facets#TypeList" );
+    
+    /** <p></p> */
+    public static final Resource allTypes = m_model.getValueFactory().createURI( "http://simile.mit.edu/2006/01/ontologies/fresnel-facets#allTypes" );
+    
+}
Index: trunk/simile-fresnel/src/main/java/edu/mit/simile/vocabularies/FresnelCore.java
===================================================================
--- trunk/simile-fresnel/src/main/java/edu/mit/simile/vocabularies/FresnelCore.java (revision 19)
+++ trunk/simile-fresnel/src/main/java/edu/mit/simile/vocabularies/FresnelCore.java (revision 19)
@@ -0,0 +1,200 @@
+/* CVS $Id: $ */
+package edu.mit.simile.vocabularies; 
+import org.openrdf.model.*;
+import org.openrdf.model.impl.*;
+import org.openrdf.repository.*;
+import org.openrdf.repository.sail.*;
+import org.openrdf.sail.memory.MemoryStore;
+ 
+/**
+ * Vocabulary definitions from file:./ontologies/core.owl 
+ * @author Auto-generated by schemagen on 07 Mar 2008 21:56 
+ */
+public class FresnelCore {
+    /** <p>The RDF model that holds the vocabulary terms</p> */
+    private static Repository m_model;
+    static {
+    	try {
+    			m_model = new SailRepository(new MemoryStore());
+    			m_model.initialize();
+    		} catch (RepositoryException e) {
+    			System.err.println("Failed to initialize");
+    		}
+    }
+    
+    /** <p>The namespace of the vocabulary as a string</p> */
+    public static final String NS = "http://www.w3.org/2004/09/fresnel#";
+    
+    /** <p>The namespace of the vocabulary as a string</p>
+     *  @see #NS */
+    public static String getURI() {return NS;}
+    
+    /** <p>The namespace of the vocabulary as a resource</p> */
+    public static final Resource NAMESPACE = m_model.getValueFactory().createURI( NS );
+    
+    /** <p></p> */
+    public static final URI classFormatDomain = m_model.getValueFactory().createURI( "http://www.w3.org/2004/09/fresnel#classFormatDomain" );
+    
+    /** <p></p> */
+    public static final URI classLensDomain = m_model.getValueFactory().createURI( "http://www.w3.org/2004/09/fresnel#classLensDomain" );
+    
+    /** <p></p> */
+    public static final URI group = m_model.getValueFactory().createURI( "http://www.w3.org/2004/09/fresnel#group" );
+    
+    /** <p></p> */
+    public static final URI hideProperties = m_model.getValueFactory().createURI( "http://www.w3.org/2004/09/fresnel#hideProperties" );
+    
+    /** <p></p> */
+    public static final URI instanceFormatDomain = m_model.getValueFactory().createURI( "http://www.w3.org/2004/09/fresnel#instanceFormatDomain" );
+    
+    /** <p></p> */
+    public static final URI instanceLensDomain = m_model.getValueFactory().createURI( "http://www.w3.org/2004/09/fresnel#instanceLensDomain" );
+    
+    /** <p></p> */
+    public static final URI label = m_model.getValueFactory().createURI( "http://www.w3.org/2004/09/fresnel#label" );
+    
+    /** <p></p> */
+    public static final URI labelFormat = m_model.getValueFactory().createURI( "http://www.w3.org/2004/09/fresnel#labelFormat" );
+    
+    /** <p></p> */
+    public static final URI primaryClasses = m_model.getValueFactory().createURI( "http://www.w3.org/2004/09/fresnel#primaryClasses" );
+    
+    /** <p></p> */
+    public static final URI property = m_model.getValueFactory().createURI( "http://www.w3.org/2004/09/fresnel#property" );
+    
+    /** <p></p> */
+    public static final URI propertyFormat = m_model.getValueFactory().createURI( "http://www.w3.org/2004/09/fresnel#propertyFormat" );
+    
+    /** <p></p> */
+    public static final URI propertyFormatDomain = m_model.getValueFactory().createURI( "http://www.w3.org/2004/09/fresnel#propertyFormatDomain" );
+    
+    /** <p></p> */
+    public static final URI purpose = m_model.getValueFactory().createURI( "http://www.w3.org/2004/09/fresnel#purpose" );
+    
+    /** <p></p> */
+    public static final URI resourceFormat = m_model.getValueFactory().createURI( "http://www.w3.org/2004/09/fresnel#resourceFormat" );
+    
+    /** <p></p> */
+    public static final URI showProperties = m_model.getValueFactory().createURI( "http://www.w3.org/2004/09/fresnel#showProperties" );
+    
+    /** <p></p> */
+    public static final URI sublens = m_model.getValueFactory().createURI( "http://www.w3.org/2004/09/fresnel#sublens" );
+    
+    /** <p></p> */
+    public static final URI use = m_model.getValueFactory().createURI( "http://www.w3.org/2004/09/fresnel#use" );
+    
+    /** <p></p> */
+    public static final URI value = m_model.getValueFactory().createURI( "http://www.w3.org/2004/09/fresnel#value" );
+    
+    /** <p></p> */
+    public static final URI valueFormat = m_model.getValueFactory().createURI( "http://www.w3.org/2004/09/fresnel#valueFormat" );
+    
+    /** <p></p> */
+    public static final URI contentAfter = m_model.getValueFactory().createURI( "http://www.w3.org/2004/09/fresnel#contentAfter" );
+    
+    /** <p></p> */
+    public static final URI contentBefore = m_model.getValueFactory().createURI( "http://www.w3.org/2004/09/fresnel#contentBefore" );
+    
+    /** <p></p> */
+    public static final URI contentFirst = m_model.getValueFactory().createURI( "http://www.w3.org/2004/09/fresnel#contentFirst" );
+    
+    /** <p></p> */
+    public static final URI contentLast = m_model.getValueFactory().createURI( "http://www.w3.org/2004/09/fresnel#contentLast" );
+    
+    /** <p></p> */
+    public static final URI contentNoValue = m_model.getValueFactory().createURI( "http://www.w3.org/2004/09/fresnel#contentNoValue" );
+    
+    /** <p></p> */
+    public static final URI depth = m_model.getValueFactory().createURI( "http://www.w3.org/2004/09/fresnel#depth" );
+    
+    /** <p></p> */
+    public static final URI labelStyle = m_model.getValueFactory().createURI( "http://www.w3.org/2004/09/fresnel#labelStyle" );
+    
+    /** <p></p> */
+    public static final URI propertyStyle = m_model.getValueFactory().createURI( "http://www.w3.org/2004/09/fresnel#propertyStyle" );
+    
+    /** <p></p> */
+    public static final URI resourceStyle = m_model.getValueFactory().createURI( "http://www.w3.org/2004/09/fresnel#resourceStyle" );
+    
+    /** <p></p> */
+    public static final URI valueStyle = m_model.getValueFactory().createURI( "http://www.w3.org/2004/09/fresnel#valueStyle" );
+    
+    /** <p></p> */
+    public static final Resource ClassList = m_model.getValueFactory().createURI( "http://www.w3.org/2004/09/fresnel#ClassList" );
+    
+    /** <p></p> */
+    public static final Resource ConvenienceToken = m_model.getValueFactory().createURI( "http://www.w3.org/2004/09/fresnel#ConvenienceToken" );
+    
+    /** <p></p> */
+    public static final Resource ConvienceProperty = m_model.getValueFactory().createURI( "http://www.w3.org/2004/09/fresnel#ConvienceProperty" );
+    
+    /** <p></p> */
+    public static final Resource Format = m_model.getValueFactory().createURI( "http://www.w3.org/2004/09/fresnel#Format" );
+    
+    /** <p></p> */
+    public static final Resource FormatDescription = m_model.getValueFactory().createURI( "http://www.w3.org/2004/09/fresnel#FormatDescription" );
+    
+    /** <p></p> */
+    public static final Resource FormatDescriptionNoSubstitution = m_model.getValueFactory().createURI( "http://www.w3.org/2004/09/fresnel#FormatDescriptionNoSubstitution" );
+    
+    /** <p></p> */
+    public static final Resource FormatDescriptionSubstitution = m_model.getValueFactory().createURI( "http://www.w3.org/2004/09/fresnel#FormatDescriptionSubstitution" );
+    
+    /** <p></p> */
+    public static final Resource Group = m_model.getValueFactory().createURI( "http://www.w3.org/2004/09/fresnel#Group" );
+    
+    /** <p></p> */
+    public static final Resource HidePropertyList = m_model.getValueFactory().createURI( "http://www.w3.org/2004/09/fresnel#HidePropertyList" );
+    
+    /** <p></p> */
+    public static final Resource LabellingFormat = m_model.getValueFactory().createURI( "http://www.w3.org/2004/09/fresnel#LabellingFormat" );
+    
+    /** <p></p> */
+    public static final Resource Lens = m_model.getValueFactory().createURI( "http://www.w3.org/2004/09/fresnel#Lens" );
+    
+    /** <p></p> */
+    public static final Resource PropertyDescription = m_model.getValueFactory().createURI( "http://www.w3.org/2004/09/fresnel#PropertyDescription" );
+    
+    /** <p></p> */
+    public static final Resource PropertySet = m_model.getValueFactory().createURI( "http://www.w3.org/2004/09/fresnel#PropertySet" );
+    
+    /** <p></p> */
+    public static final Resource PropertyValueStyle = m_model.getValueFactory().createURI( "http://www.w3.org/2004/09/fresnel#PropertyValueStyle" );
+    
+    /** <p></p> */
+    public static final Resource Purpose = m_model.getValueFactory().createURI( "http://www.w3.org/2004/09/fresnel#Purpose" );
+    
+    /** <p></p> */
+    public static final Resource ShowPropertyList = m_model.getValueFactory().createURI( "http://www.w3.org/2004/09/fresnel#ShowPropertyList" );
+    
+    /** <p></p> */
+    public static final Resource allProperties = m_model.getValueFactory().createURI( "http://www.w3.org/2004/09/fresnel#allProperties" );
+    
+    /** <p></p> */
+    public static final Resource defaultLens = m_model.getValueFactory().createURI( "http://www.w3.org/2004/09/fresnel#defaultLens" );
+    
+    /** <p></p> */
+    public static final Resource externalLink = m_model.getValueFactory().createURI( "http://www.w3.org/2004/09/fresnel#externalLink" );
+    
+    /** <p></p> */
+    public static final Resource image = m_model.getValueFactory().createURI( "http://www.w3.org/2004/09/fresnel#image" );
+    
+    /** <p></p> */
+    public static final Resource labelLens = m_model.getValueFactory().createURI( "http://www.w3.org/2004/09/fresnel#labelLens" );
+    
+    /** <p></p> */
+    public static final Resource member = m_model.getValueFactory().createURI( "http://www.w3.org/2004/09/fresnel#member" );
+    
+    /** <p></p> */
+    public static final Resource none = m_model.getValueFactory().createURI( "http://www.w3.org/2004/09/fresnel#none" );
+    
+    /** <p></p> */
+    public static final Resource replacedResource = m_model.getValueFactory().createURI( "http://www.w3.org/2004/09/fresnel#replacedResource" );
+    
+    /** <p></p> */
+    public static final Resource show = m_model.getValueFactory().createURI( "http://www.w3.org/2004/09/fresnel#show" );
+    
+    /** <p></p> */
+    public static final Resource uri = m_model.getValueFactory().createURI( "http://www.w3.org/2004/09/fresnel#uri" );
+    
+}
Index: trunk/simile-fresnel/src/main/java/edu/mit/simile/fresnel/results/PropertyResultSet.java
===================================================================
--- trunk/simile-fresnel/src/main/java/edu/mit/simile/fresnel/results/PropertyResultSet.java (revision 2)
+++ trunk/simile-fresnel/src/main/java/edu/mit/simile/fresnel/results/PropertyResultSet.java (revision 36)
@@ -1,102 +1,144 @@
 package edu.mit.simile.fresnel.results;
 
 import java.util.HashMap;
 import java.util.Iterator;
 
 import org.openrdf.model.Resource;
 import org.openrdf.model.URI;
 
 import edu.mit.simile.fresnel.util.WrappedVector;
 
 /**
  * Set of PropertyResults.
  * 
  * @author ryanlee
  */
 public class PropertyResultSet extends WrappedVector<PropertyResult> {
 	/**
 	 * Maps property URIs to their corresponding PropertyResults
 	 */
-	private HashMap<Resource, PropertyResult> _used;
+	private HashMap<InvertableURI, PropertyResult> _used;
 	
 	/**
 	 * Initialize a set.
 	 */
 	public PropertyResultSet() {
 		super();
-		this._used = new HashMap<Resource, PropertyResult>();
+		this._used = new HashMap<InvertableURI, PropertyResult>();
 	}
 	
 	/**
 	 * Returns a PropertyResultIterator instead of a normal iterator.
 	 * 
 	 * @return A <code>PropertyResultIterator</code>
 	 */
 	public Iterator<PropertyResult> propertyResultIterator() {
 		return this._base.iterator();
 	}
 	
 	/**
 	 * Adds a property result to the existing set.
 	 * 
 	 * @param property A <code>PropertyResult</code>
 	 * @return Success or failure
 	 */
 	public boolean addPropertyResult(PropertyResult property, Result parent) {
-		this._used.put(property.getOrigin(), property);
+		this._used.put(new InvertableURI(property.getOrigin(), property.isInverse()), property);
 		return this._base.add(property);
 	}
 	
 	/**
 	 * Removes a property result from the existing set.
 	 * 
 	 * @param property A <code>PropertyResult</code>
 	 * @return Success or failure
 	 */
 	public boolean removePropertyResult(PropertyResult property) {
 		this._used.remove(property);
 		return this._base.remove(property);
 	}
 	
 	/**
 	 * Add all elements from a property result set into this one.
 	 * 
 	 * @param arg0 A <code>PropertyResultSet</code>
 	 * @return Success or failure
 	 */
 	public boolean addPropertyResultSet(PropertyResultSet arg0) {
 		for(Iterator<PropertyResult> it = arg0.propertyResultIterator(); it.hasNext() ;) {
 			PropertyResult pr = it.next();
-			this._used.put(pr.getOrigin(), pr);
+			this._used.put(new InvertableURI(pr.getOrigin(), pr.isInverse()), pr);
 		}
 		return this._base.addAll(arg0._base);
 	}
 	
 	/**
 	 * Replace WrappedVector contains method to do specific <code>PropertyResult</code>
 	 * equality checking.
 	 * 
 	 * @param property The <code>PropertyResult</code> component to check
 	 * @return True if contained in set, false if not.
 	 */
 	public boolean contains(PropertyResult property) {
 		for (Iterator<PropertyResult> it = this.propertyResultIterator(); it.hasNext(); ) {
 			if (property.equals(it.next())) return true;
 		}
 		return false;
 	}
 	
 	/**
 	 * Check if this set contains a property URI and return its PropertyResult if so.
 	 * 
 	 * @param prop The property <code>URI</code> to lookup
 	 * @return Corresponding <code>PropertyResult</code> or null if non-existent.
 	 */
-	public PropertyResult lookup(URI prop) {
-		if (this._used.containsKey(prop)) {
-			return (PropertyResult) this._used.get(prop);
+	public PropertyResult lookup(URI prop, boolean inverse) {
+		if (this._used.containsKey(new InvertableURI(prop, inverse))) {
+			return (PropertyResult) this._used.get(new InvertableURI(prop, inverse));
 		} else {
 			return null;
 		}
 	}
+	
+	/**
+	 * Check if this set contains a property URI and return its PropertyResult if so.
+	 * 
+	 * @param prop The property <code>URI</code> to lookup
+	 * @return Corresponding <code>PropertyResult</code> or null if non-existent.
+	 */
+	public PropertyResult lookup(URI prop) {
+		return lookup(prop, false);
+	}
+	
+	private class InvertableURI {
+		private Resource uri;
+		private boolean inverse;
+		
+		public InvertableURI(Resource uri, boolean inverse) {
+			this.uri = uri;
+			this.inverse = inverse;
+		}
+
+		@Override
+		public boolean equals(Object obj) {
+			return (obj instanceof InvertableURI
+					&& ((InvertableURI)obj).getUri().equals(getUri())
+					&& ((InvertableURI)obj).isInverse() == isInverse());
+		}
+
+		public Resource getUri() {
+			return uri;
+		}
+
+		public boolean isInverse() {
+			return inverse;
+		}
+
+		@Override
+		public int hashCode() {
+			return uri.toString().hashCode() * (inverse ? -1 : 1);
+		}
+		
+		
+	}
 }
Index: trunk/simile-fresnel/src/main/java/edu/mit/simile/fresnel/results/NoSuchPropertyResult.java
===================================================================
--- trunk/simile-fresnel/src/main/java/edu/mit/simile/fresnel/results/NoSuchPropertyResult.java (revision 2)
+++ trunk/simile-fresnel/src/main/java/edu/mit/simile/fresnel/results/NoSuchPropertyResult.java (revision 33)
@@ -1,74 +1,74 @@
 package edu.mit.simile.fresnel.results;
 
 import edu.mit.simile.fresnel.selection.ISelector;
 
 import org.openrdf.model.URI;
 
 import org.w3c.dom.Document;
 import org.w3c.dom.Element;
 
 /**
  * For properties that are specified as ones to be displayed but did not
  * exist in the result model.
  * 
  * @author ryanlee
  */
 public class NoSuchPropertyResult extends PropertyResult implements ResultConstants {	
 	/**
 	 * Constructor based on property, selection mechanism, and parent resource result.
 	 * 
 	 * @param prop A property <code>URI</code>
 	 * @param selector The selectin <code>ISelector</code>
 	 * @param parent The parent <code>Resource</code>
 	 */
 	public NoSuchPropertyResult(URI prop, ISelector selector, Result parent) {
 		super(prop, selector, parent);
 	}
 	
 	/**
 	 * Whether the property is in the model or not; always false here.
 	 * 
 	 * @return <code>boolean</code> false
 	 */
 	public boolean isInModel() {
 		return false;
 	}
 	
 	/**
 	 * Only render this if there is some contentNoValue given for it.
 	 * 
 	 * @param doc A <code>Document</code> for creating elements
 	 * @return An <code>Element</code> representing the property
 	 * @see PropertyResult#render(Document)
 	 */
 	public Element render(Document doc) {
 		Element out = null;
 		if (null != getContents().getReplacement()) {
-			ValueResult noContent = new ValueResult(getContents().getReplacement(), (PropertyResult) this);
+			ValueResult noContent = new ValueResult(getContents().getReplacement(), (PropertyResult) this, null);
 			ValueResultSet values = new ValueResultSet();
 			values.addValueResult(noContent);
 			out = doc.createElementNS(INTERMEDIATE_NS, "property");
 			out.setAttribute("class", getStyles());
 			out.setAttribute("uri", getURI());
 			Element content = getContents().render(doc);
 			if (content.hasChildNodes()) out.appendChild(content);
 			if (showLabel()) {
 				Element label = doc.createElementNS(INTERMEDIATE_NS, "label");
 				label.setAttribute("class", getLabelStyles());
 				label.appendChild(getLabelContents().render(doc));
 				Element title = doc.createElementNS(INTERMEDIATE_NS, "title");
 				if (null == getTitle() || getTitle().isFallback()) {
 					title.appendChild(doc.createTextNode(getLabelContents().getReplacement()));
 					label.appendChild(title);
 					out.appendChild(label);				
 				} else {
 					title.appendChild(doc.createTextNode(getTitle().getString()));
 					label.appendChild(title);
 					out.appendChild(label);
 				}
 			}
 			out.appendChild(values.render(doc));
 		}
 		return out;
 	}
 }
Index: trunk/simile-fresnel/src/main/java/edu/mit/simile/fresnel/results/PropertyResult.java
===================================================================
--- trunk/simile-fresnel/src/main/java/edu/mit/simile/fresnel/results/PropertyResult.java (revision 2)
+++ trunk/simile-fresnel/src/main/java/edu/mit/simile/fresnel/results/PropertyResult.java (revision 36)
@@ -1,281 +1,321 @@
 package edu.mit.simile.fresnel.results;
 
 import edu.mit.simile.fresnel.selection.ISelector;
 
 import org.openrdf.model.URI;
+import org.openrdf.repository.Repository;
 
 import org.w3c.dom.Document;
 import org.w3c.dom.Element;
 
 /**
  * Represents property selection and formatting results.
  * 
  * @author ryanlee
  */
 public class PropertyResult implements ResultConstants {
 	/**
 	 * Property the result describes
 	 */
 	private URI _origin;
 	/**
 	 * Human friendly label
 	 */
 	private Title _title;
 	/**
 	 * Associated style classes
 	 */
 	private String _styles;
 	/**
 	 * Associated formatting strings
 	 */
 	private ContentSet _contents;
 	/**
 	 * Whether to show the property's label or not
 	 */
 	private boolean _showLabel;
 	/**
 	 * Formatting for the property's label
 	 */
 	private ContentSet _labelContents;
 	/**
 	 * Styles for the property's label
 	 */
 	private String _labelStyles;
 	/**
 	 * Values associated with the property
 	 */
 	private ValueResultSet _values;
 	/**
 	 * The selector used to select the property
 	 */
 	private ISelector _selector;
 	/**
 	 * The parent resource result
 	 */
 	private Result _parent;
+
+	/**
+	 * Whether this property result denotes an inverse relationship
+	 */
+	private boolean _inverse;	
 	
 	/**
 	 * 
 	 * @param prop
 	 * @param selector
 	 * @param parent
 	 */
+	public PropertyResult(URI prop, ISelector selector, Result parent, boolean inverse) {
+		this._origin = prop;
+		this._values = new ValueResultSet();
+		this._contents = new ContentSet();
+		this._labelContents = new ContentSet();
+		this._showLabel = true;
+		this._selector = selector;
+		this._parent = parent;
+		this._inverse = inverse;
+	}
+	
 	public PropertyResult(URI prop, ISelector selector, Result parent) {
 		this._origin = prop;
 		this._values = new ValueResultSet();
 		this._contents = new ContentSet();
 		this._labelContents = new ContentSet();
 		this._showLabel = true;
 		this._selector = selector;
 		this._parent = parent;
+		this._inverse = false;
 	}
 
 	/**
 	 * Retrieves the property URI
 	 * 
 	 * @return The property <code>URI</code>
 	 */
 	public URI getOrigin() {
 		return this._origin;
 	}
 	
 	/**
 	 * Retrieves the selecting selector
 	 * 
 	 * @return An <code>ISelector</code>
 	 */
 	public ISelector getSelector() {
 		return this._selector;
 	}
 	
 	/**
 	 * Retrieves the result for the subject using this property
 	 * 
 	 * @return A <code>Result</code>
 	 */
 	public Result getParent() {
 		return this._parent;
 	}
 	
 	/**
 	 * Returns a string representation of the property URI
 	 * 
 	 * @return A <code>String</code> URI
 	 */
 	public String getURI() {
 		return this._origin.toString();
 	}
 	
 	/**
 	 * Retrieves the title for the property
 	 * 
 	 * @return A <code>Title</code>
 	 */
 	public Title getTitle() {
 		return this._title;
 	}
 	
 	/**
 	 * Retrieves styling for the property
 	 * 
 	 * @return A <code>String</code>
 	 */
 	public String getStyles() {
 		return this._styles;
 	}
 	
 	/**
 	 * Retrieves content formatting for the property
 	 * 
 	 * @return A <code>ContentSet</code>
 	 */
 	public ContentSet getContents() {
 		return this._contents;
 	}
 	
 	/**
 	 * Retrieves styling for the property's label
 	 * 
 	 * @return A <code>String</code>
 	 */
 	public String getLabelStyles() {
 		return this._labelStyles;
 	}
 	
 	/**
 	 * Retrieves content formatting for the property's label
 	 * 
 	 * @return A <code>ContentSet</code>
 	 */
 	public ContentSet getLabelContents() {
 		return this._labelContents;
 	}
 	
 	/**
 	 * Returns the values this property points to.
 	 * 
 	 * @return A <code>ValueResultSet</code>
 	 */
 	public ValueResultSet getValues() {
 		return this._values;
 	}
 	
 	/**
 	 * Whether this property's label should be shown.
 	 * 
 	 * @return True if it should be, false if not.
 	 */
 	public boolean showLabel() {
 		return this._showLabel;
 	}
 	
 	/**
 	 * Sets the human-friendly title.
 	 * 
 	 * @param title A <code>Title</code>
 	 */
 	public void setTitle(Title title) {
 		this._title = title;
 	}
 	
 	/**
 	 * Sets the property's styling information.
 	 * 
 	 * @param style A <code>String</code>
 	 */
 	public void setStyles(String style) {
 		this._styles = style;
 	}
 	
 	/**
 	 * Sets the property's content formatting.
 	 * 
 	 * @param contents A <code>ContentSet</code>
 	 */
 	public void setContents(ContentSet contents) {
 		this._contents = contents;
 	}
 	
 	/**
 	 * Sets the property label's styling.
 	 * 
 	 * @param style A <code>String</code>
 	 */
 	public void setLabelStyles(String style) {
 		this._labelStyles = style;
 	}
 	
 	/**
 	 * Sets the property label's content formatting.
 	 * 
 	 * @param contents A <code>ContentSet</code>
 	 */
 	public void setLabelContents(ContentSet contents) {
 		this._labelContents = contents;
 	}
 	
 	/**
 	 * Sets whether the label should be shown.
 	 * 
 	 * @param show True if it should be shown, false if not
 	 */
 	public void setShowLabel(boolean show) {
 		this._showLabel = show;
 	}
 	
 	/**
 	 * Add another value to this property's value result set
 	 * 
 	 * @param val A <code>ValueResult</code>
+	 * @param in  Data repository
 	 * @return Success or failure
 	 */
-	public boolean addValue(ValueResult val) {
-		return this._values.addValueResult(val);
-	}
+	public boolean addValue(ValueResult val, Repository in) {
+		return this._values.addValueResult(val, in);
+	}
+	
+	/**
+	 * Add another value to this property's value result set
+	 * 
+	 * @param val A <code>ValueResult</code>
+	 * @return Success or failure
+	 */
+	public boolean addValue(ValueResult value) {
+		return addValue(value, null);
+	}
+
 	
 	/**
 	 * If this property result originated from the source graph.
 	 * 
 	 * @return True
 	 */
 	public boolean isInModel() {
 		return true;
 	}
 	
 	/**
 	 * Render the property result and all its children into a part of the Fresnel XML
 	 * output tree.
 	 * 
 	 * @param doc A <code>Document</code> to create elements.
 	 * @return An <code>Element</code> representing the property, e.g.:
 	 *         &lt;property&gt;&lt;label&gt; ... &lt;/label&gt; ... &lt/property&gt;
 	 */
 	public Element render(Document doc) {
 		Element out = doc.createElementNS(INTERMEDIATE_NS, "property");
 		out.setAttribute("class", getStyles());
 		out.setAttribute("uri", getURI());
+		out.setAttribute("inverse", Boolean.toString(isInverse()));
 		Element content = getContents().render(doc);
 		if (content.hasChildNodes()) out.appendChild(content);
 		if (showLabel()) {
 			Element label = doc.createElementNS(INTERMEDIATE_NS, "label");
 			label.setAttribute("class", getLabelStyles());
 			label.appendChild(getLabelContents().render(doc));
 			Element title = doc.createElementNS(INTERMEDIATE_NS, "title");
 			// this should already be taken care of by selection.applyLabelFormat, but hey,
 			// why not more code...
 			if (null == getTitle() || getTitle().isFallback()) {
 				// Happens to be null in the fresnel:member case - SBD
 				if (null != getLabelContents().getReplacement())
 					title.appendChild(doc.createTextNode(getLabelContents().getReplacement()));
 				label.appendChild(title);
 				out.appendChild(label);				
 			} else {
 				title.appendChild(doc.createTextNode(getTitle().getString()));
 				label.appendChild(title);
 				out.appendChild(label);
 			}
 		}
 		out.appendChild(getValues().render(doc));
 		return out;
 	}
+	
+	/**
+	 * If this property result denotes an inverse relationship
+	 * 
+	 * @return True
+	 */
+	public boolean isInverse() {
+		return _inverse;
+	}
 }
Index: trunk/simile-fresnel/src/main/java/edu/mit/simile/fresnel/results/Selection.java
===================================================================
--- trunk/simile-fresnel/src/main/java/edu/mit/simile/fresnel/results/Selection.java (revision 2)
+++ trunk/simile-fresnel/src/main/java/edu/mit/simile/fresnel/results/Selection.java (revision 44)
@@ -1,928 +1,1006 @@
 package edu.mit.simile.fresnel.results;
 
 import java.util.Iterator;
 import java.util.LinkedList;
 import java.util.List;
+import java.util.Vector;
 
 import javax.xml.parsers.DocumentBuilder;
 import javax.xml.parsers.DocumentBuilderFactory;
 import javax.xml.parsers.ParserConfigurationException;
 import javax.xml.transform.OutputKeys;
 import javax.xml.transform.Transformer;
 import javax.xml.transform.TransformerFactory;
 import javax.xml.transform.dom.DOMSource;
 import javax.xml.transform.sax.SAXResult;
 
 import org.openrdf.model.BNode;
 import org.openrdf.model.Literal;
 import org.openrdf.model.Resource;
 import org.openrdf.model.Statement;
 import org.openrdf.model.URI;
 import org.openrdf.model.Value;
 import org.openrdf.model.impl.LiteralImpl;
 import org.openrdf.model.impl.URIImpl;
 import org.openrdf.model.vocabulary.RDFS;
 import org.openrdf.repository.Repository;
 import org.openrdf.repository.RepositoryConnection;
 import org.openrdf.repository.RepositoryException;
 import org.openrdf.repository.RepositoryResult;
 import org.openrdf.repository.sail.SailRepository;
 import org.openrdf.sail.memory.MemoryStore;
 import org.w3c.dom.Document;
 import org.w3c.dom.Element;
 import org.xml.sax.ContentHandler;
 import org.xml.sax.SAXException;
 
 import edu.mit.simile.fresnel.FresnelUtilities;
 import edu.mit.simile.fresnel.configuration.Configuration;
 import edu.mit.simile.fresnel.configuration.Group;
 import edu.mit.simile.fresnel.configuration.LensMatchSet;
 import edu.mit.simile.fresnel.format.Format;
 import edu.mit.simile.fresnel.format.FormatDescription;
 import edu.mit.simile.fresnel.format.Style;
 import edu.mit.simile.fresnel.purpose.Purpose;
 import edu.mit.simile.fresnel.selection.AllPropertiesSelector;
+import edu.mit.simile.fresnel.selection.FSESelector;
 import edu.mit.simile.fresnel.selection.ISelector;
 import edu.mit.simile.fresnel.selection.InvalidResultSetException;
 import edu.mit.simile.fresnel.selection.Lens;
 import edu.mit.simile.fresnel.selection.PropertyDescription;
 import edu.mit.simile.fresnel.selection.PropertySelector;
 import edu.mit.simile.fresnel.selection.PropertySet;
 import edu.mit.simile.vocabularies.FresnelCore;
 
 /**
  * The output of lens selection which can then be formatted and finally
  * rendered to an XML output.
  * 
  * @author ryanlee
  */
 public class Selection implements ResultConstants {	
 	/**
 	 * The configuration that generated this selection
 	 */
 	private Configuration _conf;
 	
 	/**
 	 * The subRepository of data selected in the selection process
 	 */
 	private Repository _model;
 	
 	/**
 	 * A subRepository of data only relating to its types, independent of what is actually selected
 	 */
 	private Repository _typesModel;
 	
 	/**
 	 * Statements expected but not found in results; no way to match selectors but through
 	 * model API...
 	 */
 	private Repository _notModel;
 	
 	/**
 	 * Unused; will specify order of results if ever implemented
 	 */
 	//private Vector _order;
 	
 	/**
 	 * The set of all primary results generated during selection
 	 */
 	private List<Result> _results;
 	
 	/**
 	 * A hash of all results generated in selection keyed by resource
 	 */
 	private ResultHashMap<Resource, Result> _resultModelHash;
 	
 	/**
 	 * A hash of all property results generated in selection keyed by property URI
 	 */
 	private ResultHashMap<URI, PropertyResult> _propertyResultModelHash;
 
 	/**
 	 * A hash of all value results generated in selection keyed by value
 	 */
 	private ResultHashMap<Value, ValueResult> _valueResultModelHash;
+	
+	/**
+	 * Language preference
+	 */
+	private String _langPref;
 
 	/**
 	 * Format should apply to a resource
 	 */
 	public static final int RESOURCE = 0;
 	/**
 	 * Format should apply to a property
 	 */
 	public static final int PROPERTY = 1;
 	/**
 	 * Format should apply to a label
 	 */
 	public static final int LABEL    = 2;
 	/**
 	 * Format should apply to a value
 	 */
 	public static final int VALUE    = 3;
 	/**
 	 * dc:title URI, because it's easier to put it here
 	 */
 	public static final String DCTITLE = "http://purl.org/dc/elements/1.1/title";
 	
 	/**
 	 * Constructor based on a configuration.
 	 * 
 	 * @param conf A <code>Configuration</code>
 	 */
 	public Selection(Configuration conf) {
 		this._conf = conf;
 		this._model = new SailRepository(new MemoryStore());
 		this._typesModel = new SailRepository(new MemoryStore());
 		this._notModel = new SailRepository(new MemoryStore());
 		try {
 			this._model.initialize();
 			this._typesModel.initialize();
 			this._notModel.initialize();
 		} catch (RepositoryException e) {
 			System.err.println("Failed to initialize repositories");
 		}
 		//this._order = new Vector();
 		this._results = new LinkedList<Result>();
 		this._resultModelHash = new ResultHashMap<Resource, Result>();
 		this._propertyResultModelHash = new ResultHashMap<URI, PropertyResult>();
 		this._valueResultModelHash = new ResultHashMap<Value, ValueResult>();
+		this._langPref = "en";
 	}
 	
 	/**
 	 * Retrieves a subRepository created to reflect all the things which were requested in the
 	 * configuration and found in the data source.
 	 * 
 	 * @return A <code>Repository</code>
 	 */
 	public Repository getModel() {
 		return this._model;
 	}
 	
 	/**
 	 * Retrieves a subRepository created to reflect all the things which were requested
 	 * in configuration but not actually found in the data source.
 	 * 
 	 * @return A <code>Repository</code>
 	 */
 	public Repository getNotModel() {
 		return this._notModel;
 	}
 	
 	/**
 	 * Retrieves a subRepository with just typing information.
 	 * 
 	 * @return A <code>Repository</code> consisting solely of rdf:type statements
 	 */
 	public Repository getTypesModel() {
 		return this._typesModel;
 	}
 	
 	/**
 	 * Retrieves the hash of all results generated during selection.
 	 * 
 	 * @return A <code>ResultHashMap</code>
 	 */
 	public ResultHashMap<Resource, Result> getResourceHash() {
 		return this._resultModelHash;
 	}
 	
 	/**
 	 * Retrieves the hash of all property results generated during selection
 	 * 
 	 * @return A <code>ResultHashMap</code>
 	 */
 	public ResultHashMap<URI, PropertyResult> getPropertyHash() {
 		return this._propertyResultModelHash;
 	}
 	
 	/**
 	 * Retrieves the hash of all value results generated during selection
 	 * 
 	 * @return A <code>ResultHashMap</code>
 	 */
 	public ResultHashMap<Value, ValueResult> getValueHash() {
 		return this._valueResultModelHash;
 	}
 
 	/*
 	 * 
 	 * @param params
 	 */
 	/*
 	public void reorder(Object[] params) {
 		// TODO write this with input on how to do ordering selection
 		this._order.clear();
 	}
 	*/
 	
 	/**
 	 * Add to the list of primary results
 	 * 
 	 * @param r A <code>Result</code>
 	 */
 	public void addPrimary(Result r) {
 		this._results.add(r);
+	}
+	
+	/**
+	 * Sets preferred language for labels
+	 * @param langPref
+	 */
+	public void setLangPref(String langPref) {
+		this._langPref = langPref;
 	}
 	
 	/**
 	 * Select data using a lens.
 	 * 
 	 * @param group The <code>Group</code> to work with
 	 * @param in Data source <code>Repository</code>
 	 * @param lens The <code>Lens</code> to select with
 	 * @param focus Subject <code>Resource</code>
 	 * @param current Present recursion depth, an <code>int</code>
 	 * @param max Maximum recursion depth, an <code>int</code>
 	 * @return A selection <code>Result</code>
 	 */
 	public Result applyLens(Group group, Repository in, Lens lens, Resource focus, int current, int max) {
 		Result r = new Result(FresnelUtilities.dupResource(focus), group, lens, in);
 		try {
 			Iterator<Statement> it = r.getTypesStatements();
 			RepositoryConnection conn = this._typesModel.getConnection();
 			conn.setAutoCommit(false);
 			while(it.hasNext()) {
 				Statement s = it.next();
 				conn.add(s.getSubject(), s.getPredicate(), s.getObject(), s.getContext());
 			}
 			conn.commit();
 			conn.setAutoCommit(true);
 			conn.close();
 		} catch (RepositoryException sue) {
 			System.err.println("Could not add to repository: " + sue);
 			return null;
 		}
  		PropertySet finalProperties = resolvePropertySet(lens, in, focus);
 		Iterator<ISelector> focusPSI = finalProperties.iterator();
 		r.setTitle(resolveLabel(in, focus));
 		this._resultModelHash.putResult(FresnelUtilities.dupResource(focus), r);
 		while (focusPSI.hasNext()) {
 			ISelector selector = focusPSI.next();
 			if (selector.canSelectStatements()) {
 				try {
 					Iterator<Statement> selects = selector.selectStatements(in, focus);
 					if (!selects.hasNext() &&
 							(selector instanceof PropertySelector || selector instanceof PropertyDescription)) {
 						if (selector instanceof PropertySelector) {
 							URI predicate = ((PropertySelector) selector).getProperty();
 							PropertyResult pr = r.getProperties().lookup(predicate);
 							if (null == pr) {
 								NoSuchPropertyResult nspr = new NoSuchPropertyResult(FresnelUtilities.dupURI(predicate), selector, r);
 								nspr.setTitle(resolveLabel(in, predicate));
 								r.addProperty(nspr);
 								this._propertyResultModelHash.putResult(FresnelUtilities.dupURI(predicate), nspr);
 								RepositoryConnection nconn = this._notModel.getConnection();
 								nconn.add(FresnelUtilities.dupResource(focus), FresnelUtilities.dupURI(predicate), new LiteralImpl("empty"));
 								nconn.close();
 							} // if it's not null, there's nothing to do
 						} else {
 							Iterator<Statement> pi = ((PropertyDescription) selector).getProperty().selectStatements(in, focus);
 							if (pi.hasNext()) {
 								URI predicate = pi.next().getPredicate();
 								PropertyResult pr = r.getProperties().lookup(predicate);
 								if (null == pr) {
 									NoSuchPropertyResult nspr = new NoSuchPropertyResult(FresnelUtilities.dupURI(predicate), selector, r);
 									nspr.setTitle(resolveLabel(in, predicate));
 									r.addProperty(nspr);
 									this._propertyResultModelHash.putResult(FresnelUtilities.dupURI(predicate), nspr);
 									RepositoryConnection nconn = this._notModel.getConnection();
 									nconn.add(FresnelUtilities.dupResource(focus), FresnelUtilities.dupURI(predicate), new LiteralImpl("empty"));
 									nconn.close();
 								} // if it's not null, there's nothing to do
 							}
 						}
 					}
 					while (selects.hasNext()) {
 						Statement selected = selects.next();
 						RepositoryConnection mconn = this._model.getConnection();
 						mconn.add(selected.getSubject(), selected.getPredicate(), selected.getObject(), selected.getContext());
 						mconn.commit();
 						mconn.close();
-						URI predicate = selected.getPredicate();
-						Value object = selected.getObject();
-						PropertyResult pr = r.getProperties().lookup(predicate);
+						URI predicate;
+
+						boolean inverse = !selected.getSubject().equals(focus);
+						Value object = inverse ? selected.getSubject() : selected.getObject();
+
+						if (selector instanceof PropertyDescription && ((PropertyDescription)selector).getProperty() instanceof FSESelector) {							
+							predicate = new URIImpl("fsl://" + ((FSESelector)((PropertyDescription)selector).getProperty()).get_fse());
+						}
+						else
+							predicate = selected.getPredicate();
+						
+						PropertyResult pr = r.getProperties().lookup(predicate, inverse);
+
 						if (null == pr) {
-							pr = new PropertyResult(FresnelUtilities.dupURI(predicate), selector, r);
+							pr = new PropertyResult(FresnelUtilities.dupURI(predicate), selector, r, inverse);
 							pr.setTitle(resolveLabel(in, predicate));
 							r.addProperty(pr);
+						//	this._propertyResultModelHash.putResult(FresnelUtilities.dupURI(predicate), pr);
 						} else {
 							// if somehow this property was already marked as NoSuchProperty, then
 							// replace it with a real result
 							if (!pr.isInModel()) {
 								r.getProperties().removePropertyResult(pr);
 								pr = new PropertyResult(FresnelUtilities.dupURI(predicate), selector, r);
 								pr.setTitle(resolveLabel(in, predicate));
 								r.addProperty(pr);
+						//		this._propertyResultModelHash.putResult(FresnelUtilities.dupURI(predicate), pr);
 							}
 						}
+						
+						// cb   
 						this._propertyResultModelHash.putResult(FresnelUtilities.dupURI(predicate), pr);
 						if (object instanceof Resource) {
 							Resource objResource = (Resource) object;
 							Result subr = new Result(FresnelUtilities.dupResource(objResource), group, lens, in);
 							Iterator<Statement> types = r.getTypesStatements();
 							RepositoryConnection tmconn = this._typesModel.getConnection();
 							tmconn.setAutoCommit(false);
 							while(types.hasNext()) {
 								Statement s = types.next();
 								tmconn.add(s.getSubject(), s.getPredicate(), s.getObject(), s.getContext());
 							}
 							tmconn.commit();
 							tmconn.setAutoCommit(true);
 							tmconn.close();
 							if (selector instanceof PropertyDescription) {
 								PropertyDescription selectorPD = (PropertyDescription) selector;
 								if (current == max) {
 									// if we've hit the limit, stop with sublensing
 									subr.setTitle(resolveLabel(in, objResource));
 								} else {									
 									// pick a sublens to apply to the resource
 									int newdepth = (selectorPD.getDepth() + current < max) ? selectorPD.getDepth() + current : max;
 									Lens sublens = null;
 									Iterator<Lens> sublensesIt = selectorPD.getSublensesIterator();
 									boolean match = false;
 									matched:
 									while (sublensesIt.hasNext()) {
 										sublens = sublensesIt.next();
 										Iterator<ISelector> domainIt = sublens.getDomainSet().iterator();
 										while (domainIt.hasNext()) {
 											ISelector subdomain = domainIt.next();
 											if (subdomain.canSelect(in, objResource)) {
 												subr = applyLens(group, in, sublens, objResource, current + 1, newdepth);
 												match = true;
 												break matched;
 											}
 										}
 									}
 									if (!match) {
 										// if none of the specified sublenses fit, check for other matches
 										LensMatchSet lenses = this._conf.getLensMatches().getMatch(objResource);
 										if (null != lenses && !lenses.isEmpty()) {
 											sublens = lenses.topMatch();
 											subr = applyLens(group, in, sublens, objResource, current + 1, max);
 										} else {
 											// or if no lenses fit, turn it into a label
 											subr.setTitle(resolveLabel(in, objResource));
 										}
 									}
 								}
 							} else {
 								subr.setTitle(resolveLabel(in, objResource));
 							}
 							this._resultModelHash.putResult(FresnelUtilities.dupResource(objResource), subr);
-							ValueResult vr = new ValueResult(subr, pr);
+							ValueResult vr = new ValueResult(subr, pr, selected.getContext());
 							this._valueResultModelHash.putResult(FresnelUtilities.dupResource(objResource), vr);
-							pr.addValue(vr);
-						} else {
+							pr.addValue(vr,in);
+						} /* instanceof Resource */ 
+						else {
 							Literal objLiteral = (Literal) object;
-							ValueResult vr = new ValueResult(objLiteral.getLabel(), pr);
+							ValueResult vr = new ValueResult(objLiteral.getLabel(), pr, selected.getContext());
 							this._valueResultModelHash.putResult((Literal) FresnelUtilities.dupValue(objLiteral), vr);
 							pr.addValue(vr);
 						}
 					}
 				} catch (InvalidResultSetException e) {
 					//
 				} catch (RepositoryException sue) {
 					System.err.println("Could not add to repository: " + sue);
 					return null;
 				}
 			}
 		}
 		return r;
 	}
 	
 	/**
 	 * Dispatching method to apply a format depending which type is being formatted
 	 * 
 	 * @param group The <code>Group</code> to work with
 	 * @param format The <code>Format</code> to use
 	 * @param focus The <code>Object</code> to format
 	 * @param type The <code>int</code> type as specified by the class constants
 	 * @return Success or failure
 	 */
 	public boolean applyFormat(Group group, Format format, Object focus, int type, Repository in) {
 		// by contrast, do not use a formatting if it's not in the right group
 		boolean success = true;
 		switch(type) {
 			case RESOURCE:
 				applyFormat(group, format, (Resource) focus);
 				break;
 			case PROPERTY:
 				applyFormat(group, format, (URI) focus, in);
 				break;
 			case LABEL:
 				applyLabelFormat(group, format, (PropertyResult) focus);
 				break;
 			case VALUE:
 				applyValueFormat(group, format, (PropertyResult) focus);
 				break;
 			default:
 				success = false;
 				break;			
 		}
 		return success;
 	}
 	
 	/**
 	 * Applies a label lens to get a result in return.
 	 * 
 	 * @param lens The label <code>Lens</code>
 	 * @param in Data source <code>Repository</code>
 	 * @param focus The selected <code>Resource</code>
 	 * @param current The current recursion depth, an <code>int</code>
 	 * @param max The maximum recursion depth, an <code>int</code>
 	 * @return An appropriate <code>Result</code> that can be rendered as a label
 	 */
 	public Result applyLabelLens(Lens lens, Repository in, Resource focus, int current, int max) {
 		Result r = new Result(FresnelUtilities.dupResource(focus), null, lens, in);
 		try {
 			Iterator<Statement> it = r.getTypesStatements();
 			RepositoryConnection conn = this._typesModel.getConnection();
 			conn.setAutoCommit(false);
 			while (it.hasNext()) {
 				Statement s = it.next();
 				conn.add(s.getSubject(), s.getPredicate(), s.getObject(), s.getContext());
 			}
 			conn.commit();
 			conn.setAutoCommit(true);
 			conn.close();
 		} catch (RepositoryException sue) {
 			System.err.println("Could not add to repository: " + sue);
 			return null;
 		}
 		PropertySet finalProperties = resolvePropertySet(lens, in, focus);
 		Iterator<ISelector> focusPSI = finalProperties.iterator();
 		this._resultModelHash.putResult(FresnelUtilities.dupResource(focus), r);
 		while (focusPSI.hasNext()) {
 			ISelector selector = focusPSI.next();
 			if (selector.canSelectStatements()) {
 				try {
 					Iterator<Statement> selects = selector.selectStatements(in, focus);
 					while (selects.hasNext()) {
 						Statement selected = selects.next();
 						RepositoryConnection mconn = this._model.getConnection();
 						mconn.add(FresnelUtilities.dupResource(selected.getSubject()),
 								FresnelUtilities.dupURI(selected.getPredicate()),
 								FresnelUtilities.dupValue(selected.getObject()));
 						mconn.commit();
 						mconn.close();
 						URI prop = FresnelUtilities.dupURI(selected.getPredicate());
 						Value object = selected.getObject();
 						PropertyResult pr = r.getProperties().lookup(prop);
 						if (null == pr) {
 							pr = new PropertyResult(prop, selector, r);
 							r.addProperty(pr);
 						}
 						if (object instanceof Resource) {
 							Resource objResource = (Resource) object;
 							if (selector instanceof PropertyDescription) {
 								PropertyDescription selectorPD = (PropertyDescription) selector;
 								if (current == max) {
-									ValueResult vr = new ValueResult(resolveLabel(in, objResource, false).getString(), pr);
+									ValueResult vr = new ValueResult(resolveLabel(in, objResource, false).getString(), pr, selected.getContext());
 									pr.addValue(vr);
 									this._propertyResultModelHash.putResult(prop, pr);
 								} else {
 									// pick a sublens to apply to the resource
 									int newdepth = (selectorPD.getDepth() + current < max) ? selectorPD.getDepth() : max;
 									Lens sublens = null;
 									Iterator<Lens> sublensesIt = selectorPD.getSublensesIterator();
 									boolean matched = false;
 									matching:
 									while (sublensesIt.hasNext()) {
 										sublens = sublensesIt.next();
 										Iterator<ISelector> domainIt = sublens.getDomainSet().iterator();
 										while (domainIt.hasNext()) {
 											ISelector subdomain = domainIt.next();
 											if (subdomain.canSelect(in, objResource)) {
 												Result subr = applyLabelLens(sublens, in, objResource, current + 1, newdepth);
-												ValueResult vr = new ValueResult(subr, pr);
+												ValueResult vr = new ValueResult(subr, pr, selected.getContext());
 												pr.addValue(vr);
 												this._propertyResultModelHash.putResult(prop, pr);
 												matched = true;
 												break matching;
 											}
 										}
 									}
 									
 									if (!matched) {
 										// if none of the specified sublenses fit, check for other matches
 										LensMatchSet lenses = this._conf.getLensMatches().getMatch(objResource);
 										if (null != lenses) {
 											sublens = lenses.topMatch();
 											Result subr = applyLabelLens(sublens, in, objResource, current + 1, max);
-											ValueResult vr = new ValueResult(subr, pr);
+											ValueResult vr = new ValueResult(subr, pr, selected.getContext());
 											pr.addValue(vr);
 											this._propertyResultModelHash.putResult(prop, pr);
 										} else {
 											// or if no lenses fit, turn it into a label
-											ValueResult vr = new ValueResult(resolveLabel(in, objResource, false).getString(), pr);
+											ValueResult vr = new ValueResult(resolveLabel(in, objResource, false).getString(), pr, selected.getContext());
 											pr.addValue(vr);
 											this._propertyResultModelHash.putResult(prop, pr);
 										}
 									}
 								}
 							} else {
 								// if not a sublens situation, check for other matches
 								LensMatchSet lenses = this._conf.getLensMatches().getMatch(objResource);
 								if (null != lenses) {
 									Result subr = applyLabelLens(lenses.topMatch(), in, objResource, current + 1, max);
-									ValueResult vr = new ValueResult(subr, pr);
+									ValueResult vr = new ValueResult(subr, pr, selected.getContext());
 									pr.addValue(vr);
 									this._propertyResultModelHash.putResult(prop, pr);
 								} else {
 									// or if no lenses fit, turn it into a label
-									ValueResult vr = new ValueResult(resolveLabel(in, objResource, false).getString(), pr);
+									ValueResult vr = new ValueResult(resolveLabel(in, objResource, false).getString(), pr, selected.getContext());
 									pr.addValue(vr);
 									this._propertyResultModelHash.putResult(prop, pr);
 								}
 							}
 						} else {
 							Literal objLiteral = (Literal) object;
-							ValueResult vr = new ValueResult(objLiteral.getLabel(), pr);
+							ValueResult vr = new ValueResult(objLiteral.getLabel(), pr, selected.getContext());
 							pr.addValue(vr);
 							this._propertyResultModelHash.putResult(prop, pr);
 						}
 					}
 				} catch (InvalidResultSetException e) {
 					//
 				} catch (RepositoryException sue) {
 					System.err.println("Could not add to repository: " + sue);
 					return null;
 				}
 			}
 		}
 		return r;
 	}
 	
 	/**
 	 * Look in the source and ontologies model for a resource's label.
 	 * 
 	 * @param in Data source <code>Repository</code>
 	 * @param focus The <code>Resource</code> whose label is being sought
 	 * @param lens If the algorithm should look into lenses for labelling information or not
 	 * @return A <code>Title</code> label for the resource
 	 */
 	protected Title resolveLabel(Repository in, Resource focus, boolean lens, String label) {
 		if (null != label) return new Title(label);
 		
 		Resource focusType = (Resource) FresnelUtilities.getType(in, focus);
 		// this is ugly, but to not waste resources, it really needs the 'return' statements to
 		// return ASAP
 		LensMatchSet lenses = this._conf.getLensMatches().getMatch(focus);
 		LensMatchSet instanceLenses = this._conf.getInstanceLensMatches().getMatch(focus);
 		LensMatchSet classLenses = this._conf.getClassLensMatches().getMatch(focusType);
 
 		if (lens) {
 			if (null != lenses) {
 				// find label lens for resource
 				Iterator<Lens> instancesIt = lenses.getInstanceLenses().iterator();
 				while (instancesIt.hasNext()) {
 					Lens check = instancesIt.next();
 					if (check.hasPurpose(new Purpose(FresnelCore.labelLens))) {	
 						AggregateLabel labels = new AggregateLabel(applyLabelLens(check, in, focus, 0, MAXIMUM_LENS_DEPTH));
 						if (labels.getString().trim().equals("")) 
 							continue;
 						else 
 							return new Title(labels);
 					}
 				}
 				
 				// find label lens for resource's type
 				Iterator<Lens> classesIt = lenses.getClassLenses().iterator();
 				while (classesIt.hasNext()) {
 					Lens check = classesIt.next();
 					if (check.hasPurpose(new Purpose(FresnelCore.labelLens))) {
 						AggregateLabel labels = new AggregateLabel(applyLabelLens(check, in, focus, 0, MAXIMUM_LENS_DEPTH));
 						if (labels.getString().trim().equals("")) 
 							continue;
 						else
 							return new Title(labels);
 					}
 				}
 			}
 
 			if (null != instanceLenses) {
 				// find label lens for resource
 				Iterator<Lens> instancesIt = instanceLenses.getInstanceLenses().iterator();
 				while (instancesIt.hasNext()) {
 					Lens check = instancesIt.next();
 					if (check.hasPurpose(new Purpose(FresnelCore.labelLens))) {	
 						AggregateLabel labels = new AggregateLabel(applyLabelLens(check, in, focus, 0, MAXIMUM_LENS_DEPTH));
 						if (labels.getString().trim().equals("")) 
 							continue;
 						else 
 							return new Title(labels);
 					}
 				}
 			}
 			if (null != classLenses) {
 				// find label lens for resource
 				Iterator<Lens> classesIt = classLenses.getClassLenses().iterator();
 				while (classesIt.hasNext()) {
 					Lens check = classesIt.next();
 					if (check.hasPurpose(new Purpose(FresnelCore.labelLens))) {
 						AggregateLabel labels = new AggregateLabel(applyLabelLens(check, in, focus, 0, MAXIMUM_LENS_DEPTH));
 						if (labels.getString().trim().equals("")) 
 							continue;
 						else
 							return new Title(labels);
 					}
 				}
 			}
 		}
 		
 		Iterator<Statement> labelIt = this._conf.getOntologyLabels(focus, RDFS.LABEL);
 		while (labelIt.hasNext()) {
 			Statement labelSt = labelIt.next();
 			if (((Literal) labelSt.getObject()).getLabel().trim().equals(""))
 				continue;
 			else {
 				return new Title(((Literal) labelSt.getObject()).getLabel());
 			}
 		}
 		
 		labelIt = this._conf.getOntologyLabels(focus, new URIImpl(DCTITLE));
 		while (labelIt.hasNext()) {
 			Statement labelSt = labelIt.next();
 			if (((Literal) labelSt.getObject()).getLabel().trim().equals(""))
 				continue;
 			else {
 				return new Title(((Literal) labelSt.getObject()).getLabel());
 			}
 		}
+		
+		/* Get labels from the input repository */
+		try {
+			String resLabel = null;
+			boolean matchesPreferredLanguage = false;
+			
+			String[] knownLabels = {
+					"http://xmlns.com/foaf/0.1/name",
+					"http://www.w3.org/2000/01/rdf-schema#label",
+					"http://purl.org/dc/elements/1.1/title",
+					"http://usefulinc.com/ns/doap#name",
+					"http://www.geonames.org/ontology#name"
+			};
+			
+			RepositoryConnection conn = in.getConnection();
+
+			for (String labelPredicate : knownLabels) {
+				RepositoryResult<Statement> it = conn.getStatements(focus, new URIImpl(labelPredicate), (Value) null, true);
+				while (!matchesPreferredLanguage && it.hasNext()) {
+					Statement st = it.next();
+					if (st != null && st.getObject() instanceof Literal) {
+						Literal lit = ((Literal)st.getObject());
+						if (lit.getLanguage() != null && lit.getLanguage().equals(_langPref))
+							matchesPreferredLanguage = true;
+						
+						/* Take the first label, or the first one in the preferred language */
+						if (resLabel == null || matchesPreferredLanguage)
+							resLabel = lit.getLabel();						
+					}
+				}
+
+				it.close();
+				if (matchesPreferredLanguage)
+					break;
+			}
+
+			conn.close();
+			
+			if (resLabel != null)
+				return new Title(resLabel);
+		}
+		catch (RepositoryException e) {
+			e.printStackTrace();
+		}
 
 		if (!(focus instanceof BNode)) {
 			// try to truncate the URI?
 			return new Title(((URI) focus).toString(), true);
 		} else
-			return new Title("(anonymous node)", true);
+			return new Title(((BNode)focus).getID(), true);			//return new Title("(anonymous node)", true);
 	}
 	
 	/**
 	 * Default behavior for label resolution is to look into label lenses.
 	 * 
 	 * @param in Data source <code>Repository</code>
 	 * @param focus The <code>Resource</code> whose label is being sought
 	 * @param lens <code>boolean</code> indicator of whether to use lenses or not.
 	 * @return A <code>Title</code> label for the resource
 	 */
 	protected Title resolveLabel(Repository in, Resource focus, boolean lens) {
 		return resolveLabel(in, focus, lens, null);
 	}
 	
 	/**
 	 * Default behavior for label resolution is to look into label lenses.
 	 * 
 	 * @param in The data <code>Repository</code>
 	 * @param focus The <code>Resource</code> whose label is being sought
 	 * @return A <code>Title</code> label for the resource
 	 */
 	protected Title resolveLabel(Repository in, Resource focus) {
 		return resolveLabel(in, focus, true, null);
 	}
 	
 	/**
 	 * Resolve the property sets to a final ordered list of what will show up.
 	 * 
 	 * @param lens The <code>Lens</code> with selection information
 	 * @param in The <code>Repository</code> with all the data
 	 * @param focus The <code>Resource</code> to resolve
 	 * @return A <code>PropertySet</code> of properties to select.
 	 */
 	protected PropertySet resolvePropertySet(Lens lens, Repository in, Resource focus) {
 		PropertySet properties = new PropertySet();
 		PropertySet hide = lens.getHideProperties();
 		PropertySet show = lens.getShowProperties();
 		if (show.seenAllProperties()) {
 			try {
 				RepositoryConnection conn = in.getConnection();
-                RepositoryResult<Statement> focusProperties = conn.getStatements(focus, (URI) null, (Value) null, false);
+                RepositoryResult<Statement> focusProperties = conn.getStatements(focus, (URI) null, (Value) null, true);
+                RepositoryResult<Statement> focusPropertiesInverse = conn.getStatements(null, (URI) null, focus, true);
 				Iterator<ISelector> showPSI = show.iterator();
 				while (showPSI.hasNext()) {
 					ISelector selector = showPSI.next();
 					if (AllPropertiesSelector.isAllProperties(selector)) {
 						// get all properties and check if in hidden properties
-						while (focusProperties.hasNext()) {
-							URI maybeAdd = FresnelUtilities.dupURI((focusProperties.next()).getPredicate());
+						while (focusProperties.hasNext() || focusPropertiesInverse.hasNext()) {
+							Statement st = (focusProperties.hasNext() ? focusProperties.next() : focusPropertiesInverse.next());
+							URI maybeAdd = FresnelUtilities.dupURI(st.getPredicate());
 							PropertySelector maybeAddSelector = new PropertySelector(maybeAdd);
 							if (hide.size() > 0) {
 								if (!hide.containsSelector(maybeAddSelector)
 										&& !properties.containsSelector(maybeAddSelector)) {
 									properties.addSelector(maybeAddSelector);
 								}
 							} else {
 								if (!properties.containsSelector(maybeAddSelector)) {
 									properties.addSelector(maybeAddSelector);
 								}
 							}
 						}
 					} else {
 						if (selector instanceof PropertySelector) {
 							if (!properties.containsSelector((PropertySelector) selector)) {
 								properties.addSelector(selector);
 							}
 						} else {
 							properties.addSelector(selector);						
 						}
 					}
 				}
 				focusProperties.close();
+				focusPropertiesInverse.close();
 				conn.close();
 			} catch (RepositoryException e) {
 				// TODO: how to handle this exception
 			}
 		} else {
 			properties = show;
 		}
 		return properties;
 	}
 
 	/**
 	 * Apply formatting to a resource.
 	 * 
 	 * @param grouping Use from this <code>Group</code>
 	 * @param format Use this <code>Format</coe>
 	 * @param focus On this <code>Resource</code>
 	 */
 	protected void applyFormat(Group grouping, Format format, Resource focus) {
 		// lookup the results that use this resource focus and apply this to all of them
 		Iterator<Result> it = this._resultModelHash.getResultIterator(focus);
 		while (it.hasNext()) {
 			Result r = (Result) it.next();
 
 			// get any group-scope styling
 			if (grouping.getResourceStyle().size() > 0) {
 				Iterator<Style> sit = grouping.getResourceStyle().iterator();
 				String classes = "";
 				while(sit.hasNext()) {
 					// N.B.: if styles were ever expanded to be more than strings, here would
 					// be a good place to make that adaptation
 					classes += sit.next().getString();
 				}
 				r.setStyles(classes.trim());
 			}
 			
 			// get any group-scope content
 			if (grouping.getResourceFormat().size() > 0) {
 				// there should only be one FormatDescription...
 				Iterator<FormatDescription> fdit = grouping.getResourceFormat().iterator();
 				if (fdit.hasNext()) {
 					r.setContents(fdit.next().getContentSet());
 				}
 			}
 			
 			// process format argument for style
 			if (format.getResourceStyle().size() > 0) {
 				Iterator<Style> sit = format.getResourceStyle().iterator();
 				String classes = r.getStyles() + " ";
 				while(sit.hasNext()) {
 					// N.B.: if styles were ever expanded to be more than strings, here would
 					// be a good place to make that adaptation
 					classes += sit.next().getString();
 				}
 				r.setStyles(classes.trim());
 			}
 			
 			// process format argument for content
 			if (format.getResourceFormat().size() > 0) {
 				// there should only be one FormatDescription...
 				Iterator<FormatDescription> fdit = format.getResourceFormat().iterator();
 				if (fdit.hasNext()) {
 					r.setContents(fdit.next().getContentSet());
 				}
 			}
 		}
 	}
 	
 	/**
 	 * Apply formatting to a property result.
 	 * 
 	 * @param grouping Use from this <code>Group</code>
 	 * @param format Use this <code>Format</code>
 	 * @param focus Apply to this property <code>URI</code>
 	 */
 	protected void applyFormat(Group grouping, Format format, URI focus, Repository in) {
 		Iterator<PropertyResult> it = this._propertyResultModelHash.getResultIterator(focus);
 		while (it.hasNext()) {
 			PropertyResult r = (PropertyResult) it.next();
 
 			// get any group-global styling
 			if (grouping.getPropertyStyle().size() > 0) {
 				Iterator<Style> sit = grouping.getPropertyStyle().iterator();
 				String classes = "";
 				while(sit.hasNext()) {
 					// N.B.: if styles were ever expanded to be more than strings, here would
 					// be a good place to make that adaptation
 					classes += sit.next().getString() + " ";
 				}
 				r.setStyles(classes.trim());
 			}
 
 			// get any group-scope content
 			if (grouping.getPropertyFormat().size() > 0) {
 				// there should only be one FormatDescription...
 				Iterator<FormatDescription> fdit = grouping.getPropertyFormat().iterator();
 				if (fdit.hasNext()) {
 					r.setContents(fdit.next().getContentSet());
 				}
 			}
 
 			// get any lens-specified (property description) formatting, use instead of
 			// passed in format if necessary
 			Lens parent = r.getParent().getLens();
 			Iterator<ISelector> psi = parent.getShowProperties().iterator();
 			while (psi.hasNext()) {
 				ISelector check = psi.next();
 				if (check.canSelect(in, r.getParent().getOrigin(), r.getOrigin())) {
 					if (check instanceof PropertyDescription) {
 						PropertyDescription pd = (PropertyDescription) check;
 						if (pd.isGroupUse()) {
 							// pick which format to use...
 							Group groupFormats = (Group) pd.getUse();
 							Iterator<Format> fi = groupFormats.getFormats().iterator();
 							while (fi.hasNext()) {
 								Format potential = fi.next();
 								for (Iterator<ISelector> di = potential.getDomainSet().iterator(); di.hasNext(); ) {
 									ISelector potentialCheck = di.next();
 									if (potentialCheck.canSelect(getModel(), r.getParent().getOrigin(), r.getOrigin())) {
 										format = potential;
 										break;
 									}
 								}
 							}
 						} else {
 							if (null != pd.getUse()) {
 								format = (Format) pd.getUse();
 								break;
 							}
 						}
 					}
 				}
 			}
 
 			// process format argument for style
 			if (null != format.getPropertyStyle()) {
 				Iterator<Style> sit = format.getPropertyStyle().iterator();
 				String classes = (r.getStyles() != null) ? r.getStyles() + " " : "";
 				while(sit.hasNext()) {
 					// N.B.: if styles were ever expanded to be more than strings, here would
 					// be a good place to make that adaptation
 					classes += sit.next().getString() + " ";
 				}
 				r.setStyles(classes.trim());
 			}
 			
 			// process format argument for content
 			if (null != format.getPropertyFormat()) {
 				// there should only be one FormatDescription...
 				Iterator<FormatDescription> fdit = format.getPropertyFormat().iterator();
 				if (fdit.hasNext()) {
 					r.setContents(fdit.next().getContentSet());
 				}
 			}
 						
 			// call label and value format using the right format
 			applyFormat(grouping, format, r, LABEL, in);
 			applyFormat(grouping, format, r, VALUE, in);
 		}
 	}
 
 	/**
 	 * Apply formatting to property labels.
 	 * 
 	 * @param grouping Use those found in this <code>Group</code>
 	 * @param format Use this <code>Format</code>
 	 * @param pr Associated with this <code>PropertyResult</code>
 	 */
 	protected void applyLabelFormat(Group grouping, Format format, PropertyResult pr) {
 		// get any group-global styling
 		if (grouping.getLabelStyle().size() > 0) {
 			Iterator<Style> it = grouping.getLabelStyle().iterator();
 			String classes = "";
 			while(it.hasNext()) {
 				// N.B.: if styles were ever expanded to be more than strings, here would
 				// be a good place to make that adaptation
 				classes += it.next().getString() + " ";
 			}
 			pr.setLabelStyles(classes.trim());
 		}
 		
 		// get any group-scope content
 		if (grouping.getLabelFormat().size() > 0) {
 			// there should only be one FormatDescription...
 			Iterator<FormatDescription> fdit = grouping.getLabelFormat().iterator();
 			if (fdit.hasNext()) {
 				pr.setLabelContents(fdit.next().getContentSet());
 			}
 		}
 		
 		// process format argument for style
 		if (null != format.getLabelStyle()) {
 			Iterator<Style> sit = format.getLabelStyle().iterator();
 			String classes = (pr.getLabelStyles() != null) ? pr.getLabelStyles() + " " : "";
 			while(sit.hasNext()) {
 				// N.B.: if styles were ever expanded to be more than strings, here would
 				// be a good place to make that adaptation
 				classes += sit.next().getString() + " ";
 			}
 			pr.setLabelStyles(classes.trim());
 		}
Index: trunk/simile-fresnel/src/main/java/edu/mit/simile/fresnel/results/ValueResultSet.java
===================================================================
--- trunk/simile-fresnel/src/main/java/edu/mit/simile/fresnel/results/ValueResultSet.java (revision 2)
+++ trunk/simile-fresnel/src/main/java/edu/mit/simile/fresnel/results/ValueResultSet.java (revision 45)
@@ -1,115 +1,196 @@
 package edu.mit.simile.fresnel.results;
 
+import info.aduna.iteration.Iterations;
+
+import java.util.ArrayList;
 import java.util.Iterator;
+import java.util.List;
 
+import org.openrdf.model.Resource;
+import org.openrdf.model.Statement;
+import org.openrdf.model.vocabulary.OWL;
+import org.openrdf.repository.Repository;
+import org.openrdf.repository.RepositoryConnection;
+import org.openrdf.repository.RepositoryException;
+import org.openrdf.repository.RepositoryResult;
 import org.w3c.dom.Document;
 import org.w3c.dom.Element;
 
 import edu.mit.simile.fresnel.util.WrappedVector;
 
 /**
  * Set of ValueResults.
  * 
  * @author ryanlee
  */
 public class ValueResultSet extends WrappedVector<ValueResult> implements ResultConstants {
 	/**
 	 * Contents which may apply to the overall set of values.
 	 */
 	private ContentSet _contents;
 	
 	/**
 	 * Base constructor
 	 */
 	public ValueResultSet() {
 		super();
 		this._contents = new ContentSet();
 	}
 	
 	/**
 	 * Returns the set of possible configured contents
 	 * 
 	 * @return A <code>ContentSet</code>
 	 */
 	public ContentSet getContents() {
 		return this._contents;
 	}
 	
 	/**
 	 * Sets the contents for the value result set
 	 * 
 	 * @param contents A <code>ContentSet</code>
 	 */
 	public void setContents(ContentSet contents) {
 		this._contents = contents;
 	}
 	
 	/**
 	 * Returns a ValueResultIterator instead of a normal iterator.
 	 * 
 	 * @return A <code>ValueResultIterator</code>
 	 */
 	public Iterator<ValueResult> valueResultIterator() {
 		return this._base.iterator();
 	}
 	
 	/**
 	 * Adds a value result to the existing set.
 	 * 
 	 * @param value A <code>ValueResult</code>
+	 * @param in    Data repository
+	 * @return Success or failure
+	 */
+	public boolean addValueResult(ValueResult value, Repository in) {
+		if (value.getResult() != null) {
+			/* Value is a resource */
+			RepositoryConnection conn = null;
+			try {
+				conn = in.getConnection();
+				
+				for (ValueResult existingValue : this._base) {
+					if (existingValue.getResult() == null)
+						continue;
+					
+					/* If the same value already exists, don't add it but just provide the origin */
+					if (existingValue.getResult().getOrigin().equals(value.getResult().getOrigin())) {
+						existingValue.addSources(value.getSources());
+						return true;
+					}
+					
+					/* If the value is owl:sameAs, don't add it but provide an alias */
+					if (existingValue.getPossibleAliases().contains(value.getResult().getOrigin())) {
+						existingValue.addAlias(value.getResult().getOrigin());
+						return true;
+					}
+				}	
+				
+				/* Didn't return, so value will be added. Enhance it with possible aliases. */ 
+				RepositoryResult<Statement> result = conn.getStatements(value.getResult().getOrigin(), OWL.SAMEAS, null, true);
+				RepositoryResult<Statement> inverseResult = conn.getStatements(null, OWL.SAMEAS, value.getResult().getOrigin(), true);
+				
+				while (result.hasNext() || inverseResult.hasNext()) {
+					boolean regular = result.hasNext();
+					Statement st = (regular ? result.next() : inverseResult.next());
+					value.addPossibleAlias(regular ? (Resource)st.getObject() : st.getSubject());
+				}
+			}
+			catch (RepositoryException e) {
+				e.printStackTrace();
+			}
+			finally {
+				try {
+					if (conn != null)
+							conn.close();
+				}
+				catch (RepositoryException e) {
+					e.printStackTrace();
+				}
+			}
+			
+
+		}
+		else {
+			/* It's a literal. If the same value already exists, don't add it but just provide the origin */
+			for (ValueResult existingValue : this._base) {
+				if ((existingValue.getValue() != null && value.getValue() != null && existingValue.getValue().equals(value.getValue()))
+						|| (existingValue.getTitle() != null && value.getTitle() != null && existingValue.getTitle().getString().equals(value.getTitle().getString()))) {
+					existingValue.addSources(value.getSources());
+					return true;
+				}
+			}
+		}
+		
+		return this._base.add(value);
+	}
+	
+	/**
+	 * Adds a value result to the existing set.
+	 * 
+	 * @param value A <code>ValueResult</code>
 	 * @return Success or failure
 	 */
 	public boolean addValueResult(ValueResult value) {
-		return this._base.add(value);
+		return addValueResult(value, null);
 	}
 	
 	/**
 	 * Removes a value result from the existing set.
 	 * 
 	 * @param value A <code>ValueResult</code>
 	 * @return Success or failure
 	 */
 	public boolean removeValueResult(ValueResult value) {
 		return this._base.remove(value);
 	}
 	
 	/**
 	 * Add all elements from a value result set into this one.
 	 * 
 	 * @param arg0 A <code>ValueResultSet</code>
 	 * @return Success or failure
 	 */
 	public boolean addValueResultSet(ValueResultSet arg0) {
 		return this._base.addAll(arg0._base);
 	}
 	
 	/**
 	 * Replace WrappedVector contains method to do specific <code>ValueResult</code>
 	 * equality checking.
 	 * 
 	 * @param value The <code>ValueResult</code> component to check
 	 * @return True if contained in set, false if not.
 	 */
 	public boolean contains(ValueResult value) {
 		for (Iterator<ValueResult> it = this.valueResultIterator(); it.hasNext(); ) {
 			if (value.equals(it.next())) return true;
 		}
 		return false;
 	}
 	
 	/**
 	 * Render the set as part of a DOM.
 	 * 
 	 * @param doc A <code>Document</code> for creating elements.
 	 * @return An <code>Element</code>, e.g.: &lt;values&gt; ... &lt;/values&gt;
 	 */
 	public Element render(Document doc) {
 		Element out = doc.createElementNS(INTERMEDIATE_NS, "values");
 		Element content = getContents().render(doc); 
 		if (content.hasChildNodes()) out.appendChild(content);
 		for(Iterator<ValueResult> it = valueResultIterator(); it.hasNext(); ) {
 			out.appendChild(it.next().render(doc));
 		}
 		return out;
 	}
 }
Index: trunk/simile-fresnel/src/main/java/edu/mit/simile/fresnel/results/ValueResult.java
===================================================================
--- trunk/simile-fresnel/src/main/java/edu/mit/simile/fresnel/results/ValueResult.java (revision 2)
+++ trunk/simile-fresnel/src/main/java/edu/mit/simile/fresnel/results/ValueResult.java (revision 45)
@@ -1,178 +1,256 @@
 package edu.mit.simile.fresnel.results;
 
+import java.util.ArrayList;
+import java.util.List;
+
 import org.openrdf.model.Literal;
+import org.openrdf.model.Resource;
 
 import org.w3c.dom.Document;
 import org.w3c.dom.Element;
 
 /**
  * Statement object results as selected and formatted by Fresnel lenses and formats.
  * 
  * @author ryanlee
  */
 public class ValueResult implements ResultConstants {
 	/**
 	 * If the object is a resource, the corresponding result
 	 */
 	private Result _base;
 	/**
 	 * If the object is a literal, its value
 	 */
 	private Literal _value;
 	/**
 	 * A human-friendly title for the object
 	 */
 	private Title _title;
 	/**
 	 * How to render the output
 	 */
 	private String _kind;
 	/**
 	 * Styling for the object
 	 */
 	private String _styles;
 	/**
 	 * The property that points to this object
 	 */
 	private PropertyResult _parent;
+	/**
+	 * Source URIs for the value's triple
+	 */	
+	private List<Resource> _sources;
+	/**
+	 * Alias URIs that were added (if the object is a resource)
+	 */	
+	private List<Resource> _aliases;
+	/**
+	 * All possible alias URIs
+	 */	
+	private List<Resource> _possibleAliases;
+	
+	private void init() {
+		this._base = null;
+		this._value = null;
+		this._parent = null;
+		this._sources = new ArrayList<Resource>();
+		this._aliases = new ArrayList<Resource>();
+		this._possibleAliases = new ArrayList<Resource>();		
+	}
 	
 	/**
 	 * Constructor if the value is a resource
 	 * 
 	 * @param base Resource <code>Result</code>
 	 * @param parent Parent <code>PropertyResult</code>
 	 */
-	public ValueResult(Result base, PropertyResult parent) {
+	public ValueResult(Result base, PropertyResult parent, Resource source) {
+		init();
 		this._base = base;
-		this._value = null;
 		this._parent = parent;
-	}
+		addSource(source);
+	}	
 	
 	/**
 	 * Constructor if the value is a literal
 	 * 
 	 * @param lit Value <code>Literal</code>
 	 * @param parent Parent <code>PropertyResult</code>
 	 */
-	public ValueResult(Literal lit, PropertyResult parent) {
-		this._base = null;
+	public ValueResult(Literal lit, PropertyResult parent, Resource source) {
+		init();
 		this._value = lit;
 		this._title = new Title(lit.getLabel());
 		this._parent = parent;
+		addSource(source);
 	}
 
 	/**
 	 * Constructor if the value is a literal given as a string
 	 * 
 	 * @param lit Value <code>String</code>
 	 * @param parent Parent <code>PropertyResult</code>
 	 */
-	public ValueResult(String lit, PropertyResult parent) {
-		this._base = null;
-		this._value = null;
+	public ValueResult(String lit, PropertyResult parent, Resource source) {
+		init();
 		this._title = new Title(lit);
 		this._parent = parent;
+		addSource(source);
 	}
 	
 	/**
 	 * Retrieves the parent property pointing to this value
 	 * 
 	 * @return A <code>PropertyResult</code>
 	 */
 	public PropertyResult getParent() {
 		return this._parent;
 	}
 	
 	/**
 	 * Whether the value is a resource or not.
 	 * 
 	 * @return True if a resource, false if a literal
 	 */
 	public boolean isResource() {
 		return (null != this._base);
 	}
 	
 	/**
 	 * Retrieves the resource's result if the value is a resource
 	 * 
 	 * @return A <code>Result</code>
 	 */
 	public Result getResult() {
 		return this._base;
 	}
 	
 	/**
 	 * Retrieves the literal if the value is a literal
 	 * 
 	 * @return A <code>Literal</code>
 	 */
 	public Literal getValue() {
 		return this._value;
 	}
 	
 	/**
 	 * Retrieves the title of the value
 	 * 
 	 * @return A <code>Title</code>
 	 */
 	public Title getTitle() {
 		return this._title;
 	}
 	
 	/**
 	 * Retrieves style classes for the value
 	 * 
 	 * @return A <code>String</code>
 	 */
 	public String getStyles() {
 		return this._styles;
 	}
 	
 	/**
 	 * Retrieves the display type for the value
 	 * 
 	 * @return A <code>String</code> representation
 	 */
 	public String getOutputType() {
 		return this._kind;
 	}
 	
 	/**
+	 * Retrieves the sources for the value
+	 * 
+	 * @return A <code>URI</code> representation
+	 */
+	public List<Resource> getSources() {
+		return this._sources;
+	}
+	
+	public void addSource(Resource source) {
+		if (!this._sources.contains(source))
+			this._sources.add(source);
+	}
+	
+	public void addSources(List<Resource> sources) {
+		for (Resource source : sources)
+			addSource(source);
+	}
+	
+	public void addAlias(Resource alias) {
+		if (!this._aliases.contains(alias))
+			this._aliases.add(alias);
+	}
+	
+	public List<Resource> getPossibleAliases() {
+		return this._possibleAliases;
+	}
+	
+	public void addPossibleAlias(Resource alias) {
+		if (!this._possibleAliases.contains(alias))
+			this._possibleAliases.add(alias);
+	}	
+	
+	/**
 	 * Sets style classes for the value.
 	 * 
 	 * @param styles A <code>String</code>
 	 */
 	public void setStyles(String styles) {
 		this._styles = styles;
 	}
+	
 	
 	/**
 	 * Sets the output type for the value.
 	 * 
 	 * @param kind A <code>String</code>
 	 */
 	public void setOutputType(String kind) {
 		this._kind = kind;
 	}
 	
 	/**
 	 * Renders the value to an element in the Fresnel XML tree output.
 	 * 
 	 * @param doc A <code>Document</code> for creating elements
 	 * @return An <code>Element</code> representation of a value, e.g.:
 	 *         &lt;value&gt;&lt;title&gt; ... &lt;/title&gt; ... &lt;/value&gt;
 	 */
 	public Element render(Document doc) {
 		Element out = doc.createElementNS(INTERMEDIATE_NS, "value");
 		if (getStyles() != null) out.setAttribute("class", getStyles());
 		if (getOutputType() != null) out.setAttribute("output-type", getOutputType());
 		if (!isResource()) {
 			Element title = doc.createElementNS(INTERMEDIATE_NS, "title");
 			title.appendChild(doc.createTextNode(getTitle().getString()));
 			out.appendChild(title);
 		} else {
 			out.appendChild(getResult().render(doc));
 		}
+		
+		for (Resource sourceResource : this._sources) {
+			Element sourceURI = doc.createElementNS(INTERMEDIATE_NS, "sourceURI");
+			sourceURI.appendChild(doc.createTextNode(sourceResource.toString()));
+			
+			Element source = doc.createElementNS(INTERMEDIATE_NS, "source");
+			source.appendChild(sourceURI);
+			
+			out.appendChild(source);
+		}
+		
+		for (Resource aliasResource : this._aliases) {
+			Element aliasURI = doc.createElementNS(INTERMEDIATE_NS, "alias");
+			aliasURI.appendChild(doc.createTextNode(aliasResource.toString()));
+			
+			out.appendChild(aliasURI);
+		}		
 		return out;
 	}
 }
Index: trunk/simile-fresnel/src/main/java/edu/mit/simile/fresnel/results/Result.java
===================================================================
--- trunk/simile-fresnel/src/main/java/edu/mit/simile/fresnel/results/Result.java (revision 2)
+++ trunk/simile-fresnel/src/main/java/edu/mit/simile/fresnel/results/Result.java (revision 44)
@@ -1,272 +1,275 @@
 package edu.mit.simile.fresnel.results;
 
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.Set;
 import java.util.Vector;
 
 import org.openrdf.model.BNode;
 import org.openrdf.model.Resource;
 import org.openrdf.model.Statement;
 import org.openrdf.model.URI;
 import org.openrdf.model.impl.StatementImpl;
 import org.openrdf.model.vocabulary.RDF;
 import org.openrdf.repository.Repository;
 import org.openrdf.repository.RepositoryConnection;
 import org.openrdf.repository.RepositoryException;
 import org.openrdf.repository.RepositoryResult;
 import org.w3c.dom.Document;
 import org.w3c.dom.Element;
 
 import edu.mit.simile.fresnel.FresnelUtilities;
 import edu.mit.simile.fresnel.configuration.Group;
 import edu.mit.simile.fresnel.selection.Lens;
 
 /**
  * Lens selection and formatting result for a resource.
  * 
  * @author ryanlee
  */
 public class Result implements ResultConstants {
 	/**
 	 * Identifies the resource
 	 */
 	private Resource _origin;
 	/**
 	 * Label for the resource
 	 */
 	private Title _title;
 	/**
 	 * Content formatting
 	 */
 	private ContentSet _contents;
 	/**
 	 * Styling classes
 	 */
 	private String _styles;
 	/**
 	 * Lens used to select data
 	 */
 	private Lens _lens;
 	/**
 	 * Group lens belongs to
 	 */
 	private Group _group;
 	/**
 	 * Set of properties's results associated with this resource
 	 */
 	private PropertyResultSet _properties;
 	/**
 	 * Set of rdf:type values associated with this resource
 	 */
 	private Set<Resource> _types;
 	
 	/**
 	 * Constructor based on resource with lens and group used to select it
 	 * 
 	 * @param focus The <code>Resource</code> this result is for
 	 * @param group The <code>Group</code> of Fresnel configurations used to select and format it
 	 * @param lens The <code>Lens</code> used to select data
 	 */
 	public Result(Resource focus, Group group, Lens lens, Repository in) {
 		this._origin = focus;
 		this._properties = new PropertyResultSet();
 		this._contents = new ContentSet();
 		this._lens = lens;
 		this._group = group;
 		this._types = new HashSet<Resource>();
 		setTypes(in);
 	}
 	
 	/**
 	 * The identifying resource
 	 * 
 	 * @return Identifying <code>Resource</code>
 	 */
 	public Resource getOrigin() {
 		return this._origin;
 	}
 	
 	/**
 	 * The lens used to select this resource and its data.
 	 * 
 	 * @return Selecting <code>Lens</code>
 	 */
 	public Lens getLens() {
 		return this._lens;
 	}
 	
 	/**
 	 * The group the lens and subsequent formatting belongs to
 	 * 
 	 * @return Parent <code>Group</code>
 	 */
 	public Group getGroup() {
 		return this._group;
 	}
 	
 	/**
 	 * A container for a human friendly label for the result
 	 * 
 	 * @return A <code>Title</code>
 	 */
 	public Title getTitle() {
 		return this._title;
 	}
 	
 	/**
 	 * Retrieves the resource for this result as a URI.
 	 * 
 	 * @return The resource's <code>URI</code>
 	 */
 	public String getURI() {
+		return this._origin.toString();
 		// TODO: may not be a URI...what then?
-		return ((URI) this._origin).toString();
+/*		if ((this._origin instanceof BNode))
+			return ((URI) this._origin).toString();
+		else
+			return ((URI) this._origin).toString();*/
 	}
 	
 	/**
 	 * Retrieves formatting for the resource.
 	 * 
 	 * @return A <code>ContentSet</code>
 	 */
 	public ContentSet getContents() {
 		return this._contents;
 	}
 	
 	/**
 	 * Retrieves styling classes for the resource.
 	 * 
 	 * @return A <code>String</code>
 	 */
 	public String getStyles() {
 		return this._styles;
 	}
 	
 	/**
 	 * Retrieves the properties' results associated with the resource
 	 * 
 	 * @return A <code>PropertyResultSet</code>
 	 */
 	public PropertyResultSet getProperties() {
 		return this._properties;
 	}
 	
 	/**
 	 * Fetches rdf:type values for the resource
 	 * 
 	 * @return A <code>RdfTypeSet</code>
 	 */
 	public Set<Resource> getTypes() {
 		return this._types;
 	}
 	
 	/**
 	 * Return type statements as a statement iterator.
 	 * 
 	 * @return A <code>StatementIterator</code>.
 	 */
 	public Iterator<Statement> getTypesStatements() {
 		Vector<Statement> out = new Vector<Statement>();
 		for (Resource r : getTypes()) {
 			out.add(new StatementImpl(getOrigin(), RDF.TYPE, r));			
 		}
 		return out.iterator();
 	}
 	
 	/**
 	 * Sets rdf:type values for the resource
 	 * 
 	 * @param in Data <code>Repository</code>
 	 */
 	public void setTypes(Repository in) {
 		try {
 			RepositoryConnection conn = in.getConnection();
-            RepositoryResult<Statement> si = conn.getStatements(getOrigin(), RDF.TYPE, null, false);
+            RepositoryResult<Statement> si = conn.getStatements(getOrigin(), RDF.TYPE, null, true);
 			while (si.hasNext()) {
 				Statement s = si.next();
 				this._types.add((Resource) FresnelUtilities.dupValue(s.getObject()));
 			}
 			si.close();
 			conn.close();
 		} catch (RepositoryException e) {
 			// TODO: how to handle this exception
 		}
 	}
 	
 	/**
 	 * Sets the human friendly title.
 	 * 
 	 * @param title A <code>Title</code>
 	 */
 	public void setTitle(Title title) {
 		this._title = title;
 	}
 	
 	/**
 	 * Sets the style class.
 	 * 
 	 * @param style A <code>String</code>
 	 */
 	public void setStyles(String style) {
 		this._styles = style;
 	}
 	
 	/**
 	 * Sets the formatting for the result.
 	 * 
 	 * @param contents A <code>ContentSet</code>
 	 */
 	public void setContents(ContentSet contents) {
 		this._contents = contents;
 	}
 	
 	/**
 	 * Adds a property result to the existing set of property results
 	 * 
 	 * @param prop A <code>PropertyResult</code>
 	 */
 	public void addProperty(PropertyResult prop) {
 		this._properties.addPropertyResult(prop, this);
 	}
 	
 	/**
 	 * Renders the result and everything attached to it to an element in
 	 * the Fresnel XML tree output.
 	 * 
 	 * @param doc A <code>Document</code> for creating elements.
 	 * @return An <code>Element</code> for the result, e.g.:
 	 *         &lt;resource&gt;&lt;title&gt;I'm a result&lt/title&gt; ... &lt;/resource&gt;
 	 */
 	public Element render(Document doc) {
 		Element out = doc.createElementNS(INTERMEDIATE_NS, "resource");
 		out.setAttribute("class", getStyles());
-		if (!(getOrigin() instanceof BNode))
-			out.setAttribute("uri", getURI());
+		out.setAttribute("uri", getURI());
 		if (getGroup().hasCssLinks()) {
 			for (Iterator linkIt = getGroup().getCssLinks().iterator(); linkIt.hasNext(); ) {
 				Element link = doc.createElementNS(INTERMEDIATE_NS, "link");
 				link.appendChild(doc.createTextNode((String) linkIt.next()));
 				out.appendChild(link);
 			}
 		}
 		Element title = doc.createElementNS(INTERMEDIATE_NS, "title");
 		if (null != getTitle())
 			title.appendChild(doc.createTextNode(getTitle().getString()));
 		else
 			title.appendChild(doc.createTextNode("(untitled)"));
 		out.appendChild(title);
 		Element content = getContents().render(doc);
 		if (content.hasChildNodes()) out.appendChild(content);
 		for(Iterator<PropertyResult> it = getProperties().propertyResultIterator(); it.hasNext() ; ) {
 			PropertyResult pr = it.next();
 			Element prop = null;
 			if (pr.isInModel())
 				prop = pr.render(doc);
 			else
 				prop = ((NoSuchPropertyResult) pr).render(doc);
 			if (null != prop)
 				out.appendChild(prop);
 		}
 		return out;
 	}
 }
Index: trunk/simile-fresnel/src/main/java/edu/mit/simile/fresnel/facets/FacetSet.java
===================================================================
--- trunk/simile-fresnel/src/main/java/edu/mit/simile/fresnel/facets/FacetSet.java (revision 2)
+++ trunk/simile-fresnel/src/main/java/edu/mit/simile/fresnel/facets/FacetSet.java (revision 33)
@@ -2,249 +2,249 @@
 
 import java.util.Iterator;
 import java.util.Vector;
 
 import org.openrdf.model.Resource;
 import org.openrdf.model.Statement;
 import org.openrdf.model.Value;
 import org.openrdf.repository.Repository;
 import org.openrdf.repository.RepositoryConnection;
 import org.openrdf.repository.RepositoryException;
 import org.openrdf.repository.RepositoryResult;
 
 import edu.mit.simile.fresnel.selection.ParsingException;
 import edu.mit.simile.fresnel.selection.UnresolvableException;
 import edu.mit.simile.fresnel.util.RDFList;
 import edu.mit.simile.fresnel.util.WrappedVector;
 import edu.mit.simile.vocabularies.Facets;
 
 /**
  * Container for facets, reflecting the fresnel:FacetSet member of the fresnel faceting extension
  * vocabulary.
  * 
  * @author ryanlee
  */
 public class FacetSet extends WrappedVector<Facet> {
 	/**
 	 * Set of types these facets can be used with.
 	 */
 	protected TypeSet _forTypes;
 	
 	/**
 	 * Resource identifying this FacetSet.
 	 */
 	protected Resource _identifier;
 	
 	/**
 	 * Set of facets to hide.
 	 */
 	protected Vector<Facet> _hides;
 	
 	/**
 	 * Resource defined in the schema.
 	 */
 	protected static final Resource _schemaResource = Facets.FacetSet;
 	
 	/**
 	 * Constructor for initializing wrapped vector.
 	 */
 	public FacetSet() {
 		super();
 		this._hides = new Vector<Facet>();
 	}
 	
 	/**
 	 * Constructor based on the resource identifying the facet set.
 	 * 
 	 * @param id A <code>Resource</code>
 	 */
 	public FacetSet(Resource id) {
 		this();
 		this._identifier = id;
 	}
 	
 	/**
 	 * Retrieves the resource identifying this facet set.
 	 * 
 	 * @return A <code>Resource</code>
 	 */
 	public Resource getIdentifier() {
 		return this._identifier;
 	}
 	
 	/**
 	 * Retrieves an iterator through the set of types this facet set can be used for.
 	 * 
 	 * @return A <code>TypeIterator</code>
 	 */
 	public Iterator<Resource> getForTypes() {
 		return this._forTypes.iterator();
 	}
 	
 	/**
 	 * Sets the set of types this facet set can be use for.
 	 * 
 	 * @param types A <code>TypeSet</code>
 	 */
 	public void setForTypes(TypeSet types) {
 		this._forTypes = types;
 	}
 	
 	/**
 	 * Returns a FacetIterator (instead of a normal iterator) through this set of facets.
 	 * 
 	 * @return A <code>FacetIterator</code>
 	 */
 	public Iterator<Facet> facetIterator() {
 		return this._base.iterator();
 	}
 	
 	/**
 	 * Returns a FacetIterator through the hidden facets.
 	 * 
 	 * @return A <code>FacetIterator</code>
 	 */
 	public Iterator<Facet> hideIterator() {
 		return this._hides.iterator();
 	}
 	
 	/**
 	 * Check if this facet set's type set is actually intended to be used for all types
 	 * and not just a specific set.
 	 * 
 	 * @return True if for all types, false otherwise.
 	 */
 	public boolean isForAll() {
 		return this._forTypes.isForAll();
 	}
 	
 	/**
 	 * Adds a facet to the existing set.
 	 * 
 	 * @param facet A <code>Facet</code>
 	 * @return Success or failure
 	 */
 	public boolean addFacet(Facet facet) {
 		return this._base.add(facet);
 	}
 	
 	/**
 	 * Adds a facet to the hidden facet list.
 	 * 
 	 * @param facet A <code>Facet</code>
 	 * @return Sucess or failure
 	 */
 	public boolean addHide(Facet facet) {
 		return this._hides.add(facet);
 	}
 	
 	/**
 	 * Removes a facet from the existing set.
 	 * 
 	 * @param facet A <code>Facet</code>
 	 * @return Success or failure
 	 */
 	public boolean removeFacet(Facet facet) {
 		return this._base.remove(facet);
 	}
 	
 	/**
 	 * Removes a hidden facet from the existing set.
 	 * 
 	 * @param facet A <code>Facet</code>
 	 * @return Success or failure
 	 */
 	public boolean removeHide(Facet facet) {
 		return this._hides.remove(facet);
 	}
 	
 	/**
 	 * Add all elements from a facet set into this one.
 	 * 
 	 * @param arg0 A <code>FacetSet</code>
 	 * @return Success or failure
 	 */
 	public boolean addFacetSet(FacetSet arg0) {
 		return (this._base.addAll(arg0._base) && this._hides.addAll(arg0._hides));
 	}
 	
 	/**
 	 * Parses a configuration graph for facet set information on the given resource.
 	 * 
 	 * @param source Configuration source <code>Repository</code>
 	 * @param focus <code>Resource</code> to parse
 	 * @return A <code>FacetSet</code>
 	 */
 	public static FacetSet parse(Repository source, Resource focus)
 	throws UnresolvableException, ParsingException {
 		FacetSet out = new FacetSet(focus);
 		try {
 			RepositoryConnection conn = source.getConnection();
             RepositoryResult<Statement> facetI = conn.getStatements(focus, Facets.facets, (Value) null, false);
 			if (facetI.hasNext()) {
 				Statement facetStmt = (Statement) facetI.next();
 				Value facetsNode = facetStmt.getObject();
 				if (facetI.hasNext()) throw new UnresolvableException("More than one :facets value available");
 				if (facetsNode instanceof Resource && RDFList.isRDFList(source, (Resource) facetsNode)) {
 					RDFList facetRDFList = new RDFList(source, (Resource) facetsNode);
 					if (facetRDFList.isValid()) {
 						for (Iterator listI = facetRDFList.iterator(); listI.hasNext(); ) {
 							Resource facetNode = (Resource) listI.next();
 							Facet facet = new Facet(facetNode);
 							out.addFacet(facet);
 						}
 					} else {
 						throw new ParsingException(facetsNode.toString() + "is not a valid rdf:List");
 					}
 				}
 			}
 			facetI.close();
 
-            RepositoryResult<Statement> hidesI = conn.getStatements(focus, Facets.hides, (Value) null, true);
+            RepositoryResult<Statement> hidesI = conn.getStatements(focus, Facets.hides, (Value) null, false);
 			if (hidesI.hasNext()) {
 				Statement facetStmt = hidesI.next();
 				Value facetsNode = facetStmt.getObject();
 				if (hidesI.hasNext()) throw new UnresolvableException("More than one :hides value available");
 				if (facetsNode instanceof Resource && RDFList.isRDFList(source, (Resource) facetsNode)) {
 					RDFList facetRDFList = new RDFList(source, (Resource) facetsNode);
 					if (facetRDFList.isValid()) {
 						for (Iterator listI = facetRDFList.iterator(); listI.hasNext(); ) {
 							Resource facetNode = (Resource) listI.next();
 							Facet facet = new Facet(facetNode);
 							out.addHide(facet);
 						}
 					} else {
 						throw new ParsingException(facetsNode.toString() + "is not a valid rdf:List");
 					}
 				}
 			}
 			hidesI.close();
 			conn.close();
 		} catch (RepositoryException e) {
 			throw new UnresolvableException("Problem connecting to repository: " + e.getLocalizedMessage());
 		}
 
 		TypeSet forTypes = TypeSet.parse(source, focus);
 		out.setForTypes(forTypes);
 
 		return out;
 	}
 	
 	/**
 	 * @see java.lang.Object#toString()
 	 */
 	public String toString() {
 		String state = "[FacetSet " + super.toString() + "]\n";
 		state += "   " + this._forTypes.toString();
 		Iterator<Facet> it = this.facetIterator();
 		while (it.hasNext()) {
 			Facet select = it.next();
 			state += "     [Facet " + select.getIdentifier() + "]\n";
 		}
 		it = this.hideIterator();
 		while (it.hasNext()) {
 			Facet select = it.next();
 			state += "     [Hide facet " + select.getIdentifier() + "]\n";
 		}
 		return state;
 	}
 }
Index: trunk/simile-fresnel/src/main/java/edu/mit/simile/fresnel/selection/InstanceSelector.java
===================================================================
--- trunk/simile-fresnel/src/main/java/edu/mit/simile/fresnel/selection/InstanceSelector.java (revision 2)
+++ trunk/simile-fresnel/src/main/java/edu/mit/simile/fresnel/selection/InstanceSelector.java (revision 36)
@@ -1,156 +1,164 @@
 /*
  * Created on Mar 29, 2005
  */
 package edu.mit.simile.fresnel.selection;
 
 import java.util.Iterator;
 import java.util.Vector;
 
 import org.openrdf.model.Resource;
 import org.openrdf.model.Statement;
 import org.openrdf.model.URI;
 import org.openrdf.model.Value;
 import org.openrdf.repository.Repository;
 import org.openrdf.repository.RepositoryConnection;
 import org.openrdf.repository.RepositoryException;
 import org.openrdf.repository.RepositoryResult;
 
 /**
  * Selects one specific resource.
  * 
  * @author ryanlee
  */
 public class InstanceSelector implements ISelector {
     /**
      * The resource this selector selects.
      */
     private Resource _resource;
     
     /**
      * Can return statements.
      */
     private boolean _statements = true;
     
     /**
      * Can return resources.
      */
     private boolean _resources = true;
     
     /**
      * Cannot return nodes.
      */
     private boolean _nodes = false;
     
     /**
      * Create a new InstanceSelector.
      * 
      * @param resource The <code>Resource</code> the instance selector selects
      */
     public InstanceSelector(Resource resource) {
         this._resource = resource;
     }
     
     /**
      * Returns the resource this instance selector is based on.
      * 
      * @return A <code>Resource</code>
      */
     public Resource getInstance() {
     		return this._resource;
     }
     
     /**
      * @see edu.mit.simile.fresnel.selection.ISelector#selectStatements(Repository, Resource)
      */
     public Iterator<Statement> selectStatements(Repository in, Resource selected) throws InvalidResultSetException {
     	Vector<Statement> results = null;
     	if (selected.equals(this._resource)) {
     		try {
     			RepositoryConnection conn = in.getConnection();
-    			RepositoryResult<Statement> it  = conn.getStatements(selected, (URI) null, (Value) null, false);
+    			RepositoryResult<Statement> it  = conn.getStatements(selected, (URI) null, (Value) null, true);
     			while ( it.hasNext() ) {
     				results.add(it.next());
     			}
     			it.close();
+    			
+        		/* Inverse statements */
+                it = conn.getStatements(null, null, selected, true);
+        		while (it.hasNext()) {
+        			results.add(it.next());
+        		}
+        		it.close();
+    			
     			conn.close();
     		} catch (RepositoryException e) {
     			throw new InvalidResultSetException(e.getMessage());
     		}
     	}
     	return results.iterator();
     }
 
     /**
      * @see edu.mit.simile.fresnel.selection.ISelector#canSelectStatements()
      */
     public boolean canSelectStatements() {
         return this._statements;
     }
 
     /**
      * @see edu.mit.simile.fresnel.selection.ISelector#selectResources(Repository)
      */
     public Iterator<Resource> selectResources(Repository in) throws InvalidResultSetException {
         Vector<Resource> resources = new Vector<Resource>();
         resources.add(this._resource);
         return resources.iterator();
     }
 
     /**
      * @see edu.mit.simile.fresnel.selection.ISelector#canSelectResources()
      */
     public boolean canSelectResources() {
         return this._resources;
     }
 
     /**
      * @see edu.mit.simile.fresnel.selection.ISelector#selectNodes(Repository)
      */
     public Iterator<Value> selectNodes(Repository in) throws InvalidResultSetException {
         throw new InvalidResultSetException("");
     }
 
     /**
      * @see edu.mit.simile.fresnel.selection.ISelector#canSelectNodes()
      */
     public boolean canSelectNodes() {
         return this._nodes;
     }
 
     /**
      * @see edu.mit.simile.fresnel.selection.ISelector#canSelect(Repository, Resource, URI)
      */
 	public boolean canSelect(Repository in, Resource selected, URI prop) {
 		boolean stmtExists = false;
 		try {
 			RepositoryConnection conn = in.getConnection();
-			stmtExists = conn.hasStatement(selected, prop, (Value) null, false);
+			stmtExists = conn.hasStatement(selected, prop, (Value) null, true);
 			conn.close();
 		} catch (RepositoryException e) {
 			// TODO: how to handle exception
 		}
         return (selected.equals(this._resource) && stmtExists);
 	}
 	
 	/**
      * @see edu.mit.simile.fresnel.selection.ISelector#selectStatements(Repository, Resource)
      */
     public boolean canSelect(Repository in, Resource selected) {
 		boolean stmtExists = false;
 		try {
 			RepositoryConnection conn = in.getConnection();
-			stmtExists = conn.hasStatement(selected, (URI) null, (Value) null, false);
+			stmtExists = conn.hasStatement(selected, (URI) null, (Value) null, true);
 			conn.close();
 		} catch (RepositoryException e) {
 			// TODO: how to handle exception
 		}
         return (selected.equals(this._resource) && stmtExists);
     }
 
     /**
      * @see edu.mit.simile.fresnel.selection.ISelector#canSelect(Repository, Value)
      */
     public boolean canSelect(Repository in, Value selected) {
         return this._nodes;
     }
 }
Index: trunk/simile-fresnel/src/main/java/edu/mit/simile/fresnel/selection/ContainerMemberSelector.java
===================================================================
--- trunk/simile-fresnel/src/main/java/edu/mit/simile/fresnel/selection/ContainerMemberSelector.java (revision 2)
+++ trunk/simile-fresnel/src/main/java/edu/mit/simile/fresnel/selection/ContainerMemberSelector.java (revision 36)
@@ -1,137 +1,137 @@
 /*
  * Created on Apr 27, 2005
  */
 package edu.mit.simile.fresnel.selection;
 
 import java.util.Iterator;
 import java.util.List;
 import java.util.Vector;
 
 import org.openrdf.model.Resource;
 import org.openrdf.model.Statement;
 import org.openrdf.model.URI;
 import org.openrdf.model.Value;
 import org.openrdf.model.impl.StatementImpl;
 import org.openrdf.repository.Repository;
 import org.openrdf.repository.RepositoryConnection;
 import org.openrdf.repository.RepositoryException;
 
 import edu.mit.simile.fresnel.util.Container;
 import edu.mit.simile.fresnel.util.RDFList;
 import edu.mit.simile.vocabularies.FresnelCore;
 
 /**
  * Only handles fresnel:member as a property selector.
  * 
  * @author ryanlee
  */
 public class ContainerMemberSelector implements ISelector {
     /**
      * Can return statements.
      */
     private final boolean _statements = true;
     
     /**
      * Cannot return resources.
      */
     private final boolean _resources = false;
     
     /**
      * Cannot return nodes.
      */
     private final boolean _nodes = false;
 
     /**
      * Selects statements matching fresnel:member out of container and list item
      * membership statements.  Assumes containers and lists are mutually exclusive.
      * 
      * @see edu.mit.simile.fresnel.selection.ISelector#selectStatements(Repository, Resource)
      */
     public Iterator<Statement> selectStatements(Repository in, Resource selected)
             throws InvalidResultSetException {
         // put statements in a vector and create a statement iterator based off the vector iterator
         Vector<Statement> statements = new Vector<Statement>();
         URI mem = (URI) FresnelCore.member;
         if (Container.isContainer(in, selected)) {
             Container con = new Container(in, selected);
             for (Iterator it = con.iterator(); it.hasNext(); ) {
                 statements.add(new StatementImpl(selected, mem, (Value) it.next()));
             }
         } else if (RDFList.isRDFList(in, selected)) {
             List list = new RDFList(in, selected).asJavaList();
             for (Iterator it = list.iterator(); it.hasNext(); ) {
                 statements.add(new StatementImpl(selected, mem, (Value) it.next()));
             }
         }
         return statements.iterator();
     }
 
     /**
      * @see edu.mit.simile.fresnel.selection.ISelector#canSelectStatements()
      */
     public boolean canSelectStatements() {
         return this._statements;
     }
 
     /**
      * TODO: probably this will go unused, but it doesn't make much sense as is;
      *       if this only selects fresnel:member-ish stuff, then an arbitrary
      *       property isn't going to be selected by this selector...
      * @see edu.mit.simile.fresnel.selection.ISelector#canSelect(Repository, Resource, URI)
      */
 	public boolean canSelect(Repository in, Resource selected, URI prop) {
 		boolean out = false;
 		try {
 			RepositoryConnection conn = in.getConnection();
-			out = conn.hasStatement(selected, prop, (Value) null, false);
+			out = conn.hasStatement(selected, prop, (Value) null, true);
 			conn.close();
 		} catch (RepositoryException e) {
 			// TODO: how to handle exception
 		}
 		return out;
 	}
 	
     /**
      * @see edu.mit.simile.fresnel.selection.ISelector#selectResources(Repository)
      */
     public Iterator<Resource> selectResources(Repository in)
             throws InvalidResultSetException {
         throw new InvalidResultSetException("ContainerMemberSelector cannot select resources");
     }
 
     /**
      * @see edu.mit.simile.fresnel.selection.ISelector#canSelectResources()
      */
     public boolean canSelectResources() {
         return this._resources;
     }
 
     /**
      * @see edu.mit.simile.fresnel.selection.ISelector#canSelect(Repository, Resource)
      */
     public boolean canSelect(Repository in, Resource selected) {
         return (Container.isContainer(in, selected) || RDFList.isRDFList(in, selected));
     }
 
     /**
      * @see edu.mit.simile.fresnel.selection.ISelector#selectNodes(Repository)
      */
     public Iterator<Value> selectNodes(Repository in) throws InvalidResultSetException {
         throw new InvalidResultSetException("ContainerMemberSelector cannot select nodes");
     }
 
     /**
      * @see edu.mit.simile.fresnel.selection.ISelector#canSelectNodes()
      */
     public boolean canSelectNodes() {
         return this._nodes;
     }
 
     /**
      * @see edu.mit.simile.fresnel.selection.ISelector#canSelect(Repository, Value)
      */
     public boolean canSelect(Repository in, Value selected) {
         return this._nodes;
     }
 
 }
Index: trunk/simile-fresnel/src/main/java/edu/mit/simile/fresnel/selection/FSESelector.java
===================================================================
--- trunk/simile-fresnel/src/main/java/edu/mit/simile/fresnel/selection/FSESelector.java (revision 2)
+++ trunk/simile-fresnel/src/main/java/edu/mit/simile/fresnel/selection/FSESelector.java (revision 76)
@@ -1,202 +1,214 @@
 /*
  * Created on Mar 17, 2005
  */
 package edu.mit.simile.fresnel.selection;
 
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.Vector;
 
 import org.openrdf.model.Resource;
 import org.openrdf.model.Statement;
 import org.openrdf.model.URI;
 import org.openrdf.model.Value;
 import org.openrdf.repository.Repository;
 import org.openrdf.repository.RepositoryConnection;
 import org.openrdf.repository.RepositoryException;
 import org.openrdf.repository.RepositoryResult;
 import fr.inria.jfresnel.fsl.FSLHierarchyStore;
 import fr.inria.jfresnel.fsl.FSLNSResolver;
 import fr.inria.jfresnel.fsl.FSLPath;
 import fr.inria.jfresnel.fsl.sesame.FSLSesameEvaluator;
 
 /**
  * Selector based on a Fresnel Selector Expression, composed from
  * the Fresnel Selector Language.  canSelect(Resource) and canSelect(Value)
  * are indeterminate for this selector; with no Repository source, it's impossible
  * to tell, so false is returned by default.
  * 
  * @author ryanlee
  */
 public class FSESelector implements ISelector {	
 	/**
 	 * The original FSE.
 	 */
 	private String _fse;
 	
 	/**
 	 * The context of the FSE
 	 */
 	private short _use;
 	
 	/**
 	 * Evaluates FSE's into paths
 	 */
 	private FSLSesameEvaluator _eval;
 	
 	/**
 	 * Namespace resolver for path evaluator
 	 */
 	private FSLNSResolver _nsr;
 
 	/**
 	 * Hierarchy store path evaluator; expected to do nothing for now.
 	 */
 	private FSLHierarchyStore _fhs;
 	
 	/**
 	 * Create an FSESelector based on its string representation.
 	 * 
 	 * @param fse The <code>String</code> representation of the FSE
 	 */
 	public FSESelector(String fse, short use, FSLNSResolver nsr) {
  		this._fse = fse;
 		this._use = use;
 		this._nsr = nsr;
 		this._fhs = new FSLHierarchyStore();
 		this._eval = new FSLSesameEvaluator(this._nsr, this._fhs);
 	}
 	
 	/**
 	 * This may or may not work.  If the path expression is not compatible with selecting statements
 	 * based on the starting point of the selected parameter, an exception will be thrown.
 	 * 
 	 * @see edu.mit.simile.fresnel.selection.ISelector#selectStatements(Repository, Resource)
 	 */
 	public Iterator<Statement> selectStatements(Repository in, Resource selected) throws InvalidResultSetException {
 		this._eval.setRepository(in);
 		HashMap<Statement, Object> start = new HashMap<Statement, Object>();
 		try {
 			RepositoryConnection conn = in.getConnection();
-			RepositoryResult<Statement> results = conn.getStatements(selected, null, null, false);
+			RepositoryResult<Statement> results = conn.getStatements(selected, null, null, true);
 			while (results.hasNext()) {
 				start.put(results.next(), null);
 			}
 			conn.close();
 		} catch (RepositoryException e) {
 			throw new InvalidResultSetException("Repository exception encountered generating starting points: " + this._fse);            
 		}
 		FSLPath p = FSLPath.pathFactory(this._fse, this._nsr, this._use);
         Vector<Statement> statements = new Vector<Statement>();
 		try {
             Vector<Vector<Object>> paths = this._eval.evaluatePath(p, start);
 
             for (int i = 0; i < paths.size() ; i++ ) {
 				Vector<Object> v = paths.get(i);
 				statements.add((Statement) v.get(v.size()-1));
 			}
 		} catch (ClassCastException e) {
 			throw new InvalidResultSetException("This expression does not return statements: " + this._fse);			
 		}
+		this._eval.unsetRepository();
 		return statements.iterator();
 	}
 	
 	/**
 	 * @see edu.mit.simile.fresnel.selection.ISelector#selectResources(Repository)
 	 */
 	public Iterator<Resource> selectResources(Repository in) throws InvalidResultSetException {
 		this._eval.setRepository(in);
 		FSLPath p = FSLPath.pathFactory(this._fse, this._nsr, this._use);
 		Vector<Vector<Object>> paths = this._eval.evaluatePath(p);
 		Vector<Resource> resources = new Vector<Resource>();
 		try {
 			for (int i = 0; i < paths.size() ; i++ ) {
 				Vector<Object> v = paths.get(i);
 				resources.add((Resource) v.get(v.size()-1));
 			}
 		} catch (ClassCastException e) {
 			throw new InvalidResultSetException("This expression does not return resources: " + this._fse);			
 		}
+		this._eval.unsetRepository();
 		return resources.iterator();
 	}
 	
 	/**
 	 * @see edu.mit.simile.fresnel.selection.ISelector#selectNodes(Repository)
 	 */
 	public Iterator<Value> selectNodes(Repository in) throws InvalidResultSetException {
 		this._eval.setRepository(in);
 		FSLPath p = FSLPath.pathFactory(this._fse, this._nsr, this._use);
 		Vector<Vector<Object>> paths = this._eval.evaluatePath(p);
 		Vector<Value> values = new Vector<Value>();
 		try {
 			for (int i = 0; i < paths.size() ; i++ ) {
 				Vector<Object> v = paths.get(i);
 				values.add((Value) v.get(v.size()-1));
 			}
 		} catch (ClassCastException e) {
 			throw new InvalidResultSetException("This expression does not return values: " + this._fse);			
 		}
+		this._eval.unsetRepository();
 		return values.iterator();
 	}
 	
 	/**
 	 * @see edu.mit.simile.fresnel.selection.ISelector#canSelectStatements()
 	 */
 	public boolean canSelectStatements() {
 		return true;
 	}
 	
 	/**
 	 * @see edu.mit.simile.fresnel.selection.ISelector#canSelectResources()
 	 */
 	public boolean canSelectResources() {
 		return true;
 	}
 	
 	/**
 	 * @see edu.mit.simile.fresnel.selection.ISelector#canSelectNodes()
 	 */
 	public boolean canSelectNodes() {
 		return true;
 	}
 	
 	/**
 	 * @see edu.mit.simile.fresnel.selection.ISelector#canSelect(Repository, Resource, URI)
 	 */
 	public boolean canSelect(Repository in, Resource selected, URI prop) {
-		try {
-			Iterator<Statement> si = selectStatements(in, selected);
-			while (si.hasNext()) {
-				if (si.next().getPredicate().equals(prop)) return true;
-			}
-		} catch (InvalidResultSetException e) {
-			return false;
-		}
-		return false;
+//		if (prop.toString().equals("fsl://"+_fse))
+//				return true;
+		return (prop.toString().equals("fsl://"+_fse));
+//		try {
+//			Iterator<Statement> si = selectStatements(in, selected);
+//			while (si.hasNext()) {
+//				if (si.next().getPredicate().equals(prop)) return true;
+//			}
+//		} catch (InvalidResultSetException e) {
+//			return false;
+//		}
+//		return false;
 	}
 	
 	/**
 	 * @see edu.mit.simile.fresnel.selection.ISelector#canSelect(Repository, Resource)
 	 */
 	public boolean canSelect(Repository in, Resource selected) {
+		if (_fse.equals("*")) /* will iterate all resources otherwise */
+			return true;
 		try {
 			Iterator<Resource> ri = selectResources(in);
 			while (ri.hasNext()) {
 				if (ri.next().equals(selected)) return true;
 			}
 		} catch (InvalidResultSetException e) {
 			// TODO these exceptions should be logged.
 			return false;
 		}
 		return false;
 	}
 	
 	/**
 	 * This method will always return false.
 	 * 
 	 * @see edu.mit.simile.fresnel.selection.ISelector#canSelect(Repository, Value)
 	 */
 	public boolean canSelect(Repository in, Value selected) {
 		return false;		
 	}
+
+	public String get_fse() {
+		return _fse;
+	}
 }
Index: trunk/simile-fresnel/src/main/java/edu/mit/simile/fresnel/selection/TypeSelector.java
===================================================================
--- trunk/simile-fresnel/src/main/java/edu/mit/simile/fresnel/selection/TypeSelector.java (revision 2)
+++ trunk/simile-fresnel/src/main/java/edu/mit/simile/fresnel/selection/TypeSelector.java (revision 36)
@@ -1,155 +1,155 @@
 /*
  * Created on Mar 16, 2005
  */
 package edu.mit.simile.fresnel.selection;
 
 import info.aduna.collections.iterators.CloseableIterator;
 
 import java.util.Iterator;
 
 import org.openrdf.model.Resource;
 import org.openrdf.model.Statement;
 import org.openrdf.model.URI;
 import org.openrdf.model.Value;
 import org.openrdf.model.vocabulary.RDF;
 import org.openrdf.repository.Repository;
 import org.openrdf.repository.RepositoryConnection;
 import org.openrdf.repository.RepositoryException;
 
 import edu.mit.simile.fresnel.FresnelUtilities;
 import edu.mit.simile.fresnel.util.Container;
 import edu.mit.simile.fresnel.util.RDFList;
 
 
 /**
  * Selects resources based on their rdf:type.
  * 
  * @author ryanlee
  */
 public class TypeSelector implements ISelector {
 	/**
 	 * The internal rdfs:Resource representing the desired rdf:type.
 	 */
 	private Resource _type;
 	
 	/**
 	 * Do not use for statements.
 	 */
 	private final boolean _statements = false;
 	
 	/**
 	 * Use for resources.
 	 */
 	private final boolean _resources = true;
 	
 	/**
 	 * Do not use for nodes.
 	 */
 	private final boolean _nodes = false;
 	
 	/**
 	 * Build a TypeSelector from an object of rdf:type.
 	 * 
 	 * @param type A <code>Resource</code> representing a schema class
 	 */
 	public TypeSelector(Resource type) {
 		this._type = type;
 	}
 	
 	/**
 	 * Returns the type this selector is based on.
 	 * 
 	 * @return A <code>Resource</code>
 	 */
 	public Resource getType() {
 		return this._type;
 	}
 
 	/**
 	 * Don't use this.
 	 * 
 	 * @see edu.mit.simile.fresnel.selection.ISelector#selectStatements(Repository, Resource)
 	 */
 	public CloseableIterator<Statement> selectStatements(Repository in, Resource selected)
 	throws InvalidResultSetException {
 		throw new InvalidResultSetException("TypeSelector does not select statements");
 	}
 	
 	/**
 	 * @see edu.mit.simile.fresnel.selection.ISelector#selectResources(Repository)
 	 */
 	public Iterator<Resource> selectResources(Repository in)
 	throws InvalidResultSetException {
 		return FresnelUtilities.listSubjectsWithProperty(in, RDF.TYPE, this._type);
 	}
 	
 	/**
 	 * Don't use this.
 	 * 
 	 * @see edu.mit.simile.fresnel.selection.ISelector#selectNodes(Repository)
 	 */
 	public Iterator<Value> selectNodes(Repository in) throws InvalidResultSetException {
 		throw new InvalidResultSetException("TypeSelector does not select nodes");
 	}
 	
 	/**
 	 * @see edu.mit.simile.fresnel.selection.ISelector#canSelectStatements()
 	 */
 	public boolean canSelectStatements() {
 		return this._statements;
 	}
 	
 	/**
 	 * @see edu.mit.simile.fresnel.selection.ISelector#canSelectResources()
 	 */
 	public boolean canSelectResources() {
 		return this._resources;
 	}
 	
 	/**
 	 * @see edu.mit.simile.fresnel.selection.ISelector#canSelectNodes()
 	 */
 	public boolean canSelectNodes() {
 		return this._nodes;
 	}
 	
 	/**
 	 * @see edu.mit.simile.fresnel.selection.ISelector#canSelect(Repository, Resource, URI)
 	 */
 	public boolean canSelect(Repository in, Resource selected, URI prop) {
 		return this._statements;
 	}
 	
 	/**
 	 * @see edu.mit.simile.fresnel.selection.ISelector#canSelect(Repository, Resource)
 	 */
 	public boolean canSelect(Repository in, Resource selected) {
 		boolean stmtExists = false;
 		try {
 			RepositoryConnection conn = in.getConnection();
-			stmtExists = conn.hasStatement(selected, RDF.TYPE, this._type, false);
+			stmtExists = conn.hasStatement(selected, RDF.TYPE, this._type, true);
 			conn.close();
 		} catch (RepositoryException e) {
 			// TODO: how to handle exception
 		}
 		return ((this._type.equals(RDF.LIST) && RDFList.isRDFList(in, selected)) ||
 				((this._type.equals(RDF.ALT) || this._type.equals(RDF.BAG) || this._type.equals(RDF.SEQ)) && Container.isContainer(in, selected)) ||
 				stmtExists);
 	}
 	
 	/**
 	 * @see edu.mit.simile.fresnel.selection.ISelector#canSelect(Repository, Value)
 	 */
 	public boolean canSelect(Repository in, Value selected) {
 		return this._nodes;
 	}
 	
 	/**
 	 * @see java.lang.Object#toString()
 	 */
 	public String toString() {
 		String state = "   [ISelector:TypeSelector " + super.toString() + "]\n";
 		state += "   " + this._type + "\n";
 		return state;
 	}
 }
Index: trunk/simile-fresnel/src/main/java/edu/mit/simile/fresnel/selection/PropertySelector.java
===================================================================
--- trunk/simile-fresnel/src/main/java/edu/mit/simile/fresnel/selection/PropertySelector.java (revision 2)
+++ trunk/simile-fresnel/src/main/java/edu/mit/simile/fresnel/selection/PropertySelector.java (revision 36)
@@ -1,172 +1,182 @@
 /*
  * Created on Mar 17, 2005
  */
 package edu.mit.simile.fresnel.selection;
 
 import java.util.Iterator;
 import java.util.Vector;
 
 import org.openrdf.model.Resource;
 import org.openrdf.model.Statement;
 import org.openrdf.model.URI;
 import org.openrdf.model.Value;
 import org.openrdf.repository.Repository;
 import org.openrdf.repository.RepositoryConnection;
 import org.openrdf.repository.RepositoryException;
 import org.openrdf.repository.RepositoryResult;
 
 /**
  * Selects statements from a graph based on matching the property.
  * 
  * @author ryanlee
  */
 public class PropertySelector implements ISelector {  
     /**
      * The resource (a rdf:Property) to select on.
      */
     private URI _property;
     
     /**
      * Does return statements.
      */
     private boolean _statements = true;
     
     /**
      * Doesn't return resources.
      */
     private boolean _resources = false;
     
     /**
      * Doesn't return nodes.
      */
     private boolean _nodes = false;
     
     /**
      * Constructor with an rdf:Property.
      * 
      * @param prop A property <code>URI</code>
      */
     public PropertySelector(URI prop) {
         this._property = prop;
     }
     
     /**
      * Retrieves the property this selector is based on.
      * 
      * @return A property <code>URI</code>
      */
     public URI getProperty() {
         return this._property;
     }
     
     /**
      * @see edu.mit.simile.fresnel.selection.ISelector#selectStatements(Repository, Resource)
      */
     public Iterator<Statement> selectStatements(Repository in, Resource selected)
             throws InvalidResultSetException {
     	// extremely inefficient, but i'm not certain it's kosher to pass on a CloseableIterator
     	// with the connection unclosed; or with the connection closed - it seems they should only
     	// be opened/used in instances where the connection can also be closed in the same block;
     	// so TODO: figure out whether a ClosableIterator can be passed around or whether this
     	// reading of the iterator's contents to make another iterator is basically the only choice
 		Vector<Statement> out = new Vector<Statement>();
     	try {
     		RepositoryConnection conn = in.getConnection();
-            RepositoryResult<Statement> it = conn.getStatements(selected, getProperty(), (Value) null, false);
+            RepositoryResult<Statement> it = conn.getStatements(selected, getProperty(), (Value) null, true);
+    		while (it.hasNext()) {
+    			out.add(it.next());
+    		}
+    		it.close();
+    		
+    		/* Inverse statements */
+            it = conn.getStatements(null, getProperty(), selected, true);
     		while (it.hasNext()) {
     			out.add(it.next());
     		}
     		it.close();
     		conn.close();
     	} catch (RepositoryException e) {
     		throw new InvalidResultSetException("Problem connecting to repository: " + e.getLocalizedMessage());
     	}
     	return out.iterator();
     }
 
     /**
      * Do not use this.
      * 
      * @see edu.mit.simile.fresnel.selection.ISelector#selectResources(Repository)
      */
     public Iterator<Resource> selectResources(Repository in)
             throws InvalidResultSetException {
         throw new InvalidResultSetException("PropertySelector cannot be used to select resources");
     }
 
     /**
      * Do not use this.
      * 
      * @see edu.mit.simile.fresnel.selection.ISelector#selectNodes(Repository)
      */
     public Iterator<Value> selectNodes(Repository in) throws InvalidResultSetException {
         throw new InvalidResultSetException("PropertySelector cannot be used to select object nodes");
     }
 
     /**
      * @see edu.mit.simile.fresnel.selection.ISelector#canSelectStatements()
      */
     public boolean canSelectStatements() {
         return this._statements;
     }
 
     /**
      * @see edu.mit.simile.fresnel.selection.ISelector#canSelectResources()
      */
     public boolean canSelectResources() {
         return this._resources;
     }
 
     /**
      * @see edu.mit.simile.fresnel.selection.ISelector#canSelectNodes()
      */
     public boolean canSelectNodes() {
         return this._nodes;
     }
 
     /**
      * @see edu.mit.simile.fresnel.selection.ISelector#canSelect(Repository, Resource, URI)
      */
 	public boolean canSelect(Repository in, Resource selected, URI prop) {
 		boolean out = false;
 		try {
 			RepositoryConnection conn = in.getConnection();
-			out = conn.hasStatement(selected, prop, (Value) null, false) && prop.equals(getProperty());
+			out = prop.equals(getProperty()) && 
+				(conn.hasStatement(selected, prop, (Value) null, true)
+						|| conn.hasStatement(null, prop, selected, true));
 			conn.close();
 		} catch (RepositoryException e) {
 			// TODO: how to handle exception
 		}
         return out;
 	}
 	
     /**
      * @see edu.mit.simile.fresnel.selection.ISelector#canSelect(Repository, Resource)
      */
     public boolean canSelect(Repository in, Resource selected) {
 		boolean out = false;
 		try {
 			RepositoryConnection conn = in.getConnection();
-			out = conn.hasStatement(selected, getProperty(), (Value) null, false);
+			out = conn.hasStatement(selected, getProperty(), (Value) null, true)
+					|| conn.hasStatement(null, getProperty(), selected, true);
 			conn.close();
 		} catch (RepositoryException e) {
 			// TODO: how to handle exception
 		}
         return out;
     }
 
     /**
      * @see edu.mit.simile.fresnel.selection.ISelector#canSelect(Repository, Value)
      */
     public boolean canSelect(Repository in, Value selected) {
         return this._nodes;
     }
     
     /**
      * @see java.lang.Object#toString()
      */
     public String toString() {
         String state = "   [ISelector:PropertySelector " + super.toString() + "]\n";
         state += "   " + this._property + "\n";
         return state;
     }
 }
Index: trunk/simile-fresnel/src/main/java/edu/mit/simile/fresnel/selection/AllPropertiesSelector.java
===================================================================
--- trunk/simile-fresnel/src/main/java/edu/mit/simile/fresnel/selection/AllPropertiesSelector.java (revision 2)
+++ trunk/simile-fresnel/src/main/java/edu/mit/simile/fresnel/selection/AllPropertiesSelector.java (revision 36)
@@ -1,157 +1,164 @@
 /*
  * Created on Mar 17, 2005
  */
 package edu.mit.simile.fresnel.selection;
 
 import java.util.Iterator;
 import java.util.Vector;
 
 import org.openrdf.model.Resource;
 import org.openrdf.model.Statement;
 import org.openrdf.model.URI;
 import org.openrdf.model.Value;
 import org.openrdf.repository.Repository;
 import org.openrdf.repository.RepositoryConnection;
 import org.openrdf.repository.RepositoryException;
 import org.openrdf.repository.RepositoryResult;
 
 
 /**
  * Selects all properties of a given resource.
  * 
  * @author ryanlee
  */
 public class AllPropertiesSelector implements ISelector {
     /**
      * Does select statements.
      */
     private boolean _statements = true;
     
     /**
      * Does not select resources.
      */
     private boolean _resources = false;
     
     /**
      * Does not select nodes.
      */
     private boolean _nodes = false;
     
     /**
      * Compares other ISelectors to the AllPropertiesSelector to check if it is
      * an AllPropertiesSelector.
      * 
      * @param selector An <code>ISelector</code> for comparison
      * @return The <code>boolean</code> comparison result
      */
     public static boolean isAllProperties(ISelector selector) {
         return selector.getClass().equals(AllPropertiesSelector.class);
     }
     
     /**
      * @see edu.mit.simile.fresnel.selection.ISelector#selectStatements(Repository, Resource)
      */
     public Iterator<Statement> selectStatements(Repository in, Resource selected)
             throws InvalidResultSetException {
     	// TODO: problematic
     	Vector<Statement> out = new Vector<Statement>();
     	try {
     		RepositoryConnection conn = in.getConnection();
-            RepositoryResult<Statement> it = conn.getStatements(selected, (URI) null, (Value) null, false);
+            RepositoryResult<Statement> it = conn.getStatements(selected, (URI) null, (Value) null, true);
+    		while (it.hasNext()) {
+    			out.add(it.next());
+    		}
+    		it.close();
+    		
+    		/* Inverse statements */
+            it = conn.getStatements(null, null, selected, true);
     		while (it.hasNext()) {
     			out.add(it.next());
     		}
     		it.close();
     		conn.close();
     	} catch (RepositoryException e) {
     		throw new InvalidResultSetException("Problem connecting to repository: " + e.getLocalizedMessage());
     	}
     	return out.iterator();
     }
 
     /**
      * Don't use this.
      * 
      * @see edu.mit.simile.fresnel.selection.ISelector#selectResources(Repository)
      */
     public Iterator<Resource> selectResources(Repository in)
             throws InvalidResultSetException {
         throw new InvalidResultSetException("AllPropertiesSelector does not select resources");
     }
 
     /**
      * Don't use this.
      * 
      * @see edu.mit.simile.fresnel.selection.ISelector#selectNodes(Repository)
      */
     public Iterator<Value> selectNodes(Repository in) throws InvalidResultSetException {
         throw new InvalidResultSetException("AllPropertiesSelector does not select nodes");
     }
 
     /**
      * @see edu.mit.simile.fresnel.selection.ISelector#canSelectStatements()
      */
     public boolean canSelectStatements() {
         return this._statements;
     }
 
     /**
      * @see edu.mit.simile.fresnel.selection.ISelector#canSelectResources()
      */
     public boolean canSelectResources() {
         return this._resources;
     }
 
     /**
      * @see edu.mit.simile.fresnel.selection.ISelector#canSelectNodes()
      */
     public boolean canSelectNodes() {
         return this._nodes;
     }
 
     /**
      * @see edu.mit.simile.fresnel.selection.ISelector#canSelect(Repository, Resource, URI)
      */
 	public boolean canSelect(Repository in, Resource selected, URI prop) {
 		boolean out = false;
 		try {
 			RepositoryConnection conn = in.getConnection();
-			out = conn.hasStatement(selected, prop, (Value) null, false);
+			out = conn.hasStatement(selected, prop, (Value) null, true);
 			conn.close();
 		} catch (RepositoryException e) {
 			// TODO: how to handle exception
 		}
         return out;
 	}
 	
 	/**
      * @see edu.mit.simile.fresnel.selection.ISelector#canSelect(Repository, Resource)
      */
 	public boolean canSelect(Repository in, Resource selected) {
 		boolean out = false;
 		try {
 			RepositoryConnection conn = in.getConnection();
-			out = conn.hasStatement(selected, (URI) null, (Value) null, false);
+			out = conn.hasStatement(selected, (URI) null, (Value) null, true);
 			conn.close();
 		} catch (RepositoryException e) {
 			// TODO: how to handle exception
 		}
         return out;
 	}
 
     /**
      * @see edu.mit.simile.fresnel.selection.ISelector#canSelect(Repository, Value)
      */
     public boolean canSelect(Repository in, Value selected) {
         return this._nodes;
     }
     
     /**
      * @see java.lang.Object#toString()
      */
     public String toString() {
         String state = "   [ISelector:AllPropertiesSelector " + super.toString() + "]\n";
         return state;
     }
 
 }
Index: trunk/simile-fresnel/src/main/java/edu/mit/simile/fresnel/selection/PropertyDescription.java
===================================================================
--- trunk/simile-fresnel/src/main/java/edu/mit/simile/fresnel/selection/PropertyDescription.java (revision 2)
+++ trunk/simile-fresnel/src/main/java/edu/mit/simile/fresnel/selection/PropertyDescription.java (revision 3)
@@ -1,441 +1,451 @@
 /*
  * Created on Apr 11, 2005
  */
 package edu.mit.simile.fresnel.selection;
 
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.Set;
 
 import org.openrdf.model.Literal;
 import org.openrdf.model.Resource;
 import org.openrdf.model.Statement;
 import org.openrdf.model.URI;
 import org.openrdf.model.Value;
 import org.openrdf.repository.Repository;
 import org.openrdf.repository.RepositoryConnection;
 import org.openrdf.repository.RepositoryException;
 import org.openrdf.repository.RepositoryResult;
 
 import edu.mit.simile.fresnel.FresnelCoreTypes;
 import edu.mit.simile.fresnel.FresnelResource;
 import edu.mit.simile.fresnel.configuration.Configuration;
 import edu.mit.simile.fresnel.configuration.Group;
 import edu.mit.simile.fresnel.format.Format;
 import edu.mit.simile.vocabularies.FresnelCore;
+import fr.inria.jfresnel.fsl.FSLPath;
 
 /**
  * Used for describing more about how a property is selected
  * in a lens; core terms involve the sublens and which style
  * should directly be used.
  * 
  * @author ryanlee
  */
 public class PropertyDescription extends FresnelResource implements ISelector {
     /**
      * Resource of schema class
      */
     protected static final Resource _schemaResource = FresnelCore.PropertyDescription;
     
     /**
      * Identifier for a PropertyDescription instance.
      */
     private Resource _id;
     
   	/**
   	 * The selector for the property the description describes.
   	 */
   	private ISelector _propertySelector;
     
     /**
      * The set of sublenses that should be used with the property's objects.
      */
     private Set<Lens> _sublenses;
     
     /**
      * The maximum recursion depth the sublens application can reach.
      */
     private int _depth;
     
     /**
      * Default maximum recursion depth.
      */
     private static final int DEFAULT_MAX_DEPTH = 3;
     
     /**
      * The group of styles that should be used with this description.
      */
     private Group _groupUse;
     
     /**
      * The single lens that should be used with this description.
      */
     private Format _formatUse;
     
     /**
      * This selector class can return statements.
      */
     private boolean _statements = true;
     
     /**
      * This selector class cannot return resources.
      */
     private boolean _resources = false;
     
     /**
      * This selector class cannot return nodes.
      */
     private boolean _nodes = false;
     
+    /**
+     * Context for determining FSL first location step type.
+     */
+    protected final static short _fslContext = FSLPath.ARC_STEP;
+
     /**
      * Constructor taking an identifier for the property description.
      * 
      * @param identifier A unique <code>Resource</code>
      */
     public PropertyDescription(Resource identifier) {
         setIdentifier(identifier);
         this._sublenses = new HashSet<Lens>();
     }
     
     /**
      * Returns the instance identifier.
      * 
      * @return A <code>Resource</code> identifier.
      */
     public Resource getIdentifier() {
         return this._id;
     }
     
   	/**
   	 * Returns the property selector being described.
   	 * 
   	 * @return A property <code>ISelector</code>
   	 */
   	public ISelector getProperty() {
   		return this._propertySelector;
   	}
     
     /**
      * Returns the maximum recursion depth that can be attained in sublensing.
      * 
      * @return An <code>int</code> depth.
      */
     public int getDepth() {
         return this._depth;
     }
     
     /**
      * Returns the set of sublenses associated with this description.
      * 
      * @return A <code>LensSet</code> of sublenses.
      */
     public Set<Lens> getSublenses() {
         return this._sublenses;
     }
     
     /**
      * Return an iterator over sublenses.
      * 
      * @return A <code>LensIterator</code>
      */
     public Iterator<Lens> getSublensesIterator() {
         return this._sublenses.iterator();
     }
     
     /**
      * Return the style usage for the property.
      * 
      * @return An <code>Object</code>
      * @see edu.mit.simile.fresnel.selection.PropertyDescription#isGroupUse()
      */
     public Object getUse() {
         return (null != this._groupUse) ? (Object) this._groupUse : (Object) this._formatUse;
     }
     
     /**
      * Returns whether or not the usage is a group or a single style.
      * 
      * @return A <code>boolean</code>
      */
     public boolean isGroupUse() {
         return (null != this._groupUse);
     }
     
     /**
      * Returns whether or not there is a usage associated with this description.
      * 
      * @return A <code>boolean</code>
      */
     public boolean hasUse() {
         return (null != this._groupUse || null != this._formatUse);
     }
     
     /**
      * Returns whether or not there are sublenses associated with this description.
      * 
      * @return A <code>boolean</code>
      */
     public boolean hasSublens() {
         return (null != this._sublenses);
     }
     
     /**
      * Sets the identifier for the instance of a description.
      * 
      * @param id A unique <code>Resource</code>
      */
     protected void setIdentifier(Resource id) {
         this._id = id;
     }
     
   	/**
   	 * Sets the property selector this instance describes
   	 * 
   	 * @param prop A property <code>ISelector</code>
   	 */
   	public void setProperty(ISelector propertySelector) {
   		this._propertySelector = propertySelector;
   	}
     
     /**
      * Sets the maximum recursion depth.
      * 
      * @param depth An <code>int</code>
      */
     public void setDepth(int depth) {
         this._depth = depth;
     }
     
     /**
      * Sets the sublens set used in this description.
      * 
      * @param sub A <code>LensSet</code>
      */
     public void setSublenses(Set<Lens> sub) {
         this._sublenses = sub;
     }
     
     /**
      * Appends a sublens to the set of sublenses.
      * 
      * @param sub A <code>Lens</code>
      */
     public void addSublens(Lens sub) {
         this._sublenses.add(sub);
     }
     
     /**
      * Sets the style group to use with the property description.
      * 
      * @param use A <code>Group</code> with styles
      */
     public void setGroupUse(Group use) {
     	this._groupUse = use;
     }
 
     /**
      * Sets the format to use with the property description.
      * 
      * @param use A <code>Format</code>
      */
     public void setFormatUse(Format use) {
     	this._formatUse = use;
     }
 
     /**
      * Parses a fresnel:PropertyDescription.
      * 
      * @param lens A <code>Lens</code> (the lens being parsed)
      * @param in The <code>Repository</code> containing the configuration
      * @param selected The <code>Resource</code> that is a property description
      * @param conf The <code>Configuration</code>, for lookups of existing resources
      * @return A <code>PropertyDescription</code>
      * @throws UnresolvableException When too many predicates are used beyond their
      *         OWL cardinality restriction 
      * @throws ParsingException When an improper model form is used in configuration
      */
     public static PropertyDescription parse(Lens lens, Repository in, Resource selected, Configuration conf)
     throws UnresolvableException, ParsingException, ResourceNotFoundException {
     	PropertyDescription out = new PropertyDescription(selected);
     	try {
     		RepositoryConnection conn = in.getConnection();
             RepositoryResult<Statement> pdSI = conn.getStatements(selected, FresnelCore.property, (Value) null, false);
     		while (pdSI.hasNext()) {
     			Statement stmt = (Statement) pdSI.next();
     			if (pdSI.hasNext())
     				throw new UnresolvableException("More than one fresnel:property predicate used.");
 
     			Value obj = stmt.getObject();
     			ISelector selector = null;
 
   				// Evaluate the selector type for a property
   				if (obj instanceof Resource) {
   					// This is a type selector
   					selector = new PropertySelector((URI) obj);
   					out.setProperty(selector);
   				} else if (obj instanceof Literal) {
   					Literal domainL = (Literal) obj;
   					// TODO: catch bad expressions? throw exceptions?
+  					if (domainL.getDatatype().equals(FresnelCoreTypes.fslSelector)) {
+  						selector = new FSESelector(domainL.getLabel(), _fslContext, conf.getNamespaceMap());
+  						out.setProperty(selector);
+  					}
   					if (domainL.getDatatype().equals(FresnelCoreTypes.sparqlSelector)) {
   						selector = new SPARQLSelector(domainL.getLabel(), conf.getNamespaces());
   						out.setProperty(selector);
   					}
   				} else {
     				throw new ParsingException("Expected but did not find a resource value for fresnel:property");
     			}
     		}
     		pdSI.close();
 
     		pdSI = conn.getStatements(selected, FresnelCore.sublens, (Value) null, false);
     		while (pdSI.hasNext()) {
     			Statement stmt = (Statement) pdSI.next();
     			Value obj = stmt.getObject();
     			if (obj instanceof Resource) {
     				Resource objRes = (Resource) obj;
     				Lens sublens = (!objRes.equals(lens.getIdentifier())) ? conf.lensLookup(objRes) : lens;
     				out.addSublens(sublens);
     			} else if (obj instanceof Literal) {
     				// you could implement a fresnel-querying component for finding lenses here
     				// we chose not to
     			} else {
     				throw new ResourceNotFoundException("Expected but did not find a resource value for fresnel:sublens");
     			}            
     		}
     		pdSI.close();
 
     		pdSI = conn.getStatements(selected, FresnelCore.depth, (Value) null, false);
     		if (!pdSI.hasNext()) out.setDepth(DEFAULT_MAX_DEPTH);
     		while (pdSI.hasNext()) {
     			Statement stmt = (Statement) pdSI.next();
     			if (pdSI.hasNext())
     				throw new UnresolvableException("More than one fresnel:depth predicate used.");
 
     			Value obj = stmt.getObject();
     			if (obj instanceof Literal && Integer.parseInt(((Literal) stmt.getObject()).getLabel()) >= 0) {
     				out.setDepth(Integer.parseInt(((Literal) stmt.getObject()).getLabel()));
     			} else {
     				throw new ParsingException("Expected but did not find a non-negative integer value for fresnel:depth");
     			}
     		}
     		pdSI.close();
 
     		pdSI = conn.getStatements(selected, FresnelCore.use, (Value) null, false);
     		while (pdSI.hasNext()) {
     			Statement stmt = (Statement) pdSI.next();
     			if (pdSI.hasNext())
     				throw new UnresolvableException("More than one fresnel:use predicate used.");
 
     			Value obj = stmt.getObject();
     			if (obj instanceof Resource) {
     				Resource objRes = (Resource) obj;
     				try {
     					Group objGroup = conf.groupLookupOrAdd(objRes);
     					out.setGroupUse(objGroup);
     				} catch (ResourceNotFoundException e) {
     					// if not a group, try a format
     					try {
     						Format objFormat = conf.formatLookup(objRes);
     						out.setFormatUse(objFormat);
     					} catch (ResourceNotFoundException re) {
     						// if not a style, there's nothing to fall back to
     						throw new ParsingException("Failed to find useful description of fresnel:use object: " + ((URI) objRes).toString());
     					}
     				}
     			} else {
     				throw new ParsingException("Expected but did not find a resource value for fresnel:use");
     			}
     		}
     		pdSI.close();
     		conn.close();
     	} catch (RepositoryException e) {
         	// TODO: how to handle this exception
         }
         return out;
     }
 
     /**
      * @see edu.mit.simile.fresnel.selection.ISelector#selectStatements(Repository, Resource)
      */
     public Iterator<Statement> selectStatements(Repository in, Resource selected) throws InvalidResultSetException {
     	
     	Iterator<Statement> si = _propertySelector.selectStatements(in, selected);
     		
     	return si;
     }
 
     /**
      * @see edu.mit.simile.fresnel.selection.ISelector#canSelectStatements()
      */
     public boolean canSelectStatements() {
         return this._statements;
     }
 
     /**
      * @see edu.mit.simile.fresnel.selection.ISelector#selectResources(Repository)
      */
     public Iterator<Resource> selectResources(Repository in) throws InvalidResultSetException {
         throw new InvalidResultSetException("PropertyDescription cannot be used to select resources");
     }
 
     /**
      * @see edu.mit.simile.fresnel.selection.ISelector#canSelectResources()
      */
     public boolean canSelectResources() {
         return this._resources;
     }
 
     /**
      * @see edu.mit.simile.fresnel.selection.ISelector#selectNodes(Repository)
      */
     public Iterator<Value> selectNodes(Repository in) throws InvalidResultSetException {
         throw new InvalidResultSetException("PropertyDescription cannot be used to select object nodes");
     }
 
     /**
      * @see edu.mit.simile.fresnel.selection.ISelector#canSelectNodes()
      */
     public boolean canSelectNodes() {
         return this._nodes;
     }
 
     /**
      * @see edu.mit.simile.fresnel.selection.ISelector#canSelect(Repository, Resource, URI)
      */
 	public boolean canSelect(Repository in, Resource selected, URI prop) {
 		boolean out = false;
 		
 		out = _propertySelector.canSelect(in, selected, prop);
 
 		return out;
 	}
 	
     /**
      * @see edu.mit.simile.fresnel.selection.ISelector#canSelect(Repository, Resource)
      */
     public boolean canSelect(Repository in, Resource selected) {
 			boolean out = false;
 			
 			out = _propertySelector.canSelect(in, selected);
 			
 	    return out;
     }
 
     /**
      * @see edu.mit.simile.fresnel.selection.ISelector#canSelect(Repository, Value)
      */
     public boolean canSelect(Repository in, Value selected) {
         return this._nodes;
     }
     
     /**
      * @see java.lang.Object#toString()
      */
     public String toString() {
         String state = "   [ISelector:PropertyDescription " + super.toString() + "]\n";
         state += "   " + this._id + "\n";
         state += "   property_selector: " + this._propertySelector.toString() + "\n";
         state += "   depth: " + this._depth + "\n";
         state += "   " + this._sublenses + "\n";
         return state;
     }
 }
Index: trunk/simile-fresnel/src/main/java/edu/mit/simile/fresnel/configuration/Configuration.java
===================================================================
--- trunk/simile-fresnel/src/main/java/edu/mit/simile/fresnel/configuration/Configuration.java (revision 2)
+++ trunk/simile-fresnel/src/main/java/edu/mit/simile/fresnel/configuration/Configuration.java (revision 45)
@@ -309,837 +309,909 @@
 				} catch (UnresolvableException u) {
 					gather(u);
 				}
 			}
 			it.close();
 
 			it = conn.getStatements((Resource) null, FresnelCore.classFormatDomain, (Value) null, false);
 			while (it.hasNext()) {
 				try {
 					Statement formatResourceStatement = (Statement) it.next();
 					ClassFormat format = (ClassFormat) ClassFormat.parse(this._source, formatResourceStatement.getSubject(), this);
 					if (!this._all.containsKey(format.getIdentifier())) addClassFormat(format);
 				} catch (ParsingException e) {
 					gather(e);
 				} catch (UnresolvableException u) {
 					gather(u);
 				}
 			}
 			it.close();
 
 			// EXTENSION for declaring facets - not part of core Fresnel vocabulary
 			this._facets.clear();
 			it = conn.getStatements((Resource) null, Facets.facets, (Value) null, false);
 			while (it.hasNext()) {
 				try {
 					Statement facetStatement = (Statement) it.next();
 					FacetSet facetset = FacetSet.parse(this._source, facetStatement.getSubject());
 					if (!this._all.containsKey(facetset.getIdentifier())) addFacetSet(facetset);
 				} catch (Exception e) {
 					gather(e);
 				}
 			}
 			it.close();
 
 			// also catch even if it only has to do with hiding
 			it = conn.getStatements((Resource) null, Facets.hides, (Value) null, false);
 			while (it.hasNext()) {
 				try {
 					Statement facetStatement = (Statement) it.next();
 					FacetSet facetset = FacetSet.parse(this._source, facetStatement.getSubject());
 					if (!this._all.containsKey(facetset.getIdentifier())) addFacetSet(facetset);
 				} catch (Exception e) {
 					gather(e);
 				}
 			}
 			it.close();
 
 			// get a list of unique resources that are a group by direct inference
 			it = conn.getStatements((Resource) null, FresnelCore.group, (Value) null, false);
 			while (it.hasNext()) {
 				try {
 					Statement groupStatement = (Statement) it.next();
 					Resource groupMember = groupStatement.getSubject();
 					Resource groupResource = null;
 					Value groupValue = groupStatement.getObject();
 					if (groupValue instanceof Resource)
 						groupResource = (Resource) groupValue;
 					else
 						throw new UnresolvableException("Group referred to is not a resource: " + groupValue);
 					boolean exists = this._groups.containsKey(groupResource);
 					Group group = exists ?
 							(Group) this._groups.get(groupResource) :
 								Group.parse(this._source, groupResource, this);
 
 							try {
 								group.addLens(lensLookup(groupMember));
 							} catch (ResourceNotFoundException e) {
 								try {
 									group.addFormat(formatLookup(groupMember));
 								} catch (ResourceNotFoundException re) {
 									throw new ParsingException("Could not find useful parsing information for resource: " + ((URI) groupMember).toString());
 								}
 							}
 
 							// Group only needs to be parsed once, don't add it if it already exists
 							if (!exists) {
 								addGroup(group);
 							}
 				} catch (ParsingException e) {
 					gather(e);
 				} catch (UnresolvableException u) {
 					gather(u);
 				}
 			}
 			it.close();
 			conn.close();
 		} catch (RepositoryException e) {
 			throw new UnresolvableException("Problem connecting to repository: " + e.getLocalizedMessage());
 		}
 	}
 
 	/**
 	 * Internal method for adding instance lenses consistently.
 	 * 
 	 * @param lens <code>InstanceLens</code> to add to configuration
 	 */
 	private void addInstanceLens(Lens lens) {
 		this._lenses.add(lens);
 		this._all.put(lens.getIdentifier(), lens);
 
 		for (Iterator<ISelector> di = lens.getDomainSet().iterator(); di.hasNext(); ) {
 			ISelector domain = di.next();
 			// TODO other valid selector types may need to be integrated, such as FSE/SPARQL selectors
 			if (domain instanceof InstanceSelector) {
 				InstanceSelector is = (InstanceSelector) domain;
 				LensMatchSet lms = this._instanceLensMatches.getMatch(is.getInstance());
 				if (null == lms) {
 					lms = new LensMatchSet(is.getInstance());
 				}
 				lms.add(lens);
 				this._instanceLensMatches.putMatch(is.getInstance(), lms);
 			}
 		}
 	}
 
 	/**
 	 * Internal method for adding lenses consistently.
 	 * 
 	 * @param lens <code>Lens</code> to add to configuration.
 	 */
 	private void addLens(Lens lens) {
 		this._lenses.add(lens);
 		this._all.put(lens.getIdentifier(), lens);
 
 		for (Iterator<ISelector> di = lens.getDomainSet().iterator(); di.hasNext(); ) {
 			TypeSelector ts = (TypeSelector) di.next();
 			LensMatchSet lms = this._classLensMatches.getMatch(ts.getType());
 			if (null == lms) {
 				lms = new LensMatchSet(ts.getType());
 			}
 			lms.add(lens);
 			this._classLensMatches.putMatch(ts.getType(), lms);
 		}
 	}
 
 	/**
 	 * Internal method for adding formats consistently.
 	 * 
 	 * @param style <code>Format</code> to add to configuration.
 	 */
 	private void addPropertyFormat(Format format) {
 		this._formats.add(format);
 		this._all.put(format.getIdentifier(), format);        
 	}
 
 	/**
 	 * Internal method for adding instance formats consistently.
 	 * 
 	 * @param style <code>Format</code> to add to configuration.
 	 */
 	private void addInstanceFormat(Format format) {
 		this._formats.add(format);
 		this._all.put(format.getIdentifier(), format);        
 	}
 
 	/**
 	 * Internal method for adding class formats consistently.
 	 * 
 	 * @param style <code>Format</code> to add to configuration.
 	 */
 	private void addClassFormat(Format format) {
 		this._formats.add(format);
 		this._all.put(format.getIdentifier(), format);        
 	}
 
 	/**
 	 * EXTENSION for declaring facets
 	 * 
 	 * @param fs A set of facets
 	 */
 	private void addFacetSet(FacetSet fs) {
 		if (fs.isForAll())
 			this._facets.setDefaultSet(fs);
 		else {
 			for (Iterator<Resource> ti = fs.getForTypes(); ti.hasNext(); ) {
 				this._facets.putFacetSet(ti.next(), fs);
 			}
 		}
 		this._all.put(fs.getIdentifier(), fs);
 	}
 
 	/**
 	 * Internal method for adding groups consistently.
 	 * 
 	 * @param group <code>Group</code> to add to configuration.
 	 */
 	private void addGroup(Group group) {
 		this._groups.put(group.getIdentifier(), group);
 		this._groupOrder.add(group.getIdentifier());
 		this._all.put(group.getIdentifier(), group);        
 	}
 
 	/**
 	 * Selects based on lens matches, outputs an intermediate XML tree.
 	 * 
 	 * @param in The data <code>Repository</code>
 	 * @return A subgraph <code>Selection</code>
 	 * @throws ParserConfigurationException When a problem with the XML parsing code is encountered
 	 * @throws NoResultsException When no results can be generated from the given configuration and data
 	 */
-	public Selection select(Repository in) throws NoResultsException, ParserConfigurationException {
+	public Selection select(Repository in, String langPref) throws NoResultsException, ParserConfigurationException {
 		Selection answer = null;
 
 		Group group = null;
 		if (this._groups.size() > 0) {
 			// this just takes the first group if it's undefined;
 			// a smarter way to do it would be to do some fast analysis on which
 			// group matches the most resources
 			for (Iterator<Resource> groupIt = this._groupOrder.iterator(); groupIt.hasNext(); ) {
 				Resource groupRes = (Resource) groupIt.next();
 				Group groupCandidate = this._groups.getGroup(groupRes);
 				if (groupCandidate.getLenses().size() > 0) {
 					group = groupCandidate;
 					break;
 				}
 			}
 		}
 
 		if (null == group) {
 			// put everything in a default group if no groups containing lenses exists
 			group = new Group(DEFAULT_GROUP);
 			for (Lens l : this._lenses) {
 				group.addLens(l);
 			}
 
 			for (Format f : this._formats) {
 				group.addFormat(f);
 			}
 		}
 
-		answer = select(in, group);
+		answer = select(in, group, langPref);
 		return answer;
 	}
 
 	/**
 	 * Selects based on lens matches and a group of interest, outputs an intermediate XML tree.
 	 * 
 	 * @param in The input data <code>Model</code>
 	 * @param grouping The <code>Group</code> of lenses and styles to use
 	 * @return A subgraph <code>Selection</code>
 	 * @throws ParserConfigurationException When a problem with the XML parsing code is encountered
 	 * @throws NoResultsException When no results can be generated from the given configuration and data
 	 */
-	public Selection select(Repository in, Group grouping) throws ParserConfigurationException, NoResultsException {
+	public Selection select(Repository in, Group grouping, String langPref) throws ParserConfigurationException, NoResultsException {
 		this._mainGroup = grouping;
 		// immediate exception if no lenses exist
 		if (this._lenses.size() == 0)
 			throw new NoResultsException("There are no lenses defined!");
 
 		// execute every lens for pre-selection, make a lensMatch for every resource
 		// that gets selected.  keep adding to the lensMatch per resource until all
 		// matches are found (all lenses are executed).
 		Vector<Resource> validStarts = new Vector<Resource>();
 		if (grouping.hasPrimaries()) {
 			Iterator<ISelector> primariesIt = grouping.getPrimaries().iterator();
 			while (primariesIt.hasNext()) {
 				ISelector primary = primariesIt.next();
 				if (primary.canSelectResources()) {
 					try {
 						Iterator<Resource> valids = primary.selectResources(in);
 						while (valids.hasNext()) {
 							validStarts.add(valids.next());
 						}
 					} catch (InvalidResultSetException e) {
 						// not a valid exception at this point
 					}
 				}
 			}
 		} else {
 			validStarts = null;
 		}
 
 		Iterator<Lens> li = grouping.getLenses().iterator();
 		while (li.hasNext()) {
 			Lens lens = li.next();
 			Iterator<ISelector> di = lens.getDomainSet().iterator();
 			while (di.hasNext()) {
 				ISelector select = di.next();
 				if (select.canSelectResources()) {
 					try {
 						Iterator<Resource> ri = select.selectResources(in);
 						while (ri.hasNext()) {
 							Resource res = (Resource) ri.next();
 							if (null == validStarts || (null != validStarts && validStarts.contains(res))) {
 								if (this._lensMatches.containsKey(res)) {
 									LensMatchSet match = this._lensMatches.getMatch(res);
 									match.add(lens);
 								} else {
 									LensMatchSet match = new LensMatchSet(res);
 									match.add(lens);
 									this._lensMatches.putMatch(res, match);
 								}
 							}
 						}
 					} catch (InvalidResultSetException e) { 
 						//
 					}
 				}
 			}
 		}
 
 		// exception if no matches
 		if (this._lensMatches.size() == 0)
 			throw new NoResultsException("No lenses matching the data could be found.");
 
 		Selection answer = new Selection(this);
+		answer.setLangPref(langPref);
 
 		Iterator<?> resources = this._lensMatches.keySet().iterator();
 		while (resources.hasNext()) {
 			Resource subject = (Resource) resources.next();
 			LensMatchSet match = this._lensMatches.getMatch(subject);
 			Lens best = match.topMatch();
 			answer.addPrimary(answer.applyLens(grouping, in, best, subject, 0, MAXIMUM_LENS_DEPTH));
 		}
 
 		return answer;
 	}
 
 	/**
 	 * Select specific resource based on lens matches, outputs a Fresnel-specific Selection.
 	 * 
 	 * @param in The data <code>Repository</code>
 	 * @param focus The specific <code>Resource</code> to use Fresnel on
 	 * @return A subgraph <code>Selection</code>
 	 * @throws ParserConfigurationException When a problem with the XML parsing code is encountered
 	 * @throws NoResultsException When no results can be generated from the given configuration and data
 	 */
-	public Selection select(Repository in, Resource focus) throws NoResultsException, ParserConfigurationException {
+	public Selection select(Repository in, Resource focus, String langPref) throws NoResultsException, ParserConfigurationException {
 		Selection answer = null;
 
 		Group group = null;
 		if (this._groups.size() > 0) {
 			// this just takes the first group if it's undefined;
 			// a smarter way to do it would be to do some fast analysis on which
 			// group matches the most resources
 			for (Iterator<Resource> groupIt = this._groupOrder.iterator(); groupIt.hasNext(); ) {
 				Resource groupRes = (Resource) groupIt.next();
 				Group groupCandidate = this._groups.getGroup(groupRes);
 				if (groupCandidate.getLenses().size() > 0) {
 					group = groupCandidate;
 					break;
 				}
 			}
 		}
 
 		if (null == group) {
 			// put everything in a default group if no groups containing lenses exists
 			group = new Group(DEFAULT_GROUP);
 			for (Lens l : this._lenses) {
 				group.addLens(l);
 			}
 
 			for (Format f : this._formats) {
 				group.addFormat(f);
 			}
 		}
 
-		answer = select(in, focus, group);
+		answer = select(in, focus, group, langPref);
 		return answer;
 	}
 
 	/**
 	 * Internal selection mechanism, returns matches.
 	 */
 	private LensMatchSet _select(Repository in, Resource focus, Group grouping) throws ParserConfigurationException, NoResultsException {
 		this._mainGroup = grouping;
 		// immediate exception if no lenses exist
 		if (this._lenses.size() == 0)
 			throw new NoResultsException("There are no lenses defined!");
 
 		// execute every lens for pre-selection, make a lensMatch for every resource
 		// that gets selected.  keep adding to the lensMatch per resource until all
 		// matches are found (all lenses are executed).
 		Vector<Resource> validStarts = new Vector<Resource>();
 		if (grouping.hasPrimaries()) {
 			Iterator<ISelector> primariesIt = grouping.getPrimaries().iterator();
 			while (primariesIt.hasNext()) {
 				ISelector primary = primariesIt.next();
 				if (primary.canSelectResources()) {
 					try {
 						Iterator<Resource> valids = primary.selectResources(in);
 						while (valids.hasNext()) {
 							validStarts.add(valids.next());
 						}
 					} catch (InvalidResultSetException e) {
 						// not a valid exception at this point
 					}
 				}
 			}
 		} else {
 			validStarts = null;
 		}
 
 		LensMatchSet match = null;
 
 		Iterator<Lens> li = grouping.getLenses().iterator();
 		while (li.hasNext()) {
 			Lens lens = li.next();
 			Iterator<ISelector> di = lens.getDomainSet().iterator();
 			while (di.hasNext()) {
 				ISelector select = di.next();
 				if (select.canSelectResources()) {
 					if (select.canSelect(in, focus)) {
 						if (null == validStarts || (null != validStarts && validStarts.contains(focus))) {
 							if (this._lensMatches.containsKey(focus)) {
 								match = this._lensMatches.getMatch(focus);
 								match.add(lens);
 							} else {
 								match = new LensMatchSet(focus);
 								match.add(lens);
 								this._lensMatches.putMatch(focus, match);
 							}
 						}
 					}
 				}
 			}
 		}
 
 		return match;
 	}	
 
 	/**
 	 * Selects based on lens matches and a group of interest and a lens purpose, outputs an intermediate XML tree.
 	 * 
 	 * @param in The input data <code>Model</code>
 	 * @param focus The specific <code>Resource</code> to use Fresnel on
 	 * @param grouping The <code>Group</code> of lenses and styles to use
 	 * @param purpose The <code>Purpose</code> of the lens
 	 * @return A subgraph <code>Selection</code>
 	 * @throws ParserConfigurationException When a problem with the XML parsing code is encountered
 	 * @throws NoResultsException When no results can be generated from the given configuration and data
 	 */
-	public Selection select(Repository in, Resource focus, Group grouping, Purpose purpose) throws ParserConfigurationException, NoResultsException {
+	public Selection select(Repository in, Resource focus, Group grouping, Purpose purpose, String langPref) throws ParserConfigurationException, NoResultsException {
 		if (null == purpose)
-			return select(in, focus, grouping);
+			return select(in, focus, grouping, langPref);
 
 		LensMatchSet match = _select(in, focus, grouping);
 
 		// exception if no matches
 		if (null == match)
 			throw new NoResultsException("No lenses matching the data could be found.");
 
 		Selection answer = new Selection(this);
+		answer.setLangPref(langPref);
 
 		Lens best = match.topMatch();
 
 		// check purposes
 		for (Iterator<Lens> pli = match.lensIterator(); pli.hasNext(); ) {
 			Lens potential = pli.next();
 			if (potential.hasPurpose(purpose)) {
 				best = potential;
 				break;
 			}
 		}
 		answer.addPrimary(answer.applyLens(grouping, in, best, focus, 0, MAXIMUM_LENS_DEPTH));
 
 		return answer;
 	}
+	
+	/**
+	 * Selects based on lens matches and a group of interest and a lens purpose, outputs an intermediate XML tree.
+	 * 
+	 * @param in The input data <code>Model</code>
+	 * @param focus The specific <code>Resource</code> to use Fresnel on
+	 * @param grouping The <code>Group</code> of lenses and styles to use
+	 * @param purpose The <code>Purpose</code> of the lens
+	 * @return A subgraph <code>Selection</code>
+	 * @throws ParserConfigurationException When a problem with the XML parsing code is encountered
+	 * @throws NoResultsException When no results can be generated from the given configuration and data
+	 */
+	public Selection select(Repository in, Resource focus, Purpose purpose, String langPref) throws ParserConfigurationException, NoResultsException {
+		if (null == purpose)
+			return select(in, focus, langPref);
+
+		Group group = null;
+		if (this._groups.size() > 0) {
+			// this just takes the first group if it's undefined;
+			// a smarter way to do it would be to do some fast analysis on which
+			// group matches the most resources
+			for (Iterator<Resource> groupIt = this._groupOrder.iterator(); groupIt.hasNext(); ) {
+				Resource groupRes = (Resource) groupIt.next();
+				Group groupCandidate = this._groups.getGroup(groupRes);
+				if (groupCandidate.getLenses().size() > 0) {
+					group = groupCandidate;
+					break;
+				}
+			}
+		}
+
+		if (null == group) {
+			// put everything in a default group if no groups containing lenses exists
+			group = new Group(DEFAULT_GROUP);
+			for (Lens l : this._lenses) {
+				group.addLens(l);
+			}
+
+			for (Format f : this._formats) {
+				group.addFormat(f);
+			}
+		}
+		
+		return select(in, focus, group, purpose, langPref);
+	}	
 
 	/**
 	 * Selects based on lens matches and a group of interest, outputs an intermediate XML tree.
 	 * 
 	 * @param in The input data <code>Model</code>
 	 * @param focus The specific <code>Resource</code> to use Fresnel on
 	 * @param grouping The <code>Group</code> of lenses and styles to use
 	 * @return A subgraph <code>Selection</code>
 	 * @throws ParserConfigurationException When a problem with the XML parsing code is encountered
 	 * @throws NoResultsException When no results can be generated from the given configuration and data
 	 */
-	public Selection select(Repository in, Resource focus, Group grouping) throws ParserConfigurationException, NoResultsException {
+	public Selection select(Repository in, Resource focus, Group grouping, String langPref) throws ParserConfigurationException, NoResultsException {
 		LensMatchSet match = _select(in, focus, grouping);
 
 		// exception if no matches
 		if (null == match)
 			throw new NoResultsException("No lenses matching the data could be found.");
 
 		Selection answer = new Selection(this);
-
+		answer.setLangPref(langPref);
+		
 		Lens best = match.topMatch();
 		answer.addPrimary(answer.applyLens(grouping, in, best, focus, 0, MAXIMUM_LENS_DEPTH));
 
 		return answer;
 	}
 
 	/**
 	 * Formats the subgraph selected by a select() call according to Fresnel formatting
 	 * configuration.
 	 * 
 	 * @param in The data <code>Repository</code>
 	 * @param select The previously generated <code>Selection</code>
 	 * @return A <code>Selection</code> with formatting information.
 	 */
 	public Selection format(Repository in, Selection select) {
 		Group grouping = this._mainGroup;
 		// RESOURCES
 		// execute every format for pre-selection, make a formatMatch for every resource
 		// that gets selected.  keep adding to the lensMatch per resource until all
 		// matches are found (all formats are executed).
 		Iterator<Format> fi = grouping.getFormats().iterator();
 		Format defaultFormat = new Format(DEFAULT_FORMAT);
 		while (fi.hasNext()) {
 			Format format = fi.next();
+			
 			Iterator<ISelector> di = format.getDomainSet().iterator();
 			while (di.hasNext()) {
 				ISelector selects = di.next();
 				if (selects.canSelectResources()) {
+					/*
+					 * Only ClassFormat and InstanceFormat select resources,
+					 * so the vast amount of property formats can be skipped
+					 */
+					if (!(format instanceof ClassFormat || format instanceof InstanceFormat))
+						continue;
+					
 					try {
 						Iterator<Resource> ri = selects.selectResources(in);
 						while (ri.hasNext()) {
 							Resource res = ri.next();
 							if (this._formatResourceMatches.containsKey(res)) {
 								ResourceFormatMatchSet match = this._formatResourceMatches.get(res);
 								match.addClassFormat(format);
 							} else {
 								ResourceFormatMatchSet match = new ResourceFormatMatchSet(res);
 								match.addClassFormat(format);
 								this._formatResourceMatches.put(res, match);
 							}
 						}
 					} catch (InvalidResultSetException e) {
 						// TODO
 					}
 				} else if (selects.canSelectStatements()) {
 					// inefficient - should really ask the model via sparql or something
 					// about all the predicates it contains
 					try {
 						Iterator<Statement> si = selects.selectStatements(select.getModel(), null);
 						while (si.hasNext()) {
 							URI prop = si.next().getPredicate();
 							if (this._formatPropertyMatches.containsKey(prop)) {
 								PropertyFormatMatchSet match = this._formatPropertyMatches.get(prop);
 								match.addPropertyFormat(format);
 							} else {
 								PropertyFormatMatchSet match = new PropertyFormatMatchSet(prop);
 								match.addPropertyFormat(format);
 								this._formatPropertyMatches.put(prop, match);
 							}
 						}
 						si = selects.selectStatements(select.getNotModel(), null);
 						while (si.hasNext()) {
 							URI prop = si.next().getPredicate();
 							if (this._formatPropertyMatches.containsKey(prop)) {
 								PropertyFormatMatchSet match = this._formatPropertyMatches.get(prop);
 								match.addPropertyFormat(format);
 							} else {
 								PropertyFormatMatchSet match = new PropertyFormatMatchSet(prop);
 								match.addPropertyFormat(format);
 								this._formatPropertyMatches.put(prop, match);
 							}
 						}
 					} catch (InvalidResultSetException e) { ; }
 				}
 			}
 		}		
 
 		// er...in retrospect, subjects is the wrong word - it's any resource, be it subject or
 		// object with no predicates of its own
 		Iterator<?> subjects = select.getResourceHash().keySet().iterator();
 		while (subjects.hasNext()) {
 			Resource subject = (Resource) subjects.next();
 			ResourceFormatMatchSet match = this._formatResourceMatches.get(subject);
 			select.applyFormat(grouping, (null != match) ? match.topMatch() : defaultFormat, subject, Selection.RESOURCE, in);
 		}
 
 		// must go through *all* the properties!
 
 		// some class of stuff says this property would have been selected if it existed (not sure how
 		// this goes with FSL...), then when formatting comes along, fill it in with contentNoValue if
 		// a Format exists; if not, show nothing
 
 		Iterator<?> properties = select.getPropertyHash().keySet().iterator();
 		while (properties.hasNext()) {
 			URI subject = (URI) properties.next();
 			PropertyFormatMatchSet match = this._formatPropertyMatches.get(subject);
 			select.applyFormat(grouping,  (null != match) ? match.topMatch() : defaultFormat, subject, Selection.PROPERTY, in);
 		}
 
 		return select;
 	}
 
 	/**
 	 * Find an existing lens for re-use in another context outside straight parsing,
 	 * such as sublens parsing; parse and add the lens if not found.
 	 * 
 	 * @param identifier The <code>Resource</code> identifying the lens
 	 * @return The found <code>Lens</code>
 	 * @throws ParsingException If the lens is not found anywhere or if there are problems parsing the lens
 	 * @throws UnresolvableException If there are problems parsing the lens
 	 */
 	public Lens lensLookup(Resource identifier) throws ParsingException, UnresolvableException, ResourceNotFoundException {
 		Lens out = null;
 		if (this._all.containsKey(identifier) && this._lenses.contains(this._all.get(identifier)))
 			out = (Lens) this._all.get(identifier);
 		else {
+			RepositoryConnection conn = null;
 			try {
-				RepositoryConnection conn = this._source.getConnection();
+				conn = this._source.getConnection();
 				if (conn.hasStatement(identifier, FresnelCore.instanceLensDomain, (Value) null, false)) {
 					out = new InstanceLens(this._source, identifier, this);
 					addInstanceLens(out);
 				} else if (conn.hasStatement(identifier, FresnelCore.classLensDomain, (Value) null, false)) {
 					out = new Lens(this._source, identifier, this);
 					addLens(out);
 				} else {
 					throw new ResourceNotFoundException("Explicitly named lens not found in configuration");
 				}
-				conn.close();
 			} catch (RepositoryException e) {
 				throw new UnresolvableException("Problem connecting to repository: " + e.getLocalizedMessage());
+			}
+			finally {
+				try {
+					conn.close();
+				}
+				catch (RepositoryException e) {
+				}
 			}
 		}
 		return out;
 	}
 
 	/**
 	 * Lookup an existing group or parse a new one into the configuration
 	 * 
 	 * @param identifier The <code>Resource</code> identifier
 	 * @return A <code>Group</code>
 	 * @throws ParsingException If a parsing error occurs in creating a new group
 	 * @throws UnresolvableException If an unresolvable error occurs in creating a new group
 	 */
 	public Group groupLookupOrAdd(Resource identifier) throws ParsingException, UnresolvableException, ResourceNotFoundException {
 		Group out = null;
 		if (this._all.containsKey(identifier) && this._groups.containsKey(identifier))
 			out = (Group) this._all.get(identifier);
 		else {
+			RepositoryConnection conn = null;
 			try {
-				RepositoryConnection conn = this._source.getConnection();
+				conn = this._source.getConnection();
 				if (conn.hasStatement((Resource) null, FresnelCore.group, (Value) identifier, false)) {
 					out = Group.parse(this._source, identifier, this);
 					addGroup(out);
 				} else {
 					throw new ResourceNotFoundException("Explicitly named group not found in configuration");
 				}
-				conn.close();
 			} catch (RepositoryException e) {
 				throw new UnresolvableException("Problems connecting to repository: " + e.getLocalizedMessage());
+			}
+			finally {
+				if (conn != null)
+					try {
+						conn.close();
+					}
+				catch (RepositoryException e) {
+					e.printStackTrace();
+				}
 			}
 		}
 		return out;
 	}
 
 	/**
 	 * Only looks up the group identifier, returns null if no group found.
 	 * 
 	 * @param identifier A <code>Resource</code>
 	 * @return The <code>Group</code> or null if not found
 	 */
 	public Group groupLookup(Resource identifier) {
 		Group out = null;
 		if (this._all.containsKey(identifier) && this._groups.containsKey(identifier))
 			out = (Group) this._all.get(identifier);
 		return out;
 	}
 
 	/**
 	 * Retreives the group currently used by default
 	 * 
 	 * @return A <code>Group</code>
 	 */
 	public Group getCurrentGroup() {
 		Group group = this._mainGroup;
 		if (null == group) {
 			if (this._groups.size() > 0) {
 				// this just takes the first group if it's undefined;
 				// a smarter way to do it would be to do some fast analysis on which
 				// group matches the most resources
 				for (Iterator<Resource> groupIt = this._groupOrder.iterator(); groupIt.hasNext(); ) {
 					Resource groupRes = (Resource) groupIt.next();
 					Group groupCandidate = this._groups.getGroup(groupRes);
 					if (groupCandidate.getLenses().size() > 0) {
 						group = groupCandidate;
 						break;
 					}
 				}
 			}
 
 			if (null == group) {
 				// put everything in a default group if no groups containing lenses exists
 				group = new Group(DEFAULT_GROUP);
 			}
 		}
 
 		return group;
 	}
 
 	/**
 	 * Lookup an existing format or parse it into configuration if it does not exist.
 	 * 
 	 * @param identifier The <code>Format</code> identifier to lookup
 	 * @return A <code>Format</code>
 	 * @throws ParsingException If there are parsing errors in making a new format
 	 * @throws UnresolvableException If there are unresolvable errors in making a new format
 	 */
 	public Format formatLookup(Resource identifier) throws ParsingException, UnresolvableException, ResourceNotFoundException {
 		Format out = null;
 		if (this._all.containsKey(identifier) && this._formats.contains(this._all.get(identifier)))
 			out = (Format) this._all.get(identifier);
 		else {
 			try {
 				RepositoryConnection conn = this._source.getConnection();
 				if (conn.hasStatement(identifier, FresnelCore.propertyFormatDomain, (Value) null, false)) {
 					out = Format.parse(this._source, identifier, this);
 					addPropertyFormat(out);
 				} else if (conn.hasStatement(identifier, FresnelCore.instanceFormatDomain, (Value) null, false)) {
 					out = InstanceFormat.parse(this._source, identifier, this);
 					addInstanceFormat(out);
 				} else if (conn.hasStatement(identifier, FresnelCore.classFormatDomain, (Value) null, false)) {
 					out = ClassFormat.parse(this._source, identifier, this);
 					addClassFormat(out);
 				} else {
 					throw new ResourceNotFoundException("Explicitly named style not found in configuration");
 				}
 				conn.close();
 			} catch (RepositoryException e) {
 				throw new UnresolvableException("Problem connecting to repository: " + e.getLocalizedMessage());
 			}
 		}
 		return out;
 	}
 
 	/**
 	 * Fetch all the groups in the configuration, probably for UI purposes
 	 * 
 	 * @return A <code>Vector</code> of configured group values
 	 */
 	public Vector<Group> groups() {
 		return new Vector<Group>(this._groups.values());
 	}
 
 	/**
 	 * EXTENSION method for finding facets per class
 	 *
 	 * @param forClasses A <code>List</code> of <code>Resource</code>s
 	 * @return A <code>List</code> of <code>Resource</code>s
 	 */
 	public List<Resource> facets(Set<?> forClasses) {
 		Vector<Resource> out = new Vector<Resource>();
 		if (this._facets.hasDefaultSet()) {
 			for (Iterator<Facet> fi = this._facets.getDefaultSet().facetIterator(); fi.hasNext(); ) {
 				out.add(fi.next().getIdentifier());
 			}
 		}
 
 		if (null != forClasses) {
 			for (Iterator<?> it = forClasses.iterator(); it.hasNext(); ) {
 				Iterator<FacetSet> fsi = this._facets.getFacetSetIterator((Resource) it.next());
 				if (null != fsi) {
 					while (fsi.hasNext()) {
 						for (Iterator<Facet> fi = fsi.next().facetIterator(); fi.hasNext(); ) {
 							Facet nextF = fi.next();
 							if (!out.contains(nextF))
 								out.add(nextF.getIdentifier());
 						}
 					}
 				}
 			}
 		}
 
 		return out;
 	}
 
 	/**
 	 * EXTENSION method for finding hidden facets per class
 	 *
 	 * @param forClasses A <code>List</code> of <code>Resource</code>s
 	 * @return A <code>List</code> of <code>Resource</code>s
 	 */
 	public List<Resource> hiddenFacets(Set<?> forClasses) {
 		Vector<Resource> out = new Vector<Resource>();
 		if (this._facets.hasDefaultSet()) {
 			for (Iterator<Facet> fi = this._facets.getDefaultSet().hideIterator(); fi.hasNext(); ) {
 				out.add(fi.next().getIdentifier());
 			}
 		}
 
 		if (null != forClasses) {
 			for (Iterator<?> it = forClasses.iterator(); it.hasNext(); ) {
 				Iterator<FacetSet> fsi = this._facets.getFacetSetIterator((Resource) it.next());
 				if (null != fsi) {
 					while (fsi.hasNext()) {
 						for (Iterator<Facet> fi = fsi.next().hideIterator(); fi.hasNext(); ) {
 							Facet nextF = fi.next();
 							if (!out.contains(nextF))
 								out.add(nextF.getIdentifier());
 						}
 					}
 				}
 			}
 		}
 
 		return out;
 	}
 
 	/**
 	 * Get the parsed namespace / abbreviation map for FSL.
 	 * 
 	 * @return An <code>FSLNSResolver</code>
 	 */
 	public FSLNSResolver getNamespaceMap() {
 		return this._nsmap;
 	}
 
 	/**
 	 * Get the namespaces of the configuration for SPARQL queries.
 	 * 
 	 * @return A Set<Namespace> set.
 	 */
 	public String getNamespaces() {
 		return this._namespaces;
 	}
 
 	/**
 	 * Retrieve the hash of all lens and resource matches.
 	 * 
 	 * @return A <code>LensMatchHashMap</code>
 	 */
 	public LensMatchHashMap getLensMatches() {
 		return this._lensMatches;
 	}
 
 	/**
 	 * Retreive the hash of all instance lens and resource matches.
 	 * 
 	 * @return A <code>LensMatchHashMap</code>
 	 */
 	public LensMatchHashMap getInstanceLensMatches() {
 		return this._instanceLensMatches;
 	}
 
 	/**
 	 * Retreive the hash of all class lens and resource matches.
 	 * 
 	 * @return A <code>LensMatchHashMap</code>
 	 */
 	public LensMatchHashMap getClassLensMatches() {
 		return this._classLensMatches;
Index: trunk/simile-fresnel/src/main/java/edu/mit/simile/fresnel/FresnelUtilities.java
===================================================================
--- trunk/simile-fresnel/src/main/java/edu/mit/simile/fresnel/FresnelUtilities.java (revision 2)
+++ trunk/simile-fresnel/src/main/java/edu/mit/simile/fresnel/FresnelUtilities.java (revision 33)
@@ -1,166 +1,166 @@
 package edu.mit.simile.fresnel;
 
 import java.io.InputStream;
 import java.util.Iterator;
 import java.util.Vector;
 
 import org.openrdf.model.BNode;
 import org.openrdf.model.Literal;
 import org.openrdf.model.Resource;
 import org.openrdf.model.Statement;
 import org.openrdf.model.URI;
 import org.openrdf.model.Value;
 import org.openrdf.model.impl.BNodeImpl;
 import org.openrdf.model.impl.LiteralImpl;
 import org.openrdf.model.impl.URIImpl;
 import org.openrdf.model.vocabulary.RDF;
 import org.openrdf.repository.Repository;
 import org.openrdf.repository.RepositoryConnection;
 import org.openrdf.repository.RepositoryException;
 import org.openrdf.repository.RepositoryResult;
 import org.openrdf.rio.RDFFormat;
 
 /**
  * Various RDF processing shorthands for Fresnel.
  * 
  * @author ryanlee
  */
 public class FresnelUtilities {
 	/**
 	 * Reads data from a URL in a given syntax into a Sesame repository.
 	 * 
 	 * @param store Add RDF to this <code>LocalRepository</code>
 	 * @param url The <code>String</code> location of the data
 	 * @param syntax The <code>String</code> syntax of the data
 	 * @throws Exception For any problems encountered during read of data from the URL
 	 */
 	public static void read(Repository store, String url, String syntax) throws Exception {
 		RDFFormat format = null;
 		if (syntax.equals("TURTLE") || syntax.equals("N3"))
 			format = RDFFormat.TURTLE;
 		else if (syntax.equals("RDFXML"))
 			format = RDFFormat.RDFXML;
 		else if (syntax.equals("NTRIPLES"))
 			format = RDFFormat.NTRIPLES;
 		if (null != format) {
 			java.net.URL myRDFData = new java.net.URL(url);
 			String baseURI = url;
 			RepositoryConnection conn = store.getConnection();
 			InputStream is = myRDFData.openStream();
 			conn.add(is, baseURI, format);
 			is.close();
 			conn.commit();
 			conn.close();
 		}
 	}
 	
 	/**
 	 * Fetch resources into an iterator that match the property-object pair from the given graph.
 	 * 
 	 * @param in The source <code>Graph</code>
 	 * @param property The <code>URI</code> property to match
 	 * @param object The <code>Value</code> object to match
 	 * @return A Sesame <code>ResourceIterator</code>
 	 */
 	public static Iterator<Resource> listSubjectsWithProperty(Repository in, URI property, Value object) {
 		Vector<Resource> resources = new Vector<Resource>();
 		try {
 			RepositoryConnection conn = in.getConnection();
-            RepositoryResult<Statement> it = conn.getStatements((Resource) null, property, object, false);
+            RepositoryResult<Statement> it = conn.getStatements((Resource) null, property, object, true);
 			while ( it.hasNext() ) {
 				Resource subject = dupResource(it.next().getSubject());
 				if (!resources.contains(subject)) {
 					resources.add(subject);
 				}
 			}
 			it.close();
 			conn.close();
 		} catch (RepositoryException e) {
 			// TODO: how to handle this exception
 		}
 		return resources.iterator();
 	}
 	
 	/**
 	 * Fetch the object value of a resource's property from the given graph.  Only
 	 * returns the first, which is an arbitrary selection. 
 	 * 
 	 * @param in The source <code>Graph</code>
 	 * @param subject The subject <code>Resource</code>
 	 * @param property The property <code>URI</code>
 	 * @return A sesame <code>Value</code>
 	 */
 	public static Value getSinglePropertyValue(Repository in, Resource subject, URI property) {
 		Value out = null;
 		try {
 			RepositoryConnection conn = in.getConnection();
-            RepositoryResult<Statement> it = conn.getStatements(subject, property, (Value) null, false);
+            RepositoryResult<Statement> it = conn.getStatements(subject, property, (Value) null, true);
 			if (it.hasNext()) {
 				out = dupValue(it.next().getObject());				
             }
 			it.close();
 			conn.close();
 		} catch (RepositoryException e) {
 			// TODO: how to handle this exception
 		}
 		return out;
 	}
 	
 	/**
 	 * Fetch the rdf:type of a resource from the given graph.  Only returns the first
 	 * which is an arbitrary selection. 
 	 * 
 	 * @param in The source <code>Repository</code>
 	 * @param subject The subject <code>Resource</code>
 	 * @return A <code>Value</code>
 	 */
 	public static Value getType(Repository in, Resource subject) {
 		return getSinglePropertyValue(in, subject, RDF.TYPE);
 	}
 	
 	/**
 	 * Copy a value so the original can be finalized without locking problems.
 	 * 
 	 * @param v A <code>Value</code>
 	 * @return A copy of the original <code>Value</code>
 	 */
 	public static Value dupValue(Value v) {
 		if (v instanceof Literal)
 			return new LiteralImpl(((Literal) v).getLabel(), ((Literal) v).getDatatype());
 		
 		return dupResource((Resource) v);
 	}
 	
 	/**
 	 * Copy a resource so the original can be finalized without locking problems.
 	 * 
 	 * @param r A <code>Resource</code>
 	 * @return A copy of the original <code>Resource</code>
 	 */
 	public static Resource dupResource(Resource r) {
 		if (r instanceof BNode)
 			return dupBNode((BNode) r);
 		
 		return dupURI((URI) r);
 	}
 	
 	/**
 	 * Copy a URI so the original can be finalized without locking problems.
 	 * 
 	 * @param u A <code>URI</code>
 	 * @return A copy of the original <code>URI</code>
 	 */
 	public static URI dupURI(URI u) {
 		return new URIImpl(u.toString());
 	}
 	
 	/**
 	 * Copy a BNode so the original can be finalized without locking problems.
 	 * 
 	 * @param b A <code>BNode</code>
 	 * @return A copy of the original <code>BNode</code>
 	 */
 	public static BNode dupBNode(BNode b) {
 		return new BNodeImpl(b.getID());
 	}
 }
Index: trunk/simile-fresnel/vocab.xml
===================================================================
--- trunk/simile-fresnel/vocab.xml (revision 2)
+++ trunk/simile-fresnel/vocab.xml (revision 19)
@@ -1,22 +1,22 @@
 <?xml version='1.0' encoding='UTF-8'?>
 <project>
   <modelVersion>4.0.0</modelVersion>
   <groupId>edu.mit.simile</groupId>
   <artifactId>fresnel-vocabularies</artifactId>
   <name>SIMILE Fresnel Vocabularies</name>
   <version>1.2-alpha-SNAPSHOT</version>
   <url>http://simile.mit.edu/repository/fresnel/trunk/</url>
   <distributionManagement>
     <repository>
       <id>simile.mit.edu</id>
       <url>scpexe://simile.mit.edu/var/maven</url>
     </repository>
   </distributionManagement>
   <dependencies>
     <dependency>
       <groupId>org.openrdf</groupId>
       <artifactId>openrdf-model</artifactId>
-      <version>2.0-beta6</version>
+      <version>2.0</version>
     </dependency>
   </dependencies>
 </project>
Index: trunk/simile-fresnel/pom.xml
===================================================================
--- trunk/simile-fresnel/pom.xml (revision 2)
+++ trunk/simile-fresnel/pom.xml (revision 44)
@@ -1,140 +1,140 @@
 <?xml version='1.0' encoding='UTF-8'?>
 <project xmlns="http://maven.apache.org/POM/4.0.0" 
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"
 >
   <modelVersion>4.0.0</modelVersion>
   <groupId>edu.mit.simile</groupId>
   <artifactId>fresnel</artifactId>
   <name>SIMILE Fresnel Engine</name>
   <version>2.0-SNAPSHOT</version>
   <url>http://simile.mit.edu/repository/fresnel/trunk/</url>
   <repositories>
     <repository>
       <id>simile</id>
       <name>SIMILE Maven Repository</name>
       <url>http://simile.mit.edu/maven-proxy</url>
     </repository>
     <repository>
       <releases>
         <enabled>true</enabled>
         <updatePolicy>always</updatePolicy>
         <checksumPolicy>warn</checksumPolicy>
       </releases>
       <snapshots>
         <enabled>false</enabled>
         <updatePolicy>never</updatePolicy>
         <checksumPolicy>fail</checksumPolicy>
       </snapshots>
       <id>aduna-repo</id>
       <name>Aduna Repository</name>
       <url>http://repository.aduna-software.org/maven2</url>
     </repository>
     <repository>
       <id>jfresnel</id>
       <url>http://jfresnel.gforge.inria.fr/maven</url>
     </repository>
   </repositories>
   <distributionManagement>
     <repository>
       <id>simile.mit.edu</id>
       <url>scpexe://simile.mit.edu/var/maven</url>
     </repository>
   </distributionManagement>
   <scm>
     <connection>scm:svn:http://simile.mit.edu/repository/fresnel/trunk/</connection>
     <developerConnection>scm:svn:http://simile.mit.edu/repository/fresnel/trunk/</developerConnection>
     <url>http://simile.mit.edu/viewsvn/fresnel/trunk/</url>
   </scm>
   <build>
     <plugins>
       <plugin>
         <groupId>org.codehaus.mojo</groupId>
         <artifactId>dependency-maven-plugin</artifactId>
         <executions>
           <execution>
             <id>copy-dependencies</id>
             <phase>package</phase>
             <goals>
               <goal>copy-dependencies</goal>
             </goals>
             <configuration>
               <outputDirectory>${project.build.directory}</outputDirectory>
             </configuration>
           </execution>
         </executions>
       </plugin>
       <plugin>
         <inherited>true</inherited>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-source-plugin</artifactId>
         <executions>
           <execution>
             <id>attach-sources</id>
             <goals>
               <goal>jar</goal>
             </goals>
           </execution>
         </executions>
       </plugin>
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-compiler-plugin</artifactId>
         <configuration>
           <source>1.5</source>
           <target>1.5</target>
         </configuration>
       </plugin>
       <plugin>
           <groupId>org.apache.maven.plugins</groupId>
           <artifactId>maven-eclipse-plugin</artifactId>
           <configuration>
               <downloadSources>true</downloadSources>
           </configuration>
       </plugin>
     </plugins>
   </build>
   <dependencies>
     <dependency>
       <groupId>xmlunit</groupId>
       <artifactId>xmlunit</artifactId>
       <version>1.0</version>
       <scope>test</scope>
     </dependency>
-    <dependency>
+    <!-- <dependency>
       <groupId>edu.mit.simile</groupId>
       <artifactId>fresnel-vocabularies</artifactId>
       <version>1.2-alpha-SNAPSHOT</version>
-    </dependency>
+    </dependency> -->
     <dependency>
       <groupId>edu.mit.simile</groupId>
       <artifactId>isaviz-fsl-simile</artifactId>
       <version>0.6.5-SNAPSHOT</version>
     </dependency>
     <dependency>
       <groupId>org.slf4j</groupId>
       <artifactId>slf4j-log4j12</artifactId>
       <version>1.0.1</version>
     </dependency>
     <dependency>
       <groupId>log4j</groupId>
       <artifactId>log4j</artifactId>
       <version>1.2.13</version>
     </dependency>
     <dependency>
       <groupId>velocity</groupId>
       <artifactId>velocity</artifactId>
       <version>1.4</version>
     </dependency>
     <dependency>
       <groupId>commons-collections</groupId>
       <artifactId>commons-collections</artifactId>
       <version>3.0</version>
     </dependency>
     <dependency>
       <groupId>org.openrdf</groupId>
       <artifactId>openrdf-queryparser-sparql</artifactId>
-      <version>2.0-beta6</version>
+      <version>2.0.1</version>
     </dependency>
   </dependencies>
 </project>
Index: trunk/simile-fresnel/.classpath
===================================================================
--- trunk/simile-fresnel/.classpath (revision 36)
+++ trunk/simile-fresnel/.classpath (revision 36)
@@ -0,0 +1,45 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="src/main/java"/>
+	<classpathentry kind="src" path="src/test/java"/>
+	<classpathentry kind="lib" path="target/fresnel-2.0-SNAPSHOT-sources.jar"/>
+	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER"/>
+	<classpathentry kind="lib" path="/Users/Christian/Sites/DBpediaMobile/simile-fresnel/target/aduna-collections-1.3.jar"/>
+	<classpathentry kind="lib" path="/Users/Christian/Sites/DBpediaMobile/simile-fresnel/target/aduna-concurrent-1.4.jar"/>
+	<classpathentry kind="lib" path="/Users/Christian/Sites/DBpediaMobile/simile-fresnel/target/aduna-io-1.3.jar"/>
+	<classpathentry kind="lib" path="/Users/Christian/Sites/DBpediaMobile/simile-fresnel/target/aduna-iteration-1.5.jar"/>
+	<classpathentry kind="lib" path="/Users/Christian/Sites/DBpediaMobile/simile-fresnel/target/aduna-lang-1.4.jar"/>
+	<classpathentry kind="lib" path="/Users/Christian/Sites/DBpediaMobile/simile-fresnel/target/aduna-net-1.5.jar"/>
+	<classpathentry kind="lib" path="/Users/Christian/Sites/DBpediaMobile/simile-fresnel/target/aduna-text-1.3.jar"/>
+	<classpathentry kind="lib" path="/Users/Christian/Sites/DBpediaMobile/simile-fresnel/target/aduna-xml-1.5.jar"/>
+	<classpathentry kind="lib" path="/Users/Christian/Sites/DBpediaMobile/simile-fresnel/target/antlr-2.7.7.jar"/>
+	<classpathentry kind="lib" path="/Users/Christian/Sites/DBpediaMobile/simile-fresnel/target/commons-collections-3.0.jar"/>
+	<classpathentry kind="lib" path="/Users/Christian/Sites/DBpediaMobile/simile-fresnel/target/junit-3.8.1.jar"/>
+	<classpathentry kind="lib" path="/Users/Christian/Sites/DBpediaMobile/simile-fresnel/target/log4j-1.2.13.jar"/>
+	<classpathentry kind="lib" path="/Users/Christian/Sites/DBpediaMobile/simile-fresnel/target/openrdf-query-2.0.jar"/>
+	<classpathentry kind="lib" path="/Users/Christian/Sites/DBpediaMobile/simile-fresnel/target/openrdf-queryalgebra-evaluation-2.0.jar"/>
+	<classpathentry kind="lib" path="/Users/Christian/Sites/DBpediaMobile/simile-fresnel/target/openrdf-queryalgebra-model-2.0.jar"/>
+	<classpathentry kind="lib" path="/Users/Christian/Sites/DBpediaMobile/simile-fresnel/target/openrdf-queryparser-api-2.0.jar"/>
+	<classpathentry kind="lib" path="/Users/Christian/Sites/DBpediaMobile/simile-fresnel/target/openrdf-queryparser-sparql-2.0.jar"/>
+	<classpathentry kind="lib" path="/Users/Christian/Sites/DBpediaMobile/simile-fresnel/target/openrdf-repository-api-2.0.jar"/>
+	<classpathentry kind="lib" path="/Users/Christian/Sites/DBpediaMobile/simile-fresnel/target/openrdf-repository-sail-2.0.jar"/>
+	<classpathentry kind="lib" path="/Users/Christian/Sites/DBpediaMobile/simile-fresnel/target/openrdf-rio-api-2.0.jar"/>
+	<classpathentry kind="lib" path="/Users/Christian/Sites/DBpediaMobile/simile-fresnel/target/openrdf-rio-n3-2.0.jar"/>
+	<classpathentry kind="lib" path="/Users/Christian/Sites/DBpediaMobile/simile-fresnel/target/openrdf-rio-ntriples-2.0.jar"/>
+	<classpathentry kind="lib" path="/Users/Christian/Sites/DBpediaMobile/simile-fresnel/target/openrdf-rio-rdfxml-2.0.jar"/>
+	<classpathentry kind="lib" path="/Users/Christian/Sites/DBpediaMobile/simile-fresnel/target/openrdf-rio-trix-2.0.jar"/>
+	<classpathentry kind="lib" path="/Users/Christian/Sites/DBpediaMobile/simile-fresnel/target/openrdf-rio-turtle-2.0.jar"/>
+	<classpathentry kind="lib" path="/Users/Christian/Sites/DBpediaMobile/simile-fresnel/target/openrdf-sail-api-2.0.jar"/>
+	<classpathentry kind="lib" path="/Users/Christian/Sites/DBpediaMobile/simile-fresnel/target/openrdf-sail-inferencer-2.0.jar"/>
+	<classpathentry kind="lib" path="/Users/Christian/Sites/DBpediaMobile/simile-fresnel/target/openrdf-sail-memory-2.0.jar"/>
+	<classpathentry kind="lib" path="/Users/Christian/Sites/DBpediaMobile/simile-fresnel/target/openrdf-sail-nativerdf-2.0.jar"/>
+	<classpathentry kind="lib" path="/Users/Christian/Sites/DBpediaMobile/simile-fresnel/target/slf4j-api-1.3.0.jar"/>
+	<classpathentry kind="lib" path="/Users/Christian/Sites/DBpediaMobile/simile-fresnel/target/slf4j-log4j12-1.0.1.jar"/>
+	<classpathentry kind="lib" path="/Users/Christian/Sites/DBpediaMobile/simile-fresnel/target/slf4j-simple-1.3.0.jar"/>
+	<classpathentry kind="lib" path="/Users/Christian/Sites/DBpediaMobile/simile-fresnel/target/velocity-1.4.jar"/>
+	<classpathentry kind="lib" path="/Users/Christian/Sites/DBpediaMobile/simile-fresnel/target/openrdf-model-2.0.jar" sourcepath="/Users/Christian/Sites/DBpediaMobile/FresnelView/web/WEB-INF/lib/openrdf-sesame-2.0-sources.jar"/>
+	<classpathentry kind="lib" path="/Users/Christian/Sites/DBpediaMobile/simile-fresnel/target/fsl-core-0.6.5.jar"/>
+	<classpathentry kind="lib" path="/Users/Christian/Sites/DBpediaMobile/simile-fresnel/target/fresnel-vocabularies-1.2-alpha-SNAPSHOT.jar"/>
+	<classpathentry combineaccessrules="false" kind="src" path="/isaviz-fsl"/>
+	<classpathentry kind="output" path="target/classes"/>
+</classpath>
Index: trunk/simile-fresnel/fresnel.bat
===================================================================
--- trunk/simile-fresnel/fresnel.bat (revision 3)
+++ trunk/simile-fresnel/fresnel.bat (revision 3)
@@ -0,0 +1,12 @@
+set JAVA_HOME="C:\programme\java\jdk1.6.0_02"
+set FRESNEL_HOME="C:\work\work\projekte\diplomarbeit\simile-fresnel"
+::set JAVA_OPTIONS="-Xms32M -Xmx512M"
+set JAVA_OPTIONS=
+
+set JAVA="%JAVA_HOME%/bin/java"
+set ENDORSED_LIBS="%FRESNEL_HOME%/lib/endorsed"
+set ENDORSED="-Djava.endorsed.dirs=%ENDORSED_LIBS%"
+set PARSER=-Dorg.xml.sax.parser=org.apache.xerces.parsers.SAXParser
+set CP="`echo %FRESNEL_HOME%/target/*.jar | tr ' ' %PATHSEP%`"
+
+%JAVA% %JAVA_OPTIONS% -cp %CP% %ENDORSED% %PARSER% edu.mit.simile.fresnel.Fresnel %ARGS%
Index: trunk/simile-fresnel/package.sh
===================================================================
--- trunk/simile-fresnel/package.sh (revision 3)
+++ trunk/simile-fresnel/package.sh (revision 3)
@@ -0,0 +1,1 @@
+mvn -Dmaven.test.skip=true package
Index: trunk/simile-fresnel/deploy.sh
===================================================================
--- trunk/simile-fresnel/deploy.sh (revision 76)
+++ trunk/simile-fresnel/deploy.sh (revision 76)
@@ -0,0 +1,2 @@
+mvn -Dmaven.test.skip=true package
+cp target/fresnel-* ../Marbles/web/WEB-INF/lib
Index: trunk/simile-fresnel/bootstrap.xml
===================================================================
--- trunk/simile-fresnel/bootstrap.xml (revision 2)
+++ trunk/simile-fresnel/bootstrap.xml (revision 19)
@@ -1,257 +1,257 @@
 <?xml version='1.0' encoding='UTF-8'?>
 <project>
   <modelVersion>4.0.0</modelVersion>
   <groupId>edu.mit.simile</groupId>
   <artifactId>fresnel</artifactId>
   <name>SIMILE Fresnel Engine</name>
   <version>1.4-alpha-SNAPSHOT</version>
   <url>http://simile.mit.edu/repository/fresnel/trunk/</url>
   <repositories>
     <repository>
       <releases>
         <enabled>true</enabled>
         <updatePolicy>always</updatePolicy>
         <checksumPolicy>warn</checksumPolicy>
       </releases>
       <snapshots>
         <enabled>false</enabled>
         <updatePolicy>never</updatePolicy>
         <checksumPolicy>fail</checksumPolicy>
       </snapshots>
       <id>aduna-repo</id>
       <name>Aduna Repository</name>
       <url>http://repository.aduna-software.org/maven2</url>
     </repository>
     <repository>
       <releases>
         <enabled>false</enabled>
         <updatePolicy>never</updatePolicy>
         <checksumPolicy>fail</checksumPolicy>
       </releases>
       <snapshots>
         <enabled>true</enabled>
         <updatePolicy>daily</updatePolicy>
         <checksumPolicy>warn</checksumPolicy>
       </snapshots>
       <id>aduna-snapshot-repo</id>
       <name>Aduna Snapshot Repository</name>
       <url>http://repository.aduna-software.org/maven2-snapshots</url>
     </repository>
     <repository>
       <id>central</id>
       <name>Maven Repository</name>
       <url>http://www.ibiblio.org/maven2</url>
     </repository>
     <repository>
       <id>simile</id>
       <name>SIMILE Maven Repository</name>
       <url>http://simile.mit.edu/maven</url>
     </repository>
   </repositories>
   <distributionManagement>
     <repository>
       <id>simile.mit.edu</id>
       <url>scpexe://simile.mit.edu/var/maven</url>
     </repository>
   </distributionManagement>
   <build>
     <plugins>
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-compiler-plugin</artifactId>
         <configuration>
           <source>1.5</source>
           <target>1.5</target>
         </configuration>
       </plugin>
       <plugin>
         <groupId>org.codehaus.mojo</groupId>
         <artifactId>dependency-maven-plugin</artifactId>
         <executions>
           <execution>
             <id>copy-dependencies</id>
             <phase>package</phase>
             <goals>
               <goal>copy-dependencies</goal>
             </goals>
             <configuration>
               <outputDirectory>${project.build.directory}</outputDirectory>
             </configuration>
           </execution>
         </executions>
       </plugin>
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-antrun-plugin</artifactId>
         <executions>
           <execution>
             <id>compile-vocab</id>
             <phase>generate-sources</phase>
             <configuration>
               <tasks>
                 <ant antfile="${basedir}/build.xml" inheritRefs="true">
                   <target name="package-vocabularies"/>
                 </ant>
               </tasks>
             </configuration>
             <goals>
               <goal>run</goal>
             </goals>
           </execution>
 	  <execution>
             <id>compile-engine</id>
             <phase>compile</phase>
             <configuration>
               <tasks>
                 <ant antfile="${basedir}/build.xml" inheritRefs="true">
                   <target name="compile"/>
                 </ant>
               </tasks>
             </configuration>
             <goals>
               <goal>run</goal>
             </goals>
           </execution>
 	  <execution>
             <id>repackage</id>
             <phase>package</phase>
             <configuration>
               <tasks>
                 <ant antfile="${basedir}/build.xml" inheritRefs="true">
                   <target name="package"/>
                 </ant>
                 <ant antfile="${basedir}/build.xml" inheritRefs="true">
                   <target name="package-vocabularies-sources"/>
                 </ant>
                 <ant antfile="${basedir}/build.xml" inheritRefs="true">
                   <target name="package-sources"/>
                 </ant>
               </tasks>
             </configuration>
             <goals>
               <goal>run</goal>
             </goals>
           </execution>
 	  <execution>
             <id>clean-vocabularies</id>
             <phase>clean</phase>
             <configuration>
               <tasks>
                 <ant antfile="${basedir}/build.xml" inheritRefs="true">
                   <target name="clean-vocabularies"/>
                 </ant>
               </tasks>
             </configuration>
             <goals>
               <goal>run</goal>
             </goals>
           </execution>
         </executions>
         <dependencies>
           <dependency>
             <groupId>ant</groupId>
             <artifactId>ant-antlr</artifactId>
             <version>1.6.5</version>
           </dependency>
           <dependency>
             <groupId>antlr</groupId>
             <artifactId>antlrall</artifactId>
             <version>2.7.4</version>
           </dependency>
           <dependency>
             <groupId>ant-contrib</groupId>
             <artifactId>ant-contrib</artifactId>
             <version>20020829</version>
           </dependency>
          <dependency>
             <groupId>org.openrdf</groupId>
             <artifactId>openrdf-model</artifactId>
-            <version>2.0-beta6</version>
+            <version>2.0</version>
           </dependency>
           <dependency>
             <groupId>org.openrdf</groupId>
             <artifactId>openrdf-repository-api</artifactId>
-            <version>2.0-beta6</version>
+            <version>2.0</version>
           </dependency>
           <dependency>
             <groupId>org.openrdf</groupId>
             <artifactId>openrdf-repository-sail</artifactId>
-            <version>2.0-beta6</version>
+            <version>2.0</version>
           </dependency>
           <dependency>
             <groupId>org.openrdf</groupId>
             <artifactId>openrdf-rio-api</artifactId>
-            <version>2.0-beta6</version>
+            <version>2.0</version>
           </dependency>
           <dependency>
             <groupId>org.openrdf</groupId>
             <artifactId>openrdf-rio-rdfxml</artifactId>
-            <version>2.0-beta6</version>
+            <version>2.0</version>
           </dependency>
           <dependency>
             <groupId>org.openrdf</groupId>
             <artifactId>openrdf-rio-n3</artifactId>
-            <version>2.0-beta6</version>
+            <version>2.0</version>
           </dependency>
           <dependency>
             <groupId>org.openrdf</groupId>
             <artifactId>openrdf-rio-ntriples</artifactId>
-            <version>2.0-beta6</version>
+            <version>2.0</version>
           </dependency>
           <dependency>
             <groupId>org.openrdf</groupId>
             <artifactId>openrdf-rio-turtle</artifactId>
-            <version>2.0-beta6</version>
+            <version>2.0</version>
           </dependency>
           <dependency>
             <groupId>org.openrdf</groupId>
             <artifactId>openrdf-sail-memory</artifactId>
-            <version>2.0-beta6</version>
+            <version>2.0</version>
           </dependency>
           <dependency>
             <groupId>log4j</groupId>
             <artifactId>log4j</artifactId>
             <version>1.2.13</version>
           </dependency>
           <dependency>
             <groupId>org.slf4j</groupId>
             <artifactId>slf4j-log4j12</artifactId>
             <version>1.0.1</version>
           </dependency>
           <dependency>
             <groupId>xerces</groupId>
             <artifactId>xercesImpl</artifactId>
             <version>2.8.1</version>
           </dependency>
         </dependencies>
       </plugin>
     </plugins>
   </build>
   <dependencies>
     <dependency>
       <groupId>edu.mit.simile</groupId>
       <artifactId>isaviz-fsl-simile</artifactId>
       <version>0.6.4-SNAPSHOT</version>
     </dependency>
     <dependency>
       <groupId>log4j</groupId>
       <artifactId>log4j</artifactId>
       <version>1.2.13</version>
     </dependency>
     <dependency>
       <groupId>org.slf4j</groupId>
       <artifactId>slf4j-log4j12</artifactId>
       <version>1.0.1</version>
     </dependency>
     <dependency>
       <groupId>velocity</groupId>
       <artifactId>velocity</artifactId>
       <version>1.4</version>
     </dependency>
     <dependency>
       <groupId>commons-collections</groupId>
       <artifactId>commons-collections</artifactId>
       <version>3.0</version>
     </dependency>
   </dependencies>
 </project>
